/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page", {
  /***/ "(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2FUsers%2Faluaorazbek%2FDesktop%2Fcharts%2Fsrc%2Fcomponents%2Fline-chart.tsx%22%2C%22ids%22%3A%5B%22default%22%5D%7D&server=false!":
    /*!***********************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2FUsers%2Faluaorazbek%2FDesktop%2Fcharts%2Fsrc%2Fcomponents%2Fline-chart.tsx%22%2C%22ids%22%3A%5B%22default%22%5D%7D&server=false! ***!
  \***********************************************************************************************************************************************************************************************************************************************************/
    /***/ function (
      __unused_webpack_module,
      __unused_webpack_exports,
      __webpack_require__,
    ) {
      eval(
        __webpack_require__.ts(
          'Promise.resolve(/*! import() eager */).then(__webpack_require__.t.bind(__webpack_require__, /*! ./src/components/line-chart.tsx */ "(app-pages-browser)/./src/components/line-chart.tsx", 23));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtZmxpZ2h0LWNsaWVudC1lbnRyeS1sb2FkZXIuanM/bW9kdWxlcz0lN0IlMjJyZXF1ZXN0JTIyJTNBJTIyJTJGVXNlcnMlMkZhbHVhb3JhemJlayUyRkRlc2t0b3AlMkZjaGFydHMlMkZzcmMlMkZjb21wb25lbnRzJTJGbGluZS1jaGFydC50c3glMjIlMkMlMjJpZHMlMjIlM0ElNUIlMjJkZWZhdWx0JTIyJTVEJTdEJnNlcnZlcj1mYWxzZSEiLCJtYXBwaW5ncyI6IkFBQUEsOExBQWlJIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8/ODE2YSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQoLyogd2VicGFja01vZGU6IFwiZWFnZXJcIiwgd2VicGFja0V4cG9ydHM6IFtcImRlZmF1bHRcIl0gKi8gXCIvVXNlcnMvYWx1YW9yYXpiZWsvRGVza3RvcC9jaGFydHMvc3JjL2NvbXBvbmVudHMvbGluZS1jaGFydC50c3hcIik7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2FUsers%2Faluaorazbek%2FDesktop%2Fcharts%2Fsrc%2Fcomponents%2Fline-chart.tsx%22%2C%22ids%22%3A%5B%22default%22%5D%7D&server=false!\n',
        ),
      );

      /***/
    },

  /***/ "(app-pages-browser)/./src/components/line-chart.tsx":
    /*!***************************************!*\
  !*** ./src/components/line-chart.tsx ***!
  \***************************************/
    /***/ function (module, __unused_webpack_exports, __webpack_require__) {
      eval(
        __webpack_require__.ts(
          "/* __next_internal_client_entry_do_not_use__  auto */  // import React, { useMemo } from 'react'\n // import { extent } from 'd3-array'\n // import { timeFormat } from 'd3-time-format'\n // import { AxisBottom, AxisRight } from '@visx/axis'\n // import { LinePath } from '@visx/shape'\n // import { Group } from '@visx/group'\n // import { scaleLinear, scaleTime } from '@visx/scale'\n // import { GridRows } from \"@visx/grid\";\n // import { curveLinear } from '@visx/curve'\n // import { data } from '../data/line-chart'\n // import { getDimensions, xAccessor, yAccessor } from '#/utils/line-chart'\n // type Props = {\n //   width: number\n //   height: number\n // }\n // function LineChart({ width, height }: Props) {\n //   const { margin, boundedWidth, boundedHeight } = getDimensions({\n //     width,\n //     height,\n //   })\n //   const LpYValue = 54300.2; \n //   const LatestValue = 59980.9;\n //   const xScale = useMemo(\n //     () =>\n //       scaleTime<number>({\n //         domain: extent(data, xAccessor) as [Date, Date],\n //         range: [0, boundedWidth],\n //         nice: true,\n //       }),\n //     [boundedWidth]\n //   )\n //   const yScale = useMemo(\n //     () =>\n //       scaleLinear<number>({\n //         domain: extent(data, yAccessor) as [number, number],\n //         range: [boundedHeight, 0],\n //         nice: true,\n //       }),\n //     [boundedHeight]\n //   )\n //   const customYPosition = yScale(LpYValue); \n //   // Generate y-axis tick values and ensure both LpYValue and LatestValue are included\n //   const yTickValues = yScale.ticks(8);\n //   if (!yTickValues.includes(LpYValue)) {\n //     yTickValues.push(LpYValue);\n //   }\n //   if (!yTickValues.includes(LatestValue)) {\n //     yTickValues.push(LatestValue);\n //   }\n //   return (\n //     <div className=\"w-fit\">\n //       <svg\n //         className=''\n //         width={width}\n //         height={height}\n //         role=\"figure\"\n //       >\n //         <rect\n //             x={0}\n //             y={0}\n //             width={width}\n //             height={height}\n //         />\n //         <title>line chart looking at the distribution of max temperature</title>\n //         <Group top={margin.top} left={margin.left}>\n //           <GridRows\n //             scale={yScale}\n //             width={boundedWidth}\n //             strokeDasharray=\"1,3\"\n //             stroke=\"#262626\"\n //             pointerEvents=\"none\"\n //           />\n //           <LinePath\n //             curve={curveLinear}\n //             data={data}\n //             stroke={\"#FFCA43\"}\n //             strokeWidth={1.5}\n //             x={(d) => xScale(xAccessor(d)) ?? 0}\n //             y={(d) => yScale(yAccessor(d)) ?? 0}\n //           />\n //           {customYPosition && (\n //             <line\n //               x1={0}\n //               x2={boundedWidth}\n //               y1={customYPosition}\n //               y2={customYPosition}\n //               stroke=\"white\"\n //               strokeWidth={1}\n //               strokeDasharray=\"3,5\" \n //             />\n //           )}\n //           <AxisRight\n //             left={boundedWidth + margin.right - 40}\n //             scale={yScale}\n //             top={0}\n //             hideAxisLine={true}\n //             hideTicks={true}\n //             labelOffset={0}\n //             tickValues={yTickValues}\n //             tickFormat={(value) => `${Number(value).toFixed(1)}`} \n //             tickLabelProps={() => ({\n //               fill: '#A6A6A6',\n //               fontSize: 9,\n //               textAnchor: 'start',\n //             })}\n //             tickComponent={({ formattedValue, x, y }) => {\n //               if (formattedValue === undefined) {\n //                 return null; \n //               }\n //               const numFormattedValue = Number(formattedValue); \n //               const isLPValue = numFormattedValue === LpYValue;\n //               const isLatestValue = numFormattedValue === LatestValue;\n //               const text = isLPValue\n //                 ? `LP ${LpYValue.toFixed(1)}`\n //                 : isLatestValue\n //                 ? `${LatestValue.toFixed(1)}`\n //                 : formattedValue;\n //               const paddingX = 8; \n //               const paddingY = 2; \n //               const fontSize = 9;\n //               const textWidth = text.length * (fontSize * 0.6); // Estimate that each character is ~60% of the font size\n //               const rectWidth = textWidth + paddingX; // Add padding for width\n //               const rectHeight = fontSize + paddingY; // Add padding for height\n //               if (isLPValue) {\n //                 return (\n //                   <g transform={`translate(${x},${y})`}>\n //                     <rect\n //                       x={-rectWidth / 2} \n //                       y={-rectHeight / 2}\n //                       width={rectWidth}\n //                       height={rectHeight}\n //                       fill=\"#4d4d4d\"\n //                       rx={0} \n //                     />\n //                     <text\n //                       fill=\"white\"\n //                       fontSize={fontSize}\n //                       textAnchor=\"middle\"\n //                       dy=\"0.32em\"\n //                       x={0} \n //                     >\n //                       LP {LpYValue.toFixed(1)}\n //                     </text>\n //                   </g>\n //                 );\n //               } else if (isLatestValue) {\n //                 return (\n //                   <g transform={`translate(${x},${y})`}>\n //                     <rect\n //                       x={-rectWidth / 2} \n //                       y={-rectHeight / 2}\n //                       width={rectWidth}\n //                       height={rectHeight}\n //                       fill=\"white\"\n //                       rx={0} \n //                     />\n //                     <text\n //                       fill=\"black\"\n //                       fontWeight=\"700\"\n //                       fontSize={fontSize}\n //                       textAnchor=\"middle\"\n //                       dy=\"0.32em\"\n //                       x={0}\n //                     >\n //                       {LatestValue.toFixed(1)}\n //                     </text>\n //                   </g>\n //                 );\n //               } else {\n //                 return (\n //                   <text\n //                     fill=\"#A6A6A6\"\n //                     fontSize={fontSize}\n //                     textAnchor=\"start\"\n //                     dy=\"0.32em\"\n //                     x={-10}\n //                     y={y}\n //                   >\n //                     {text}\n //                   </text>\n //                 );\n //               }\n //             }}\n //           />\n //           <AxisBottom\n //             rangePadding={41}\n //             top={boundedHeight}\n //             hideAxisLine={true}\n //             hideTicks={true}\n //             scale={xScale}\n //             tickFormat={(d) => {\n //               return d instanceof Date ? timeFormat('%H:%M')(d) : '';\n //             }}\n //             tickLabelProps={() => ({\n //               fill: 'white',\n //               fontSize: 8,\n //               textAnchor: 'middle',\n //             })}\n //           />\n //         </Group>\n //       </svg>\n //     </div>\n //   )\n // }\n // export { LineChart }\n // 'use client'\n // import React, { useMemo, useCallback } from 'react';\n // import { extent, bisector, max, min } from 'd3-array';\n // import { timeFormat } from 'd3-time-format';\n // import { AxisBottom, AxisRight } from '@visx/axis';\n // import { LinePath } from '@visx/shape';\n // import { Group } from '@visx/group';\n // import { scaleLinear, scaleTime } from '@visx/scale';\n // import { GridRows } from '@visx/grid';\n // import { curveLinear } from '@visx/curve';\n // import { useTooltip, TooltipWithBounds } from '@visx/tooltip';\n // import { localPoint } from '@visx/event';\n // import { data } from '../data/line-chart';\n // import { getDimensions, xAccessor, yAccessor } from '#/utils/line-chart';\n // type Props = {\n //   width: number;\n //   height: number;\n // };\n // function LineChart({ width, height }: Props) {\n //   const { margin, boundedWidth, boundedHeight } = getDimensions({\n //     width,\n //     height,\n //   });\n //   const LpYValue = 54300.2;\n //   const LatestValue = 59980.9;\n //   const xScale = useMemo(\n //     () =>\n //       scaleTime<number>({\n //         domain: extent(data, xAccessor) as [Date, Date],\n //         range: [0, boundedWidth],\n //         nice: true,\n //       }),\n //     [boundedWidth]\n //   );\n //   const yScale = useMemo(\n //     () =>\n //       scaleLinear<number>({\n //         domain: extent(data, yAccessor) as [number, number],\n //         range: [boundedHeight, 0],\n //         nice: true,\n //       }),\n //     [boundedHeight]\n //   );\n //   const { showTooltip, hideTooltip, tooltipData, tooltipLeft, tooltipTop } = useTooltip();\n //   const handleTooltip = useCallback(\n //     (event: React.MouseEvent) => {\n //       const { x } = localPoint(event) || { x: 0 };\n //       const x0 = xScale.invert(x - margin.left); // Get the date from x position\n //       const bisectDate = bisector(xAccessor).left;\n //       const index = bisectDate(data, x0, 1);\n //       const d0 = data[index - 1];\n //       const d1 = data[index];\n //       const d = x0 - xAccessor(d0) > xAccessor(d1) - x0 ? d1 : d0; // Get closest data point\n //       showTooltip({\n //         tooltipData: d,\n //         tooltipLeft: xScale(xAccessor(d)),\n //         tooltipTop: yScale(yAccessor(d)),\n //       });\n //     },\n //     [xScale, yScale, showTooltip]\n //   );\n //   const customYPosition = yScale(LpYValue);\n //   const yTickValues = yScale.ticks(8);\n //   if (!yTickValues.includes(LpYValue)) yTickValues.push(LpYValue);\n //   if (!yTickValues.includes(LatestValue)) yTickValues.push(LatestValue);\n //   return (\n //     <div className=\"w-fit\">\n //       <svg className=\"\" width={width} height={height} role=\"figure\">\n //         <rect x={0} y={0} width={width} height={height} />\n //         <Group top={margin.top} left={margin.left}>\n //           <GridRows\n //             scale={yScale}\n //             width={boundedWidth}\n //             strokeDasharray=\"1,3\"\n //             stroke=\"#262626\"\n //             pointerEvents=\"none\"\n //           />\n //           <LinePath\n //             curve={curveLinear}\n //             data={data}\n //             stroke={'#FFCA43'}\n //             strokeWidth={1.5}\n //             x={(d) => xScale(xAccessor(d)) ?? 0}\n //             y={(d) => yScale(yAccessor(d)) ?? 0}\n //           />\n //           {customYPosition && (\n //             <line\n //               x1={0}\n //               x2={boundedWidth}\n //               y1={customYPosition}\n //               y2={customYPosition}\n //               stroke=\"white\"\n //               strokeWidth={1}\n //               strokeDasharray=\"3,5\"\n //             />\n //           )}\n //           <AxisRight\n //             left={boundedWidth + margin.right - 40}\n //             scale={yScale}\n //             top={0}\n //             hideAxisLine={true}\n //             hideTicks={true}\n //             tickValues={yTickValues}\n //             tickFormat={(value) => `${Number(value).toFixed(1)}`}\n //             tickLabelProps={() => ({\n //               fill: '#A6A6A6',\n //               fontSize: 9,\n //               textAnchor: 'start',\n //             })}\n //             tickComponent={({ formattedValue, x, y }) => {\n //                             if (formattedValue === undefined) {\n //                               return null; \n //                             }\n //                             const numFormattedValue = Number(formattedValue); \n //                             const isLPValue = numFormattedValue === LpYValue;\n //                             const isLatestValue = numFormattedValue === LatestValue;\n //                             const text = isLPValue\n //                               ? `LP ${LpYValue.toFixed(1)}`\n //                               : isLatestValue\n //                               ? `${LatestValue.toFixed(1)}`\n //                               : formattedValue;\n //                             const paddingX = 8; \n //                             const paddingY = 2; \n //                             const fontSize = 9;\n //                             const textWidth = text.length * (fontSize * 0.6); // Estimate that each character is ~60% of the font size\n //                             const rectWidth = textWidth + paddingX; // Add padding for width\n //                             const rectHeight = fontSize + paddingY; // Add padding for height\n //                             if (isLPValue) {\n //                               return (\n //                                 <g transform={`translate(${x},${y})`}>\n //                                   <rect\n //                                     x={-rectWidth / 2} \n //                                     y={-rectHeight / 2}\n //                                     width={rectWidth}\n //                                     height={rectHeight}\n //                                     fill=\"#4d4d4d\"\n //                                     rx={0} \n //                                   />\n //                                   <text\n //                                     fill=\"white\"\n //                                     fontSize={fontSize}\n //                                     textAnchor=\"middle\"\n //                                     dy=\"0.32em\"\n //                                     x={0} \n //                                   >\n //                                     LP {LpYValue.toFixed(1)}\n //                                   </text>\n //                                 </g>\n //                               );\n //                             } else if (isLatestValue) {\n //                               return (\n //                                 <g transform={`translate(${x},${y})`}>\n //                                   <rect\n //                                     x={-rectWidth / 2} \n //                                     y={-rectHeight / 2}\n //                                     width={rectWidth}\n //                                     height={rectHeight}\n //                                     fill=\"white\"\n //                                     rx={0} \n //                                   />\n //                                   <text\n //                                     fill=\"black\"\n //                                     fontWeight=\"700\"\n //                                     fontSize={fontSize}\n //                                     textAnchor=\"middle\"\n //                                     dy=\"0.32em\"\n //                                     x={0}\n //                                   >\n //                                     {LatestValue.toFixed(1)}\n //                                   </text>\n //                                 </g>\n //                               );\n //                             } else {\n //                               return (\n //                                 <text\n //                                   fill=\"#A6A6A6\"\n //                                   fontSize={fontSize}\n //                                   textAnchor=\"start\"\n //                                   dy=\"0.32em\"\n //                                   x={-10}\n //                                   y={y}\n //                                 >\n //                                   {text}\n //                                 </text>\n //                               );\n //                             }\n //                           }}\n //           />\n //           <AxisBottom\n //             rangePadding={41}\n //             top={boundedHeight}\n //             hideAxisLine={true}\n //             hideTicks={true}\n //             scale={xScale}\n //             tickFormat={(d) => (d instanceof Date ? timeFormat('%H:%M')(d) : '')}\n //             tickLabelProps={() => ({\n //               fill: 'white',\n //               fontSize: 8,\n //               textAnchor: 'middle',\n //             })}\n //           />\n //           <rect\n //             x={0}\n //             y={0}\n //             width={boundedWidth}\n //             height={boundedHeight}\n //             fill=\"transparent\"\n //             onMouseMove={handleTooltip}\n //             onMouseLeave={() => hideTooltip()}\n //           />\n //         </Group>\n //         {tooltipData && (\n //           <circle\n //             cx={tooltipLeft}\n //             cy={tooltipTop}\n //             r={5}\n //             stroke=\"black\"\n //             fill=\"#ffcb8f\"\n //             strokeWidth={2}\n //             pointerEvents=\"none\"\n //           />\n //         )}\n //       </svg>\n //       {tooltipData && (\n //         <TooltipWithBounds\n //           top={tooltipTop - 12}\n //           left={tooltipLeft + 12}\n //           style={{\n //             backgroundColor: '#4d4d4d',\n //             color: 'white',\n //             padding: '0.5rem',\n //             borderRadius: '4px',\n //             fontSize: '10px',\n //           }}\n //         >\n //           <div>Date: {timeFormat('%b %d, %Y')(xAccessor(tooltipData))}</div>\n //           <div>Value: {yAccessor(tooltipData)}</div>\n //         </TooltipWithBounds>\n //       )}\n //     </div>\n //   );\n // }\n // export { LineChart };\n // import React, { useMemo } from 'react'\n // import { extent } from 'd3-array'\n // import { timeFormat } from 'd3-time-format'\n // import { AxisBottom, AxisRight } from '@visx/axis'\n // import { LinePath } from '@visx/shape'\n // import { Group } from '@visx/group'\n // import { scaleLinear, scaleTime } from '@visx/scale'\n // import { GridRows } from \"@visx/grid\";\n // import { curveLinear } from '@visx/curve'\n // import { data } from '../data/line-chart'\n // import { getDimensions, xAccessor, yAccessor } from '#/utils/line-chart'\n // type Props = {\n //   width: number\n //   height: number\n // }\n // function LineChart({ width, height }: Props) {\n //   const { margin, boundedWidth, boundedHeight } = getDimensions({\n //     width,\n //     height,\n //   })\n //   const LpYValue = 54300.2; \n //   const LatestValue = 59980.9;\n //   const xScale = useMemo(\n //     () =>\n //       scaleTime<number>({\n //         domain: extent(data, xAccessor) as [Date, Date],\n //         range: [0, boundedWidth],\n //         nice: true,\n //       }),\n //     [boundedWidth]\n //   )\n //   const yScale = useMemo(\n //     () =>\n //       scaleLinear<number>({\n //         domain: extent(data, yAccessor) as [number, number],\n //         range: [boundedHeight, 0],\n //         nice: true,\n //       }),\n //     [boundedHeight]\n //   )\n //   const customYPosition = yScale(LpYValue); \n //   // Generate y-axis tick values and ensure both LpYValue and LatestValue are included\n //   const yTickValues = yScale.ticks(8);\n //   if (!yTickValues.includes(LpYValue)) {\n //     yTickValues.push(LpYValue);\n //   }\n //   if (!yTickValues.includes(LatestValue)) {\n //     yTickValues.push(LatestValue);\n //   }\n //   return (\n //     <div className=\"w-fit\">\n //       <svg\n //         className=''\n //         width={width}\n //         height={height}\n //         role=\"figure\"\n //       >\n //         <rect\n //             x={0}\n //             y={0}\n //             width={width}\n //             height={height}\n //         />\n //         <title>line chart looking at the distribution of max temperature</title>\n //         <Group top={margin.top} left={margin.left}>\n //           <GridRows\n //             scale={yScale}\n //             width={boundedWidth}\n //             strokeDasharray=\"1,3\"\n //             stroke=\"#262626\"\n //             pointerEvents=\"none\"\n //           />\n //           <LinePath\n //             curve={curveLinear}\n //             data={data}\n //             stroke={\"#FFCA43\"}\n //             strokeWidth={1.5}\n //             x={(d) => xScale(xAccessor(d)) ?? 0}\n //             y={(d) => yScale(yAccessor(d)) ?? 0}\n //           />\n //           {customYPosition && (\n //             <line\n //               x1={0}\n //               x2={boundedWidth}\n //               y1={customYPosition}\n //               y2={customYPosition}\n //               stroke=\"white\"\n //               strokeWidth={1}\n //               strokeDasharray=\"3,5\" \n //             />\n //           )}\n //           <AxisRight\n //             left={boundedWidth + margin.right - 40}\n //             scale={yScale}\n //             top={0}\n //             hideAxisLine={true}\n //             hideTicks={true}\n //             labelOffset={0}\n //             tickValues={yTickValues}\n //             tickFormat={(value) => `${Number(value).toFixed(1)}`} \n //             tickLabelProps={() => ({\n //               fill: '#A6A6A6',\n //               fontSize: 9,\n //               textAnchor: 'start',\n //             })}\n //             tickComponent={({ formattedValue, x, y }) => {\n //               if (formattedValue === undefined) {\n //                 return null; \n //               }\n //               const numFormattedValue = Number(formattedValue); \n //               const isLPValue = numFormattedValue === LpYValue;\n //               const isLatestValue = numFormattedValue === LatestValue;\n //               const text = isLPValue\n //                 ? `LP ${LpYValue.toFixed(1)}`\n //                 : isLatestValue\n //                 ? `${LatestValue.toFixed(1)}`\n //                 : formattedValue;\n //               const paddingX = 8; \n //               const paddingY = 2; \n //               const fontSize = 9;\n //               const textWidth = text.length * (fontSize * 0.6); // Estimate that each character is ~60% of the font size\n //               const rectWidth = textWidth + paddingX; // Add padding for width\n //               const rectHeight = fontSize + paddingY; // Add padding for height\n //               if (isLPValue) {\n //                 return (\n //                   <g transform={`translate(${x},${y})`}>\n //                     <rect\n //                       x={-rectWidth / 2} \n //                       y={-rectHeight / 2}\n //                       width={rectWidth}\n //                       height={rectHeight}\n //                       fill=\"#4d4d4d\"\n //                       rx={0} \n //                     />\n //                     <text\n //                       fill=\"white\"\n //                       fontSize={fontSize}\n //                       textAnchor=\"middle\"\n //                       dy=\"0.32em\"\n //                       x={0} \n //                     >\n //                       LP {LpYValue.toFixed(1)}\n //                     </text>\n //                   </g>\n //                 );\n //               } else if (isLatestValue) {\n //                 return (\n //                   <g transform={`translate(${x},${y})`}>\n //                     <rect\n //                       x={-rectWidth / 2} \n //                       y={-rectHeight / 2}\n //                       width={rectWidth}\n //                       height={rectHeight}\n //                       fill=\"white\"\n //                       rx={0} \n //                     />\n //                     <text\n //                       fill=\"black\"\n //                       fontWeight=\"700\"\n //                       fontSize={fontSize}\n //                       textAnchor=\"middle\"\n //                       dy=\"0.32em\"\n //                       x={0}\n //                     >\n //                       {LatestValue.toFixed(1)}\n //                     </text>\n //                   </g>\n //                 );\n //               } else {\n //                 return (\n //                   <text\n //                     fill=\"#A6A6A6\"\n //                     fontSize={fontSize}\n //                     textAnchor=\"start\"\n //                     dy=\"0.32em\"\n //                     x={-10}\n //                     y={y}\n //                   >\n //                     {text}\n //                   </text>\n //                 );\n //               }\n //             }}\n //           />\n //           <AxisBottom\n //             rangePadding={41}\n //             top={boundedHeight}\n //             hideAxisLine={true}\n //             hideTicks={true}\n //             scale={xScale}\n //             tickFormat={(d) => {\n //               return d instanceof Date ? timeFormat('%H:%M')(d) : '';\n //             }}\n //             tickLabelProps={() => ({\n //               fill: 'white',\n //               fontSize: 8,\n //               textAnchor: 'middle',\n //             })}\n //           />\n //         </Group>\n //       </svg>\n //     </div>\n //   )\n // }\n // export { LineChart }\n // 'use client'\n // import React, { useMemo, useCallback } from 'react';\n // import { extent, bisector, max, min } from 'd3-array';\n // import { timeFormat } from 'd3-time-format';\n // import { AxisBottom, AxisRight } from '@visx/axis';\n // import { LinePath } from '@visx/shape';\n // import { Group } from '@visx/group';\n // import { scaleLinear, scaleTime } from '@visx/scale';\n // import { GridRows } from '@visx/grid';\n // import { curveLinear } from '@visx/curve';\n // import { useTooltip, TooltipWithBounds } from '@visx/tooltip';\n // import { localPoint } from '@visx/event';\n // import { data } from '../data/line-chart';\n // import { getDimensions, xAccessor, yAccessor } from '#/utils/line-chart';\n // type Props = {\n //   width: number;\n //   height: number;\n // };\n // function LineChart({ width, height }: Props) {\n //   const { margin, boundedWidth, boundedHeight } = getDimensions({\n //     width,\n //     height,\n //   });\n //   const LpYValue = 54300.2;\n //   const LatestValue = 59980.9;\n //   const xScale = useMemo(\n //     () =>\n //       scaleTime<number>({\n //         domain: extent(data, xAccessor) as [Date, Date],\n //         range: [0, boundedWidth],\n //         nice: true,\n //       }),\n //     [boundedWidth]\n //   );\n //   const yScale = useMemo(\n //     () =>\n //       scaleLinear<number>({\n //         domain: extent(data, yAccessor) as [number, number],\n //         range: [boundedHeight, 0],\n //         nice: true,\n //       }),\n //     [boundedHeight]\n //   );\n //   const { showTooltip, hideTooltip, tooltipData, tooltipLeft, tooltipTop } = useTooltip();\n //   const handleTooltip = useCallback(\n //     (event: React.MouseEvent) => {\n //       const { x } = localPoint(event) || { x: 0 };\n //       const x0 = xScale.invert(x ); // Correctly handle margin offset\n //       const bisectDate = bisector(xAccessor).left;\n //       const index = bisectDate(data, x0, 1);\n //       const d0 = data[index - 1];\n //       const d1 = data[index];\n //       let d = d0;\n //       if (d1 && xAccessor(d1)) {\n //         d = x0 - xAccessor(d0) > xAccessor(d1) - x0 ? d1 : d0;\n //       }\n //       showTooltip({\n //         tooltipData: d,\n //         tooltipLeft: xScale(xAccessor(d)),\n //         tooltipTop: yScale(yAccessor(d)),\n //       });\n //     },\n //     [xScale, yScale, showTooltip]\n //   );\n //   const customYPosition = yScale(LpYValue);\n //   const yTickValues = yScale.ticks(8);\n //   if (!yTickValues.includes(LpYValue)) yTickValues.push(LpYValue);\n //   if (!yTickValues.includes(LatestValue)) yTickValues.push(LatestValue);\n //   return (\n //     <div className=\"w-fit\">\n //       <svg className=\"\" width={width} height={height} role=\"figure\">\n //         <rect x={0} y={0} width={width} height={height} />\n //         <Group top={margin.top} left={margin.left}>\n //           <GridRows\n //             scale={yScale}\n //             width={boundedWidth}\n //             strokeDasharray=\"1,3\"\n //             stroke=\"#262626\"\n //             pointerEvents=\"none\"\n //           />\n //           <LinePath\n //             curve={curveLinear}\n //             data={data}\n //             stroke={'#FFCA43'}\n //             strokeWidth={1.5}\n //             x={(d) => xScale(xAccessor(d)) ?? 0}\n //             y={(d) => yScale(yAccessor(d)) ?? 0}\n //           />\n //           {customYPosition && (\n //             <line\n //               x1={0}\n //               x2={boundedWidth}\n //               y1={customYPosition}\n //               y2={customYPosition}\n //               stroke=\"white\"\n //               strokeWidth={1}\n //               strokeDasharray=\"3,5\"\n //             />\n //           )}\n //           <AxisRight\n //             left={boundedWidth + margin.right - 40}\n //             scale={yScale}\n //             top={0}\n //             hideAxisLine={true}\n //             hideTicks={true}\n //             tickValues={yTickValues}\n //             tickFormat={(value) => `${Number(value).toFixed(1)}`}\n //             tickLabelProps={() => ({\n //               fill: '#A6A6A6',\n //               fontSize: 9,\n //               textAnchor: 'start',\n //             })}\n //             tickComponent={({\n //               formattedValue, x, y }) => {\n //                 if (formattedValue === undefined) {\n //                   return null; \n //                 }\n //                 const numFormattedValue = Number(formattedValue); \n //                 const isLPValue = numFormattedValue === LpYValue;\n //                 const isLatestValue = numFormattedValue === LatestValue;\n //                 const text = isLPValue\n //                   ? `LP ${LpYValue.toFixed(1)}`\n //                   : isLatestValue\n //                   ? `${LatestValue.toFixed(1)}`\n //                   : formattedValue;\n //                 const paddingX = 8; \n //                 const paddingY = 2; \n //                 const fontSize = 9;\n //                 const textWidth = text.length * (fontSize * 0.6); // Estimate that each character is ~60% of the font size\n //                 const rectWidth = textWidth + paddingX; // Add padding for width\n //                 const rectHeight = fontSize + paddingY; // Add padding for height\n //                 if (isLPValue) {\n //                   return (\n //                     <g transform={`translate(${x},${y})`}>\n //                       <rect\n //                         x={-rectWidth / 2} \n //                         y={-rectHeight / 2}\n //                         width={rectWidth}\n //                         height={rectHeight}\n //                         fill=\"#4d4d4d\"\n //                         rx={0} \n //                       />\n //                       <text\n //                         fill=\"white\"\n //                         fontSize={fontSize}\n //                         textAnchor=\"middle\"\n //                         dy=\"0.32em\"\n //                         x={0} \n //                       >\n //                         LP {LpYValue.toFixed(1)}\n //                       </text>\n //                     </g>\n //                   );\n //                 } else if (isLatestValue) {\n //                   return (\n //                     <g transform={`translate(${x},${y})`}>\n //                       <rect\n //                         x={-rectWidth / 2} \n //                         y={-rectHeight / 2}\n //                         width={rectWidth}\n //                         height={rectHeight}\n //                         fill=\"white\"\n //                         rx={0} \n //                       />\n //                       <text\n //                         fill=\"black\"\n //                         fontWeight=\"700\"\n //                         fontSize={fontSize}\n //                         textAnchor=\"middle\"\n //                         dy=\"0.32em\"\n //                         x={0}\n //                       >\n //                         {LatestValue.toFixed(1)}\n //                       </text>\n //                     </g>\n //                   );\n //                 } else {\n //                   return (\n //                     <text\n //                       fill=\"#A6A6A6\"\n //                       fontSize={fontSize}\n //                       textAnchor=\"start\"\n //                       dy=\"0.32em\"\n //                       x={-10}\n //                       y={y}\n //                     >\n //                       {text}\n //                     </text>\n //                   );\n //                 }\n //             }}\n //           />\n //           <AxisBottom\n //             rangePadding={41}\n //             top={boundedHeight}\n //             hideAxisLine={true}\n //             hideTicks={true}\n //             scale={xScale}\n //             tickFormat={(d) => (d instanceof Date ? timeFormat('%H:%M')(d) : '')}\n //             tickLabelProps={() => ({\n //               fill: 'white',\n //               fontSize: 8,\n //               textAnchor: 'middle',\n //             })}\n //           />\n //           <rect\n //             x={0}\n //             y={0}\n //             width={boundedWidth}\n //             height={boundedHeight}\n //             fill=\"transparent\"\n //             onMouseMove={handleTooltip}\n //             onMouseLeave={() => hideTooltip()}\n //           />\n //         </Group>\n //         {tooltipData && (\n //           <circle\n //             cx={tooltipLeft + 14}\n //             cy={tooltipTop + 12 }\n //             r={5}\n //             stroke=\"black\"\n //             fill=\"#ffcb8f\"\n //             strokeWidth={2}\n //             pointerEvents=\"none\"\n //           />\n //         )}\n //       </svg>\n //       {tooltipData && (\n //         <TooltipWithBounds\n //           top={tooltipTop-250}\n //           left={tooltipLeft}\n //           style={{\n //             width: '120px',\n //             backgroundColor: '#4d4d4d',\n //             color: 'white',\n //             padding: '0.5rem',\n //             borderRadius: '4px',\n //             fontSize: '10px',\n //           }}\n //         >\n //           <div>Date: {timeFormat('%b %d, %Y')(xAccessor(tooltipData))}</div>\n //           <div>Value: {yAccessor(tooltipData)}</div>\n //         </TooltipWithBounds>\n //       )}\n //     </div>\n //   );\n // }\n // export { LineChart };\n // import React, { useMemo, useCallback } from 'react';\n // import { extent, bisector } from 'd3-array';\n // import { timeFormat } from 'd3-time-format';\n // import { AxisBottom, AxisRight } from '@visx/axis';\n // import { LinePath, Bar } from '@visx/shape';\n // import { Group } from '@visx/group';\n // import { scaleLinear, scaleTime } from '@visx/scale';\n // import { GridRows } from \"@visx/grid\";\n // import { curveLinear } from '@visx/curve';\n // import { withTooltip, TooltipWithBounds, defaultStyles } from '@visx/tooltip';\n // import { localPoint } from '@visx/event';\n // import { data } from '../data/line-chart';\n // import { getDimensions, xAccessor, yAccessor } from '#/utils/line-chart';\n // const formatDate = timeFormat('%b %d, %H:%M');\n // const tooltipStyles = {\n //   ...defaultStyles,\n //   background: 'rgba(0, 0, 0, 0.9)',\n //   borderRadius: '4px',\n //   color: 'white',\n // };\n // const bisectDate = bisector(d => xAccessor(d)).left;\n // type Props = {\n //   width: number;\n //   height: number;\n // };\n // function LineChart({ width, height, showTooltip, hideTooltip, tooltipData, tooltipLeft, tooltipTop }: Props & any) {\n //   const { margin, boundedWidth, boundedHeight } = getDimensions({ width, height });\n //   const LpYValue = 54300.2; \n //   const LatestValue = 59980.9;\n //   const xScale = useMemo(() => scaleTime({\n //     domain: extent(data, xAccessor) as [Date, Date],\n //     range: [0, boundedWidth],\n //     nice: true,\n //   }), [boundedWidth]);\n //   const yScale = useMemo(() => scaleLinear({\n //     domain: extent(data, yAccessor) as [number, number],\n //     range: [boundedHeight, 0],\n //     nice: true,\n //   }), [boundedHeight]);\n //   const handleTooltip = useCallback((event) => {\n //     const { x } = localPoint(event) || { x: 0 };\n //     const x0 = xScale.invert(x);\n //     const index = bisectDate(data, x0, 1);\n //     const d0 = data[index - 1];\n //     const d1 = data[index];\n //     let d = d0;\n //     if (d1 && xAccessor(d1)) {\n //       d = x0.valueOf() - xAccessor(d0).valueOf() > xAccessor(d1).valueOf() - x0.valueOf() ? d1 : d0;\n //     }\n //     showTooltip({\n //       tooltipData: d,\n //       tooltipLeft: x,\n //       tooltipTop: yScale(yAccessor(d)),\n //     });\n //   }, [showTooltip, yScale, xScale]);\n //   const customYPosition = yScale(LpYValue); \n //   const yTickValues = yScale.ticks(8);\n //   if (!yTickValues.includes(LpYValue)) {\n //     yTickValues.push(LpYValue);\n //   }\n //   if (!yTickValues.includes(LatestValue)) {\n //     yTickValues.push(LatestValue);\n //   }\n //   return (\n //     <div className=\"w-fit\">\n //       <svg width={width} height={height} role=\"figure\">\n //         <rect x={0} y={0} width={width} height={height} fill=\"transparent\" />\n //         <Group top={margin.top} left={margin.left}>\n //           <GridRows scale={yScale} width={boundedWidth} strokeDasharray=\"1,3\" stroke=\"#262626\" pointerEvents=\"none\" />\n //           <LinePath\n //             curve={curveLinear}\n //             data={data}\n //             stroke={\"#FFCA43\"}\n //             strokeWidth={1.5}\n //             x={(d) => xScale(xAccessor(d)) ?? 0}\n //             y={(d) => yScale(yAccessor(d)) ?? 0}\n //           />\n //           <Bar\n //             x={0}\n //             y={0}\n //             width={boundedWidth}\n //             height={boundedHeight}\n //             fill=\"transparent\"\n //             onMouseMove={handleTooltip}\n //             onMouseLeave={hideTooltip}\n //           />\n //           {customYPosition && (\n //             <line\n //               x1={0}\n //               x2={boundedWidth}\n //               y1={customYPosition}\n //               y2={customYPosition}\n //               stroke=\"white\"\n //               strokeWidth={1}\n //               strokeDasharray=\"3,5\"\n //             />\n //           )}\n //           <AxisRight\n //             left={boundedWidth + margin.right - 40}\n //             scale={yScale}\n //             top={0}\n //             hideAxisLine={true}\n //             hideTicks={true}\n //             tickValues={yTickValues}\n //             tickFormat={(value) => `${Number(value).toFixed(1)}`}\n //             tickLabelProps={() => ({\n //               fill: '#A6A6A6',\n //               fontSize: 9,\n //               textAnchor: 'start',\n //             })}\n //             tickComponent={({ formattedValue, x, y }) => {\n //               if (formattedValue === undefined) return null;\n //               const numFormattedValue = Number(formattedValue); \n //               const isLPValue = numFormattedValue === LpYValue;\n //               const isLatestValue = numFormattedValue === LatestValue;\n //               const text = isLPValue ? `LP ${LpYValue.toFixed(1)}` : isLatestValue ? `${LatestValue.toFixed(1)}` : formattedValue;\n //               return (\n //                 <text\n //                   fill={isLPValue ? 'white' : isLatestValue ? 'pink' : '#A6A6A6'}\n //                   fontSize={9}\n //                   fontWeight={isLatestValue ? '700' : 'normal'}\n //                   x={x - 10}\n //                   y={y}\n //                 >\n //                   {text}\n //                 </text>\n //               );\n //             }}\n //           />\n //           <AxisBottom\n //             rangePadding={41}\n //             top={boundedHeight}\n //             hideAxisLine={true}\n //             hideTicks={true}\n //             scale={xScale}\n //             tickFormat={(d) => (d instanceof Date ? timeFormat('%H:%M')(d) : '')}\n //             tickLabelProps={() => ({\n //               fill: 'white',\n //               fontSize: 8,\n //               textAnchor: 'middle',\n //             })}\n //           />\n //         </Group>\n //         {tooltipData && (\n //           <g>\n //             <circle cx={tooltipLeft} cy={tooltipTop+10} r={4} fill=\"gray\" stroke=\"black\" strokeWidth={1} />\n //           </g>\n //         )}\n //       </svg>\n //       {tooltipData && (\n //         <div>\n //           <TooltipWithBounds top={tooltipTop} left={tooltipLeft} style={tooltipStyles}>\n //             {`Value: ${yAccessor(tooltipData)}`}\n //           </TooltipWithBounds>\n //         </div>\n //       )}\n //     </div>\n //   );\n // }\n // export default withTooltip(LineChart);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL2xpbmUtY2hhcnQudHN4IiwibWFwcGluZ3MiOiJzREFBQSxDQUVBLHlDQUF5QztDQUN6QyxvQ0FBb0M7Q0FDcEMsOENBQThDO0NBQzlDLHFEQUFxRDtDQUNyRCx5Q0FBeUM7Q0FDekMsc0NBQXNDO0NBQ3RDLHVEQUF1RDtDQUN2RCx5Q0FBeUM7Q0FDekMsNENBQTRDO0NBRTVDLDRDQUE0QztDQUM1QywyRUFBMkU7Q0FFM0UsaUJBQWlCO0NBQ2pCLGtCQUFrQjtDQUNsQixtQkFBbUI7Q0FDbkIsSUFBSTtDQUVKLGlEQUFpRDtDQUNqRCxvRUFBb0U7Q0FDcEUsYUFBYTtDQUNiLGNBQWM7Q0FDZCxPQUFPO0NBRVAsK0JBQStCO0NBQy9CLGlDQUFpQztDQUVqQyw0QkFBNEI7Q0FDNUIsWUFBWTtDQUNaLDRCQUE0QjtDQUM1QiwyREFBMkQ7Q0FDM0Qsb0NBQW9DO0NBQ3BDLHNCQUFzQjtDQUN0QixZQUFZO0NBQ1oscUJBQXFCO0NBQ3JCLE1BQU07Q0FFTiw0QkFBNEI7Q0FDNUIsWUFBWTtDQUNaLDhCQUE4QjtDQUM5QiwrREFBK0Q7Q0FDL0QscUNBQXFDO0NBQ3JDLHNCQUFzQjtDQUN0QixZQUFZO0NBQ1osc0JBQXNCO0NBQ3RCLE1BQU07Q0FFTiwrQ0FBK0M7Q0FFL0MseUZBQXlGO0NBQ3pGLHlDQUF5QztDQUV6QywyQ0FBMkM7Q0FDM0Msa0NBQWtDO0NBQ2xDLE1BQU07Q0FDTiw4Q0FBOEM7Q0FDOUMscUNBQXFDO0NBQ3JDLE1BQU07Q0FFTixhQUFhO0NBQ2IsOEJBQThCO0NBQzlCLGFBQWE7Q0FDYix1QkFBdUI7Q0FDdkIsd0JBQXdCO0NBQ3hCLDBCQUEwQjtDQUMxQix3QkFBd0I7Q0FDeEIsVUFBVTtDQUNWLGdCQUFnQjtDQUNoQixvQkFBb0I7Q0FDcEIsb0JBQW9CO0NBQ3BCLDRCQUE0QjtDQUM1Qiw4QkFBOEI7Q0FDOUIsYUFBYTtDQUNiLG1GQUFtRjtDQUNuRixzREFBc0Q7Q0FDdEQsc0JBQXNC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b3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2NvbXBvbmVudHMvbGluZS1jaGFydC50c3g/Yzg1YyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCdcblxuLy8gaW1wb3J0IFJlYWN0LCB7IHVzZU1lbW8gfSBmcm9tICdyZWFjdCdcbi8vIGltcG9ydCB7IGV4dGVudCB9IGZyb20gJ2QzLWFycmF5J1xuLy8gaW1wb3J0IHsgdGltZUZvcm1hdCB9IGZyb20gJ2QzLXRpbWUtZm9ybWF0J1xuLy8gaW1wb3J0IHsgQXhpc0JvdHRvbSwgQXhpc1JpZ2h0IH0gZnJvbSAnQHZpc3gvYXhpcydcbi8vIGltcG9ydCB7IExpbmVQYXRoIH0gZnJvbSAnQHZpc3gvc2hhcGUnXG4vLyBpbXBvcnQgeyBHcm91cCB9IGZyb20gJ0B2aXN4L2dyb3VwJ1xuLy8gaW1wb3J0IHsgc2NhbGVMaW5lYXIsIHNjYWxlVGltZSB9IGZyb20gJ0B2aXN4L3NjYWxlJ1xuLy8gaW1wb3J0IHsgR3JpZFJvd3MgfSBmcm9tIFwiQHZpc3gvZ3JpZFwiO1xuLy8gaW1wb3J0IHsgY3VydmVMaW5lYXIgfSBmcm9tICdAdmlzeC9jdXJ2ZSdcblxuLy8gaW1wb3J0IHsgZGF0YSB9IGZyb20gJy4uL2RhdGEvbGluZS1jaGFydCdcbi8vIGltcG9ydCB7IGdldERpbWVuc2lvbnMsIHhBY2Nlc3NvciwgeUFjY2Vzc29yIH0gZnJvbSAnIy91dGlscy9saW5lLWNoYXJ0J1xuXG4vLyB0eXBlIFByb3BzID0ge1xuLy8gICB3aWR0aDogbnVtYmVyXG4vLyAgIGhlaWdodDogbnVtYmVyXG4vLyB9XG5cbi8vIGZ1bmN0aW9uIExpbmVDaGFydCh7IHdpZHRoLCBoZWlnaHQgfTogUHJvcHMpIHtcbi8vICAgY29uc3QgeyBtYXJnaW4sIGJvdW5kZWRXaWR0aCwgYm91bmRlZEhlaWdodCB9ID0gZ2V0RGltZW5zaW9ucyh7XG4vLyAgICAgd2lkdGgsXG4vLyAgICAgaGVpZ2h0LFxuLy8gICB9KVxuXG4vLyAgIGNvbnN0IExwWVZhbHVlID0gNTQzMDAuMjsgXG4vLyAgIGNvbnN0IExhdGVzdFZhbHVlID0gNTk5ODAuOTtcblxuLy8gICBjb25zdCB4U2NhbGUgPSB1c2VNZW1vKFxuLy8gICAgICgpID0+XG4vLyAgICAgICBzY2FsZVRpbWU8bnVtYmVyPih7XG4vLyAgICAgICAgIGRvbWFpbjogZXh0ZW50KGRhdGEsIHhBY2Nlc3NvcikgYXMgW0RhdGUsIERhdGVdLFxuLy8gICAgICAgICByYW5nZTogWzAsIGJvdW5kZWRXaWR0aF0sXG4vLyAgICAgICAgIG5pY2U6IHRydWUsXG4vLyAgICAgICB9KSxcbi8vICAgICBbYm91bmRlZFdpZHRoXVxuLy8gICApXG5cbi8vICAgY29uc3QgeVNjYWxlID0gdXNlTWVtbyhcbi8vICAgICAoKSA9PlxuLy8gICAgICAgc2NhbGVMaW5lYXI8bnVtYmVyPih7XG4vLyAgICAgICAgIGRvbWFpbjogZXh0ZW50KGRhdGEsIHlBY2Nlc3NvcikgYXMgW251bWJlciwgbnVtYmVyXSxcbi8vICAgICAgICAgcmFuZ2U6IFtib3VuZGVkSGVpZ2h0LCAwXSxcbi8vICAgICAgICAgbmljZTogdHJ1ZSxcbi8vICAgICAgIH0pLFxuLy8gICAgIFtib3VuZGVkSGVpZ2h0XVxuLy8gICApXG5cbi8vICAgY29uc3QgY3VzdG9tWVBvc2l0aW9uID0geVNjYWxlKExwWVZhbHVlKTsgXG5cbi8vICAgLy8gR2VuZXJhdGUgeS1heGlzIHRpY2sgdmFsdWVzIGFuZCBlbnN1cmUgYm90aCBMcFlWYWx1ZSBhbmQgTGF0ZXN0VmFsdWUgYXJlIGluY2x1ZGVkXG4vLyAgIGNvbnN0IHlUaWNrVmFsdWVzID0geVNjYWxlLnRpY2tzKDgpO1xuXG4vLyAgIGlmICgheVRpY2tWYWx1ZXMuaW5jbHVkZXMoTHBZVmFsdWUpKSB7XG4vLyAgICAgeVRpY2tWYWx1ZXMucHVzaChMcFlWYWx1ZSk7XG4vLyAgIH1cbi8vICAgaWYgKCF5VGlja1ZhbHVlcy5pbmNsdWRlcyhMYXRlc3RWYWx1ZSkpIHtcbi8vICAgICB5VGlja1ZhbHVlcy5wdXNoKExhdGVzdFZhbHVlKTtcbi8vICAgfVxuXG4vLyAgIHJldHVybiAoXG4vLyAgICAgPGRpdiBjbGFzc05hbWU9XCJ3LWZpdFwiPlxuLy8gICAgICAgPHN2Z1xuLy8gICAgICAgICBjbGFzc05hbWU9Jydcbi8vICAgICAgICAgd2lkdGg9e3dpZHRofVxuLy8gICAgICAgICBoZWlnaHQ9e2hlaWdodH1cbi8vICAgICAgICAgcm9sZT1cImZpZ3VyZVwiXG4vLyAgICAgICA+XG4vLyAgICAgICAgIDxyZWN0XG4vLyAgICAgICAgICAgICB4PXswfVxuLy8gICAgICAgICAgICAgeT17MH1cbi8vICAgICAgICAgICAgIHdpZHRoPXt3aWR0aH1cbi8vICAgICAgICAgICAgIGhlaWdodD17aGVpZ2h0fVxuLy8gICAgICAgICAvPlxuLy8gICAgICAgICA8dGl0bGU+bGluZSBjaGFydCBsb29raW5nIGF0IHRoZSBkaXN0cmlidXRpb24gb2YgbWF4IHRlbXBlcmF0dXJlPC90aXRsZT5cbi8vICAgICAgICAgPEdyb3VwIHRvcD17bWFyZ2luLnRvcH0gbGVmdD17bWFyZ2luLmxlZnR9PlxuLy8gICAgICAgICAgIDxHcmlkUm93c1xuLy8gICAgICAgICAgICAgc2NhbGU9e3lTY2FsZX1cbi8vICAgICAgICAgICAgIHdpZHRoPXtib3VuZGVkV2lkdGh9XG4vLyAgICAgICAgICAgICBzdHJva2VEYXNoYXJyYXk9XCIxLDNcIlxuLy8gICAgICAgICAgICAgc3Ryb2tlPVwiIzI2MjYyNlwiXG4vLyAgICAgICAgICAgICBwb2ludGVyRXZlbnRzPVwibm9uZVwiXG4vLyAgICAgICAgICAgLz5cbi8vICAgICAgICAgICA8TGluZVBhdGhcbi8vICAgICAgICAgICAgIGN1cnZlPXtjdXJ2ZUxpbmVhcn1cbi8vICAgICAgICAgICAgIGRhdGE9e2RhdGF9XG4vLyAgICAgICAgICAgICBzdHJva2U9e1wiI0ZGQ0E0M1wifVxuLy8gICAgICAgICAgICAgc3Ryb2tlV2lkdGg9ezEuNX1cbi8vICAgICAgICAgICAgIHg9eyhkKSA9PiB4U2NhbGUoeEFjY2Vzc29yKGQpKSA/PyAwfVxuLy8gICAgICAgICAgICAgeT17KGQpID0+IHlTY2FsZSh5QWNjZXNzb3IoZCkpID8/IDB9XG4vLyAgICAgICAgICAgLz5cblxuLy8gICAgICAgICAgIHtjdXN0b21ZUG9zaXRpb24gJiYgKFxuLy8gICAgICAgICAgICAgPGxpbmVcbi8vICAgICAgICAgICAgICAgeDE9ezB9XG4vLyAgICAgICAgICAgICAgIHgyPXtib3VuZGVkV2lkdGh9XG4vLyAgICAgICAgICAgICAgIHkxPXtjdXN0b21ZUG9zaXRpb259XG4vLyAgICAgICAgICAgICAgIHkyPXtjdXN0b21ZUG9zaXRpb259XG4vLyAgICAgICAgICAgICAgIHN0cm9rZT1cIndoaXRlXCJcbi8vICAgICAgICAgICAgICAgc3Ryb2tlV2lkdGg9ezF9XG4vLyAgICAgICAgICAgICAgIHN0cm9rZURhc2hhcnJheT1cIjMsNVwiIFxuLy8gICAgICAgICAgICAgLz5cbi8vICAgICAgICAgICApfVxuXG4vLyAgICAgICAgICAgPEF4aXNSaWdodFxuLy8gICAgICAgICAgICAgbGVmdD17Ym91bmRlZFdpZHRoICsgbWFyZ2luLnJpZ2h0IC0gNDB9XG4vLyAgICAgICAgICAgICBzY2FsZT17eVNjYWxlfVxuLy8gICAgICAgICAgICAgdG9wPXswfVxuLy8gICAgICAgICAgICAgaGlkZUF4aXNMaW5lPXt0cnVlfVxuLy8gICAgICAgICAgICAgaGlkZVRpY2tzPXt0cnVlfVxuLy8gICAgICAgICAgICAgbGFiZWxPZmZzZXQ9ezB9XG4vLyAgICAgICAgICAgICB0aWNrVmFsdWVzPXt5VGlja1ZhbHVlc31cbi8vICAgICAgICAgICAgIHRpY2tGb3JtYXQ9eyh2YWx1ZSkgPT4gYCR7TnVtYmVyKHZhbHVlKS50b0ZpeGVkKDEpfWB9IFxuLy8gICAgICAgICAgICAgdGlja0xhYmVsUHJvcHM9eygpID0+ICh7XG4vLyAgICAgICAgICAgICAgIGZpbGw6ICcjQTZBNkE2Jyxcbi8vICAgICAgICAgICAgICAgZm9udFNpemU6IDksXG4vLyAgICAgICAgICAgICAgIHRleHRBbmNob3I6ICdzdGFydCcsXG4vLyAgICAgICAgICAgICB9KX1cbi8vICAgICAgICAgICAgIHRpY2tDb21wb25lbnQ9eyh7IGZvcm1hdHRlZFZhbHVlLCB4LCB5IH0pID0+IHtcbi8vICAgICAgICAgICAgICAgaWYgKGZvcm1hdHRlZFZhbHVlID09PSB1bmRlZmluZWQpIHtcbi8vICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDsgXG4vLyAgICAgICAgICAgICAgIH1cblxuLy8gICAgICAgICAgICAgICBjb25zdCBudW1Gb3JtYXR0ZWRWYWx1ZSA9IE51bWJlcihmb3JtYXR0ZWRWYWx1ZSk7IFxuLy8gICAgICAgICAgICAgICBjb25zdCBpc0xQVmFsdWUgPSBudW1Gb3JtYXR0ZWRWYWx1ZSA9PT0gTHBZVmFsdWU7XG4vLyAgICAgICAgICAgICAgIGNvbnN0IGlzTGF0ZXN0VmFsdWUgPSBudW1Gb3JtYXR0ZWRWYWx1ZSA9PT0gTGF0ZXN0VmFsdWU7XG5cbi8vICAgICAgICAgICAgICAgY29uc3QgdGV4dCA9IGlzTFBWYWx1ZVxuLy8gICAgICAgICAgICAgICAgID8gYExQICR7THBZVmFsdWUudG9GaXhlZCgxKX1gXG4vLyAgICAgICAgICAgICAgICAgOiBpc0xhdGVzdFZhbHVlXG4vLyAgICAgICAgICAgICAgICAgPyBgJHtMYXRlc3RWYWx1ZS50b0ZpeGVkKDEpfWBcbi8vICAgICAgICAgICAgICAgICA6IGZvcm1hdHRlZFZhbHVlO1xuXG4vLyAgICAgICAgICAgICAgIGNvbnN0IHBhZGRpbmdYID0gODsgXG4vLyAgICAgICAgICAgICAgIGNvbnN0IHBhZGRpbmdZID0gMjsgXG4vLyAgICAgICAgICAgICAgIGNvbnN0IGZvbnRTaXplID0gOTtcblxuLy8gICAgICAgICAgICAgICBjb25zdCB0ZXh0V2lkdGggPSB0ZXh0Lmxlbmd0aCAqIChmb250U2l6ZSAqIDAuNik7IC8vIEVzdGltYXRlIHRoYXQgZWFjaCBjaGFyYWN0ZXIgaXMgfjYwJSBvZiB0aGUgZm9udCBzaXplXG4vLyAgICAgICAgICAgICAgIGNvbnN0IHJlY3RXaWR0aCA9IHRleHRXaWR0aCArIHBhZGRpbmdYOyAvLyBBZGQgcGFkZGluZyBmb3Igd2lkdGhcbi8vICAgICAgICAgICAgICAgY29uc3QgcmVjdEhlaWdodCA9IGZvbnRTaXplICsgcGFkZGluZ1k7IC8vIEFkZCBwYWRkaW5nIGZvciBoZWlnaHRcblxuLy8gICAgICAgICAgICAgICBpZiAoaXNMUFZhbHVlKSB7XG4vLyAgICAgICAgICAgICAgICAgcmV0dXJuIChcbi8vICAgICAgICAgICAgICAgICAgIDxnIHRyYW5zZm9ybT17YHRyYW5zbGF0ZSgke3h9LCR7eX0pYH0+XG4vLyAgICAgICAgICAgICAgICAgICAgIDxyZWN0XG4vLyAgICAgICAgICAgICAgICAgICAgICAgeD17LXJlY3RXaWR0aCAvIDJ9IFxuLy8gICAgICAgICAgICAgICAgICAgICAgIHk9ey1yZWN0SGVpZ2h0IC8gMn1cbi8vICAgICAgICAgICAgICAgICAgICAgICB3aWR0aD17cmVjdFdpZHRofVxuLy8gICAgICAgICAgICAgICAgICAgICAgIGhlaWdodD17cmVjdEhlaWdodH1cbi8vICAgICAgICAgICAgICAgICAgICAgICBmaWxsPVwiIzRkNGQ0ZFwiXG4vLyAgICAgICAgICAgICAgICAgICAgICAgcng9ezB9IFxuLy8gICAgICAgICAgICAgICAgICAgICAvPlxuLy8gICAgICAgICAgICAgICAgICAgICA8dGV4dFxuLy8gICAgICAgICAgICAgICAgICAgICAgIGZpbGw9XCJ3aGl0ZVwiXG4vLyAgICAgICAgICAgICAgICAgICAgICAgZm9udFNpemU9e2ZvbnRTaXplfVxuLy8gICAgICAgICAgICAgICAgICAgICAgIHRleHRBbmNob3I9XCJtaWRkbGVcIlxuLy8gICAgICAgICAgICAgICAgICAgICAgIGR5PVwiMC4zMmVtXCJcbi8vICAgICAgICAgICAgICAgICAgICAgICB4PXswfSBcbi8vICAgICAgICAgICAgICAgICAgICAgPlxuLy8gICAgICAgICAgICAgICAgICAgICAgIExQIHtMcFlWYWx1ZS50b0ZpeGVkKDEpfVxuLy8gICAgICAgICAgICAgICAgICAgICA8L3RleHQ+XG4vLyAgICAgICAgICAgICAgICAgICA8L2c+XG4vLyAgICAgICAgICAgICAgICAgKTtcbi8vICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpc0xhdGVzdFZhbHVlKSB7XG4vLyAgICAgICAgICAgICAgICAgcmV0dXJuIChcbi8vICAgICAgICAgICAgICAgICAgIDxnIHRyYW5zZm9ybT17YHRyYW5zbGF0ZSgke3h9LCR7eX0pYH0+XG4vLyAgICAgICAgICAgICAgICAgICAgIDxyZWN0XG4vLyAgICAgICAgICAgICAgICAgICAgICAgeD17LXJlY3RXaWR0aCAvIDJ9IFxuLy8gICAgICAgICAgICAgICAgICAgICAgIHk9ey1yZWN0SGVpZ2h0IC8gMn1cbi8vICAgICAgICAgICAgICAgICAgICAgICB3aWR0aD17cmVjdFdpZHRofVxuLy8gICAgICAgICAgICAgICAgICAgICAgIGhlaWdodD17cmVjdEhlaWdodH1cbi8vICAgICAgICAgICAgICAgICAgICAgICBmaWxsPVwid2hpdGVcIlxuLy8gICAgICAgICAgICAgICAgICAgICAgIHJ4PXswfSBcbi8vICAgICAgICAgICAgICAgICAgICAgLz5cbi8vICAgICAgICAgICAgICAgICAgICAgPHRleHRcbi8vICAgICAgICAgICAgICAgICAgICAgICBmaWxsPVwiYmxhY2tcIlxuLy8gICAgICAgICAgICAgICAgICAgICAgIGZvbnRXZWlnaHQ9XCI3MDBcIlxuLy8gICAgICAgICAgICAgICAgICAgICAgIGZvbnRTaXplPXtmb250U2l6ZX1cbi8vICAgICAgICAgICAgICAgICAgICAgICB0ZXh0QW5jaG9yPVwibWlkZGxlXCJcbi8vICAgICAgICAgICAgICAgICAgICAgICBkeT1cIjAuMzJlbVwiXG4vLyAgICAgICAgICAgICAgICAgICAgICAgeD17MH1cbi8vICAgICAgICAgICAgICAgICAgICAgPlxuLy8gICAgICAgICAgICAgICAgICAgICAgIHtMYXRlc3RWYWx1ZS50b0ZpeGVkKDEpfVxuLy8gICAgICAgICAgICAgICAgICAgICA8L3RleHQ+XG4vLyAgICAgICAgICAgICAgICAgICA8L2c+XG4vLyAgICAgICAgICAgICAgICAgKTtcbi8vICAgICAgICAgICAgICAgfSBlbHNlIHtcbi8vICAgICAgICAgICAgICAgICByZXR1cm4gKFxuLy8gICAgICAgICAgICAgICAgICAgPHRleHRcbi8vICAgICAgICAgICAgICAgICAgICAgZmlsbD1cIiNBNkE2QTZcIlxuLy8gICAgICAgICAgICAgICAgICAgICBmb250U2l6ZT17Zm9udFNpemV9XG4vLyAgICAgICAgICAgICAgICAgICAgIHRleHRBbmNob3I9XCJzdGFydFwiXG4vLyAgICAgICAgICAgICAgICAgICAgIGR5PVwiMC4zMmVtXCJcbi8vICAgICAgICAgICAgICAgICAgICAgeD17LTEwfVxuLy8gICAgICAgICAgICAgICAgICAgICB5PXt5fVxuLy8gICAgICAgICAgICAgICAgICAgPlxuLy8gICAgICAgICAgICAgICAgICAgICB7dGV4dH1cbi8vICAgICAgICAgICAgICAgICAgIDwvdGV4dD5cbi8vICAgICAgICAgICAgICAgICApO1xuLy8gICAgICAgICAgICAgICB9XG4vLyAgICAgICAgICAgICB9fVxuLy8gICAgICAgICAgIC8+XG4vLyAgICAgICAgICAgPEF4aXNCb3R0b21cbi8vICAgICAgICAgICAgIHJhbmdlUGFkZGluZz17NDF9XG4vLyAgICAgICAgICAgICB0b3A9e2JvdW5kZWRIZWlnaHR9XG4vLyAgICAgICAgICAgICBoaWRlQXhpc0xpbmU9e3RydWV9XG4vLyAgICAgICAgICAgICBoaWRlVGlja3M9e3RydWV9XG4vLyAgICAgICAgICAgICBzY2FsZT17eFNjYWxlfVxuLy8gICAgICAgICAgICAgdGlja0Zvcm1hdD17KGQpID0+IHtcbi8vICAgICAgICAgICAgICAgcmV0dXJuIGQgaW5zdGFuY2VvZiBEYXRlID8gdGltZUZvcm1hdCgnJUg6JU0nKShkKSA6ICcnO1xuLy8gICAgICAgICAgICAgfX1cbi8vICAgICAgICAgICAgIHRpY2tMYWJlbFByb3BzPXsoKSA9PiAoe1xuLy8gICAgICAgICAgICAgICBmaWxsOiAnd2hpdGUnLFxuLy8gICAgICAgICAgICAgICBmb250U2l6ZTogOCxcbi8vICAgICAgICAgICAgICAgdGV4dEFuY2hvcjogJ21pZGRsZScsXG4vLyAgICAgICAgICAgICB9KX1cbi8vICAgICAgICAgICAvPlxuLy8gICAgICAgICA8L0dyb3VwPlxuLy8gICAgICAgPC9zdmc+XG4vLyAgICAgPC9kaXY+XG4vLyAgIClcbi8vIH1cblxuLy8gZXhwb3J0IHsgTGluZUNoYXJ0IH1cblxuXG4vLyAndXNlIGNsaWVudCdcblxuLy8gaW1wb3J0IFJlYWN0LCB7IHVzZU1lbW8sIHVzZUNhbGxiYWNrIH0gZnJvbSAncmVhY3QnO1xuLy8gaW1wb3J0IHsgZXh0ZW50LCBiaXNlY3RvciwgbWF4LCBtaW4gfSBmcm9tICdkMy1hcnJheSc7XG4vLyBpbXBvcnQgeyB0aW1lRm9ybWF0IH0gZnJvbSAnZDMtdGltZS1mb3JtYXQnO1xuLy8gaW1wb3J0IHsgQXhpc0JvdHRvbSwgQXhpc1JpZ2h0IH0gZnJvbSAnQHZpc3gvYXhpcyc7XG4vLyBpbXBvcnQgeyBMaW5lUGF0aCB9IGZyb20gJ0B2aXN4L3NoYXBlJztcbi8vIGltcG9ydCB7IEdyb3VwIH0gZnJvbSAnQHZpc3gvZ3JvdXAnO1xuLy8gaW1wb3J0IHsgc2NhbGVMaW5lYXIsIHNjYWxlVGltZSB9IGZyb20gJ0B2aXN4L3NjYWxlJztcbi8vIGltcG9ydCB7IEdyaWRSb3dzIH0gZnJvbSAnQHZpc3gvZ3JpZCc7XG4vLyBpbXBvcnQgeyBjdXJ2ZUxpbmVhciB9IGZyb20gJ0B2aXN4L2N1cnZlJztcbi8vIGltcG9ydCB7IHVzZVRvb2x0aXAsIFRvb2x0aXBXaXRoQm91bmRzIH0gZnJvbSAnQHZpc3gvdG9vbHRpcCc7XG4vLyBpbXBvcnQgeyBsb2NhbFBvaW50IH0gZnJvbSAnQHZpc3gvZXZlbnQnO1xuXG4vLyBpbXBvcnQgeyBkYXRhIH0gZnJvbSAnLi4vZGF0YS9saW5lLWNoYXJ0Jztcbi8vIGltcG9ydCB7IGdldERpbWVuc2lvbnMsIHhBY2Nlc3NvciwgeUFjY2Vzc29yIH0gZnJvbSAnIy91dGlscy9saW5lLWNoYXJ0JztcblxuLy8gdHlwZSBQcm9wcyA9IHtcbi8vICAgd2lkdGg6IG51bWJlcjtcbi8vICAgaGVpZ2h0OiBudW1iZXI7XG4vLyB9O1xuXG4vLyBmdW5jdGlvbiBMaW5lQ2hhcnQoeyB3aWR0aCwgaGVpZ2h0IH06IFByb3BzKSB7XG4vLyAgIGNvbnN0IHsgbWFyZ2luLCBib3VuZGVkV2lkdGgsIGJvdW5kZWRIZWlnaHQgfSA9IGdldERpbWVuc2lvbnMoe1xuLy8gICAgIHdpZHRoLFxuLy8gICAgIGhlaWdodCxcbi8vICAgfSk7XG5cbi8vICAgY29uc3QgTHBZVmFsdWUgPSA1NDMwMC4yO1xuLy8gICBjb25zdCBMYXRlc3RWYWx1ZSA9IDU5OTgwLjk7XG5cbi8vICAgY29uc3QgeFNjYWxlID0gdXNlTWVtbyhcbi8vICAgICAoKSA9PlxuLy8gICAgICAgc2NhbGVUaW1lPG51bWJlcj4oe1xuLy8gICAgICAgICBkb21haW46IGV4dGVudChkYXRhLCB4QWNjZXNzb3IpIGFzIFtEYXRlLCBEYXRlXSxcbi8vICAgICAgICAgcmFuZ2U6IFswLCBib3VuZGVkV2lkdGhdLFxuLy8gICAgICAgICBuaWNlOiB0cnVlLFxuLy8gICAgICAgfSksXG4vLyAgICAgW2JvdW5kZWRXaWR0aF1cbi8vICAgKTtcblxuLy8gICBjb25zdCB5U2NhbGUgPSB1c2VNZW1vKFxuLy8gICAgICgpID0+XG4vLyAgICAgICBzY2FsZUxpbmVhcjxudW1iZXI+KHtcbi8vICAgICAgICAgZG9tYWluOiBleHRlbnQoZGF0YSwgeUFjY2Vzc29yKSBhcyBbbnVtYmVyLCBudW1iZXJdLFxuLy8gICAgICAgICByYW5nZTogW2JvdW5kZWRIZWlnaHQsIDBdLFxuLy8gICAgICAgICBuaWNlOiB0cnVlLFxuLy8gICAgICAgfSksXG4vLyAgICAgW2JvdW5kZWRIZWlnaHRdXG4vLyAgICk7XG5cbi8vICAgY29uc3QgeyBzaG93VG9vbHRpcCwgaGlkZVRvb2x0aXAsIHRvb2x0aXBEYXRhLCB0b29sdGlwTGVmdCwgdG9vbHRpcFRvcCB9ID0gdXNlVG9vbHRpcCgpO1xuXG4vLyAgIGNvbnN0IGhhbmRsZVRvb2x0aXAgPSB1c2VDYWxsYmFjayhcbi8vICAgICAoZXZlbnQ6IFJlYWN0Lk1vdXNlRXZlbnQpID0+IHtcbi8vICAgICAgIGNvbnN0IHsgeCB9ID0gbG9jYWxQb2ludChldmVudCkgfHwgeyB4OiAwIH07XG4vLyAgICAgICBjb25zdCB4MCA9IHhTY2FsZS5pbnZlcnQoeCAtIG1hcmdpbi5sZWZ0KTsgLy8gR2V0IHRoZSBkYXRlIGZyb20geCBwb3NpdGlvblxuXG4vLyAgICAgICBjb25zdCBiaXNlY3REYXRlID0gYmlzZWN0b3IoeEFjY2Vzc29yKS5sZWZ0O1xuLy8gICAgICAgY29uc3QgaW5kZXggPSBiaXNlY3REYXRlKGRhdGEsIHgwLCAxKTtcbi8vICAgICAgIGNvbnN0IGQwID0gZGF0YVtpbmRleCAtIDFdO1xuLy8gICAgICAgY29uc3QgZDEgPSBkYXRhW2luZGV4XTtcbi8vICAgICAgIGNvbnN0IGQgPSB4MCAtIHhBY2Nlc3NvcihkMCkgPiB4QWNjZXNzb3IoZDEpIC0geDAgPyBkMSA6IGQwOyAvLyBHZXQgY2xvc2VzdCBkYXRhIHBvaW50XG5cbi8vICAgICAgIHNob3dUb29sdGlwKHtcbi8vICAgICAgICAgdG9vbHRpcERhdGE6IGQsXG4vLyAgICAgICAgIHRvb2x0aXBMZWZ0OiB4U2NhbGUoeEFjY2Vzc29yKGQpKSxcbi8vICAgICAgICAgdG9vbHRpcFRvcDogeVNjYWxlKHlBY2Nlc3NvcihkKSksXG4vLyAgICAgICB9KTtcbi8vICAgICB9LFxuLy8gICAgIFt4U2NhbGUsIHlTY2FsZSwgc2hvd1Rvb2x0aXBdXG4vLyAgICk7XG5cbi8vICAgY29uc3QgY3VzdG9tWVBvc2l0aW9uID0geVNjYWxlKExwWVZhbHVlKTtcblxuLy8gICBjb25zdCB5VGlja1ZhbHVlcyA9IHlTY2FsZS50aWNrcyg4KTtcbi8vICAgaWYgKCF5VGlja1ZhbHVlcy5pbmNsdWRlcyhMcFlWYWx1ZSkpIHlUaWNrVmFsdWVzLnB1c2goTHBZVmFsdWUpO1xuLy8gICBpZiAoIXlUaWNrVmFsdWVzLmluY2x1ZGVzKExhdGVzdFZhbHVlKSkgeVRpY2tWYWx1ZXMucHVzaChMYXRlc3RWYWx1ZSk7XG5cbi8vICAgcmV0dXJuIChcbi8vICAgICA8ZGl2IGNsYXNzTmFtZT1cInctZml0XCI+XG4vLyAgICAgICA8c3ZnIGNsYXNzTmFtZT1cIlwiIHdpZHRoPXt3aWR0aH0gaGVpZ2h0PXtoZWlnaHR9IHJvbGU9XCJmaWd1cmVcIj5cbi8vICAgICAgICAgPHJlY3QgeD17MH0geT17MH0gd2lkdGg9e3dpZHRofSBoZWlnaHQ9e2hlaWdodH0gLz5cbi8vICAgICAgICAgPEdyb3VwIHRvcD17bWFyZ2luLnRvcH0gbGVmdD17bWFyZ2luLmxlZnR9PlxuLy8gICAgICAgICAgIDxHcmlkUm93c1xuLy8gICAgICAgICAgICAgc2NhbGU9e3lTY2FsZX1cbi8vICAgICAgICAgICAgIHdpZHRoPXtib3VuZGVkV2lkdGh9XG4vLyAgICAgICAgICAgICBzdHJva2VEYXNoYXJyYXk9XCIxLDNcIlxuLy8gICAgICAgICAgICAgc3Ryb2tlPVwiIzI2MjYyNlwiXG4vLyAgICAgICAgICAgICBwb2ludGVyRXZlbnRzPVwibm9uZVwiXG4vLyAgICAgICAgICAgLz5cbi8vICAgICAgICAgICA8TGluZVBhdGhcbi8vICAgICAgICAgICAgIGN1cnZlPXtjdXJ2ZUxpbmVhcn1cbi8vICAgICAgICAgICAgIGRhdGE9e2RhdGF9XG4vLyAgICAgICAgICAgICBzdHJva2U9eycjRkZDQTQzJ31cbi8vICAgICAgICAgICAgIHN0cm9rZVdpZHRoPXsxLjV9XG4vLyAgICAgICAgICAgICB4PXsoZCkgPT4geFNjYWxlKHhBY2Nlc3NvcihkKSkgPz8gMH1cbi8vICAgICAgICAgICAgIHk9eyhkKSA9PiB5U2NhbGUoeUFjY2Vzc29yKGQpKSA/PyAwfVxuLy8gICAgICAgICAgIC8+XG5cbi8vICAgICAgICAgICB7Y3VzdG9tWVBvc2l0aW9uICYmIChcbi8vICAgICAgICAgICAgIDxsaW5lXG4vLyAgICAgICAgICAgICAgIHgxPXswfVxuLy8gICAgICAgICAgICAgICB4Mj17Ym91bmRlZFdpZHRofVxuLy8gICAgICAgICAgICAgICB5MT17Y3VzdG9tWVBvc2l0aW9ufVxuLy8gICAgICAgICAgICAgICB5Mj17Y3VzdG9tWVBvc2l0aW9ufVxuLy8gICAgICAgICAgICAgICBzdHJva2U9XCJ3aGl0ZVwiXG4vLyAgICAgICAgICAgICAgIHN0cm9rZVdpZHRoPXsxfVxuLy8gICAgICAgICAgICAgICBzdHJva2VEYXNoYXJyYXk9XCIzLDVcIlxuLy8gICAgICAgICAgICAgLz5cbi8vICAgICAgICAgICApfVxuXG4vLyAgICAgICAgICAgPEF4aXNSaWdodFxuLy8gICAgICAgICAgICAgbGVmdD17Ym91bmRlZFdpZHRoICsgbWFyZ2luLnJpZ2h0IC0gNDB9XG4vLyAgICAgICAgICAgICBzY2FsZT17eVNjYWxlfVxuLy8gICAgICAgICAgICAgdG9wPXswfVxuLy8gICAgICAgICAgICAgaGlkZUF4aXNMaW5lPXt0cnVlfVxuLy8gICAgICAgICAgICAgaGlkZVRpY2tzPXt0cnVlfVxuLy8gICAgICAgICAgICAgdGlja1ZhbHVlcz17eVRpY2tWYWx1ZXN9XG4vLyAgICAgICAgICAgICB0aWNrRm9ybWF0PXsodmFsdWUpID0+IGAke051bWJlcih2YWx1ZSkudG9GaXhlZCgxKX1gfVxuLy8gICAgICAgICAgICAgdGlja0xhYmVsUHJvcHM9eygpID0+ICh7XG4vLyAgICAgICAgICAgICAgIGZpbGw6ICcjQTZBNkE2Jyxcbi8vICAgICAgICAgICAgICAgZm9udFNpemU6IDksXG4vLyAgICAgICAgICAgICAgIHRleHRBbmNob3I6ICdzdGFydCcsXG4vLyAgICAgICAgICAgICB9KX1cbi8vICAgICAgICAgICAgIHRpY2tDb21wb25lbnQ9eyh7IGZvcm1hdHRlZFZhbHVlLCB4LCB5IH0pID0+IHtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZm9ybWF0dGVkVmFsdWUgPT09IHVuZGVmaW5lZCkge1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7IFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbnVtRm9ybWF0dGVkVmFsdWUgPSBOdW1iZXIoZm9ybWF0dGVkVmFsdWUpOyBcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpc0xQVmFsdWUgPSBudW1Gb3JtYXR0ZWRWYWx1ZSA9PT0gTHBZVmFsdWU7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaXNMYXRlc3RWYWx1ZSA9IG51bUZvcm1hdHRlZFZhbHVlID09PSBMYXRlc3RWYWx1ZTtcbiAgICAgICAgICAgICAgXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdGV4dCA9IGlzTFBWYWx1ZVxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBgTFAgJHtMcFlWYWx1ZS50b0ZpeGVkKDEpfWBcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogaXNMYXRlc3RWYWx1ZVxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBgJHtMYXRlc3RWYWx1ZS50b0ZpeGVkKDEpfWBcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogZm9ybWF0dGVkVmFsdWU7XG4gICAgICAgICAgICAgIFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhZGRpbmdYID0gODsgXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFkZGluZ1kgPSAyOyBcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBmb250U2l6ZSA9IDk7XG4gICAgICAgICAgICAgIFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRleHRXaWR0aCA9IHRleHQubGVuZ3RoICogKGZvbnRTaXplICogMC42KTsgLy8gRXN0aW1hdGUgdGhhdCBlYWNoIGNoYXJhY3RlciBpcyB+NjAlIG9mIHRoZSBmb250IHNpemVcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZWN0V2lkdGggPSB0ZXh0V2lkdGggKyBwYWRkaW5nWDsgLy8gQWRkIHBhZGRpbmcgZm9yIHdpZHRoXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVjdEhlaWdodCA9IGZvbnRTaXplICsgcGFkZGluZ1k7IC8vIEFkZCBwYWRkaW5nIGZvciBoZWlnaHRcbiAgICAgICAgICAgICAgXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzTFBWYWx1ZSkge1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGcgdHJhbnNmb3JtPXtgdHJhbnNsYXRlKCR7eH0sJHt5fSlgfT5cbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8cmVjdFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeD17LXJlY3RXaWR0aCAvIDJ9IFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeT17LXJlY3RIZWlnaHQgLyAyfVxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg9e3JlY3RXaWR0aH1cbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodD17cmVjdEhlaWdodH1cbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGw9XCIjNGQ0ZDRkXCJcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ4PXswfSBcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvPlxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZXh0XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxsPVwid2hpdGVcIlxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9udFNpemU9e2ZvbnRTaXplfVxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dEFuY2hvcj1cIm1pZGRsZVwiXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkeT1cIjAuMzJlbVwiXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4PXswfSBcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA+XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBMUCB7THBZVmFsdWUudG9GaXhlZCgxKX1cbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3RleHQ+XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZz5cbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpc0xhdGVzdFZhbHVlKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZyB0cmFuc2Zvcm09e2B0cmFuc2xhdGUoJHt4fSwke3l9KWB9PlxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxyZWN0XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4PXstcmVjdFdpZHRoIC8gMn0gXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5PXstcmVjdEhlaWdodCAvIDJ9XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aD17cmVjdFdpZHRofVxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0PXtyZWN0SGVpZ2h0fVxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsbD1cIndoaXRlXCJcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ4PXswfSBcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvPlxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZXh0XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxsPVwiYmxhY2tcIlxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9udFdlaWdodD1cIjcwMFwiXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb250U2l6ZT17Zm9udFNpemV9XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0QW5jaG9yPVwibWlkZGxlXCJcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGR5PVwiMC4zMmVtXCJcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHg9ezB9XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPlxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge0xhdGVzdFZhbHVlLnRvRml4ZWQoMSl9XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90ZXh0PlxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2c+XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGV4dFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGw9XCIjQTZBNkE2XCJcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb250U2l6ZT17Zm9udFNpemV9XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dEFuY2hvcj1cInN0YXJ0XCJcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkeT1cIjAuMzJlbVwiXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeD17LTEwfVxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHk9e3l9XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID5cbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7dGV4dH1cbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90ZXh0PlxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgIH19XG4vLyAgICAgICAgICAgLz5cbi8vICAgICAgICAgICA8QXhpc0JvdHRvbVxuLy8gICAgICAgICAgICAgcmFuZ2VQYWRkaW5nPXs0MX1cbi8vICAgICAgICAgICAgIHRvcD17Ym91bmRlZEhlaWdodH1cbi8vICAgICAgICAgICAgIGhpZGVBeGlzTGluZT17dHJ1ZX1cbi8vICAgICAgICAgICAgIGhpZGVUaWNrcz17dHJ1ZX1cbi8vICAgICAgICAgICAgIHNjYWxlPXt4U2NhbGV9XG4vLyAgICAgICAgICAgICB0aWNrRm9ybWF0PXsoZCkgPT4gKGQgaW5zdGFuY2VvZiBEYXRlID8gdGltZUZvcm1hdCgnJUg6JU0nKShkKSA6ICcnKX1cbi8vICAgICAgICAgICAgIHRpY2tMYWJlbFByb3BzPXsoKSA9PiAoe1xuLy8gICAgICAgICAgICAgICBmaWxsOiAnd2hpdGUnLFxuLy8gICAgICAgICAgICAgICBmb250U2l6ZTogOCxcbi8vICAgICAgICAgICAgICAgdGV4dEFuY2hvcjogJ21pZGRsZScsXG4vLyAgICAgICAgICAgICB9KX1cbi8vICAgICAgICAgICAvPlxuLy8gICAgICAgICAgIDxyZWN0XG4vLyAgICAgICAgICAgICB4PXswfVxuLy8gICAgICAgICAgICAgeT17MH1cbi8vICAgICAgICAgICAgIHdpZHRoPXtib3VuZGVkV2lkdGh9XG4vLyAgICAgICAgICAgICBoZWlnaHQ9e2JvdW5kZWRIZWlnaHR9XG4vLyAgICAgICAgICAgICBmaWxsPVwidHJhbnNwYXJlbnRcIlxuLy8gICAgICAgICAgICAgb25Nb3VzZU1vdmU9e2hhbmRsZVRvb2x0aXB9XG4vLyAgICAgICAgICAgICBvbk1vdXNlTGVhdmU9eygpID0+IGhpZGVUb29sdGlwKCl9XG4vLyAgICAgICAgICAgLz5cbi8vICAgICAgICAgPC9Hcm91cD5cbi8vICAgICAgICAge3Rvb2x0aXBEYXRhICYmIChcbi8vICAgICAgICAgICA8Y2lyY2xlXG4vLyAgICAgICAgICAgICBjeD17dG9vbHRpcExlZnR9XG4vLyAgICAgICAgICAgICBjeT17dG9vbHRpcFRvcH1cbi8vICAgICAgICAgICAgIHI9ezV9XG4vLyAgICAgICAgICAgICBzdHJva2U9XCJibGFja1wiXG4vLyAgICAgICAgICAgICBmaWxsPVwiI2ZmY2I4ZlwiXG4vLyAgICAgICAgICAgICBzdHJva2VXaWR0aD17Mn1cbi8vICAgICAgICAgICAgIHBvaW50ZXJFdmVudHM9XCJub25lXCJcbi8vICAgICAgICAgICAvPlxuLy8gICAgICAgICApfVxuLy8gICAgICAgPC9zdmc+XG4vLyAgICAgICB7dG9vbHRpcERhdGEgJiYgKFxuLy8gICAgICAgICA8VG9vbHRpcFdpdGhCb3VuZHNcbi8vICAgICAgICAgICB0b3A9e3Rvb2x0aXBUb3AgLSAxMn1cbi8vICAgICAgICAgICBsZWZ0PXt0b29sdGlwTGVmdCArIDEyfVxuLy8gICAgICAgICAgIHN0eWxlPXt7XG4vLyAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICcjNGQ0ZDRkJyxcbi8vICAgICAgICAgICAgIGNvbG9yOiAnd2hpdGUnLFxuLy8gICAgICAgICAgICAgcGFkZGluZzogJzAuNXJlbScsXG4vLyAgICAgICAgICAgICBib3JkZXJSYWRpdXM6ICc0cHgnLFxuLy8gICAgICAgICAgICAgZm9udFNpemU6ICcxMHB4Jyxcbi8vICAgICAgICAgICB9fVxuLy8gICAgICAgICA+XG4vLyAgICAgICAgICAgPGRpdj5EYXRlOiB7dGltZUZvcm1hdCgnJWIgJWQsICVZJykoeEFjY2Vzc29yKHRvb2x0aXBEYXRhKSl9PC9kaXY+XG4vLyAgICAgICAgICAgPGRpdj5WYWx1ZToge3lBY2Nlc3Nvcih0b29sdGlwRGF0YSl9PC9kaXY+XG4vLyAgICAgICAgIDwvVG9vbHRpcFdpdGhCb3VuZHM+XG4vLyAgICAgICApfVxuLy8gICAgIDwvZGl2PlxuLy8gICApO1xuLy8gfVxuXG4vLyBleHBvcnQgeyBMaW5lQ2hhcnQgfTtcblxuXG5cblxuLy8gaW1wb3J0IFJlYWN0LCB7IHVzZU1lbW8gfSBmcm9tICdyZWFjdCdcbi8vIGltcG9ydCB7IGV4dGVudCB9IGZyb20gJ2QzLWFycmF5J1xuLy8gaW1wb3J0IHsgdGltZUZvcm1hdCB9IGZyb20gJ2QzLXRpbWUtZm9ybWF0J1xuLy8gaW1wb3J0IHsgQXhpc0JvdHRvbSwgQXhpc1JpZ2h0IH0gZnJvbSAnQHZpc3gvYXhpcydcbi8vIGltcG9ydCB7IExpbmVQYXRoIH0gZnJvbSAnQHZpc3gvc2hhcGUnXG4vLyBpbXBvcnQgeyBHcm91cCB9IGZyb20gJ0B2aXN4L2dyb3VwJ1xuLy8gaW1wb3J0IHsgc2NhbGVMaW5lYXIsIHNjYWxlVGltZSB9IGZyb20gJ0B2aXN4L3NjYWxlJ1xuLy8gaW1wb3J0IHsgR3JpZFJvd3MgfSBmcm9tIFwiQHZpc3gvZ3JpZFwiO1xuLy8gaW1wb3J0IHsgY3VydmVMaW5lYXIgfSBmcm9tICdAdmlzeC9jdXJ2ZSdcblxuLy8gaW1wb3J0IHsgZGF0YSB9IGZyb20gJy4uL2RhdGEvbGluZS1jaGFydCdcbi8vIGltcG9ydCB7IGdldERpbWVuc2lvbnMsIHhBY2Nlc3NvciwgeUFjY2Vzc29yIH0gZnJvbSAnIy91dGlscy9saW5lLWNoYXJ0J1xuXG4vLyB0eXBlIFByb3BzID0ge1xuLy8gICB3aWR0aDogbnVtYmVyXG4vLyAgIGhlaWdodDogbnVtYmVyXG4vLyB9XG5cbi8vIGZ1bmN0aW9uIExpbmVDaGFydCh7IHdpZHRoLCBoZWlnaHQgfTogUHJvcHMpIHtcbi8vICAgY29uc3QgeyBtYXJnaW4sIGJvdW5kZWRXaWR0aCwgYm91bmRlZEhlaWdodCB9ID0gZ2V0RGltZW5zaW9ucyh7XG4vLyAgICAgd2lkdGgsXG4vLyAgICAgaGVpZ2h0LFxuLy8gICB9KVxuXG4vLyAgIGNvbnN0IExwWVZhbHVlID0gNTQzMDAuMjsgXG4vLyAgIGNvbnN0IExhdGVzdFZhbHVlID0gNTk5ODAuOTtcblxuLy8gICBjb25zdCB4U2NhbGUgPSB1c2VNZW1vKFxuLy8gICAgICgpID0+XG4vLyAgICAgICBzY2FsZVRpbWU8bnVtYmVyPih7XG4vLyAgICAgICAgIGRvbWFpbjogZXh0ZW50KGRhdGEsIHhBY2Nlc3NvcikgYXMgW0RhdGUsIERhdGVdLFxuLy8gICAgICAgICByYW5nZTogWzAsIGJvdW5kZWRXaWR0aF0sXG4vLyAgICAgICAgIG5pY2U6IHRydWUsXG4vLyAgICAgICB9KSxcbi8vICAgICBbYm91bmRlZFdpZHRoXVxuLy8gICApXG5cbi8vICAgY29uc3QgeVNjYWxlID0gdXNlTWVtbyhcbi8vICAgICAoKSA9PlxuLy8gICAgICAgc2NhbGVMaW5lYXI8bnVtYmVyPih7XG4vLyAgICAgICAgIGRvbWFpbjogZXh0ZW50KGRhdGEsIHlBY2Nlc3NvcikgYXMgW251bWJlciwgbnVtYmVyXSxcbi8vICAgICAgICAgcmFuZ2U6IFtib3VuZGVkSGVpZ2h0LCAwXSxcbi8vICAgICAgICAgbmljZTogdHJ1ZSxcbi8vICAgICAgIH0pLFxuLy8gICAgIFtib3VuZGVkSGVpZ2h0XVxuLy8gICApXG5cbi8vICAgY29uc3QgY3VzdG9tWVBvc2l0aW9uID0geVNjYWxlKExwWVZhbHVlKTsgXG5cbi8vICAgLy8gR2VuZXJhdGUgeS1heGlzIHRpY2sgdmFsdWVzIGFuZCBlbnN1cmUgYm90aCBMcFlWYWx1ZSBhbmQgTGF0ZXN0VmFsdWUgYXJlIGluY2x1ZGVkXG4vLyAgIGNvbnN0IHlUaWNrVmFsdWVzID0geVNjYWxlLnRpY2tzKDgpO1xuXG4vLyAgIGlmICgheVRpY2tWYWx1ZXMuaW5jbHVkZXMoTHBZVmFsdWUpKSB7XG4vLyAgICAgeVRpY2tWYWx1ZXMucHVzaChMcFlWYWx1ZSk7XG4vLyAgIH1cbi8vICAgaWYgKCF5VGlja1ZhbHVlcy5pbmNsdWRlcyhMYXRlc3RWYWx1ZSkpIHtcbi8vICAgICB5VGlja1ZhbHVlcy5wdXNoKExhdGVzdFZhbHVlKTtcbi8vICAgfVxuXG4vLyAgIHJldHVybiAoXG4vLyAgICAgPGRpdiBjbGFzc05hbWU9XCJ3LWZpdFwiPlxuLy8gICAgICAgPHN2Z1xuLy8gICAgICAgICBjbGFzc05hbWU9Jydcbi8vICAgICAgICAgd2lkdGg9e3dpZHRofVxuLy8gICAgICAgICBoZWlnaHQ9e2hlaWdodH1cbi8vICAgICAgICAgcm9sZT1cImZpZ3VyZVwiXG4vLyAgICAgICA+XG4vLyAgICAgICAgIDxyZWN0XG4vLyAgICAgICAgICAgICB4PXswfVxuLy8gICAgICAgICAgICAgeT17MH1cbi8vICAgICAgICAgICAgIHdpZHRoPXt3aWR0aH1cbi8vICAgICAgICAgICAgIGhlaWdodD17aGVpZ2h0fVxuLy8gICAgICAgICAvPlxuLy8gICAgICAgICA8dGl0bGU+bGluZSBjaGFydCBsb29raW5nIGF0IHRoZSBkaXN0cmlidXRpb24gb2YgbWF4IHRlbXBlcmF0dXJlPC90aXRsZT5cbi8vICAgICAgICAgPEdyb3VwIHRvcD17bWFyZ2luLnRvcH0gbGVmdD17bWFyZ2luLmxlZnR9PlxuLy8gICAgICAgICAgIDxHcmlkUm93c1xuLy8gICAgICAgICAgICAgc2NhbGU9e3lTY2FsZX1cbi8vICAgICAgICAgICAgIHdpZHRoPXtib3VuZGVkV2lkdGh9XG4vLyAgICAgICAgICAgICBzdHJva2VEYXNoYXJyYXk9XCIxLDNcIlxuLy8gICAgICAgICAgICAgc3Ryb2tlPVwiIzI2MjYyNlwiXG4vLyAgICAgICAgICAgICBwb2ludGVyRXZlbnRzPVwibm9uZVwiXG4vLyAgICAgICAgICAgLz5cbi8vICAgICAgICAgICA8TGluZVBhdGhcbi8vICAgICAgICAgICAgIGN1cnZlPXtjdXJ2ZUxpbmVhcn1cbi8vICAgICAgICAgICAgIGRhdGE9e2RhdGF9XG4vLyAgICAgICAgICAgICBzdHJva2U9e1wiI0ZGQ0E0M1wifVxuLy8gICAgICAgICAgICAgc3Ryb2tlV2lkdGg9ezEuNX1cbi8vICAgICAgICAgICAgIHg9eyhkKSA9PiB4U2NhbGUoeEFjY2Vzc29yKGQpKSA/PyAwfVxuLy8gICAgICAgICAgICAgeT17KGQpID0+IHlTY2FsZSh5QWNjZXNzb3IoZCkpID8/IDB9XG4vLyAgICAgICAgICAgLz5cblxuLy8gICAgICAgICAgIHtjdXN0b21ZUG9zaXRpb24gJiYgKFxuLy8gICAgICAgICAgICAgPGxpbmVcbi8vICAgICAgICAgICAgICAgeDE9ezB9XG4vLyAgICAgICAgICAgICAgIHgyPXtib3VuZGVkV2lkdGh9XG4vLyAgICAgICAgICAgICAgIHkxPXtjdXN0b21ZUG9zaXRpb259XG4vLyAgICAgICAgICAgICAgIHkyPXtjdXN0b21ZUG9zaXRpb259XG4vLyAgICAgICAgICAgICAgIHN0cm9rZT1cIndoaXRlXCJcbi8vICAgICAgICAgICAgICAgc3Ryb2tlV2lkdGg9ezF9XG4vLyAgICAgICAgICAgICAgIHN0cm9rZURhc2hhcnJheT1cIjMsNVwiIFxuLy8gICAgICAgICAgICAgLz5cbi8vICAgICAgICAgICApfVxuXG4vLyAgICAgICAgICAgPEF4aXNSaWdodFxuLy8gICAgICAgICAgICAgbGVmdD17Ym91bmRlZFdpZHRoICsgbWFyZ2luLnJpZ2h0IC0gNDB9XG4vLyAgICAgICAgICAgICBzY2FsZT17eVNjYWxlfVxuLy8gICAgICAgICAgICAgdG9wPXswfVxuLy8gICAgICAgICAgICAgaGlkZUF4aXNMaW5lPXt0cnVlfVxuLy8gICAgICAgICAgICAgaGlkZVRpY2tzPXt0cnVlfVxuLy8gICAgICAgICAgICAgbGFiZWxPZmZzZXQ9ezB9XG4vLyAgICAgICAgICAgICB0aWNrVmFsdWVzPXt5VGlja1ZhbHVlc31cbi8vICAgICAgICAgICAgIHRpY2tGb3JtYXQ9eyh2YWx1ZSkgPT4gYCR7TnVtYmVyKHZhbHVlKS50b0ZpeGVkKDEpfWB9IFxuLy8gICAgICAgICAgICAgdGlja0xhYmVsUHJvcHM9eygpID0+ICh7XG4vLyAgICAgICAgICAgICAgIGZpbGw6ICcjQTZBNkE2Jyxcbi8vICAgICAgICAgICAgICAgZm9udFNpemU6IDksXG4vLyAgICAgICAgICAgICAgIHRleHRBbmNob3I6ICdzdGFydCcsXG4vLyAgICAgICAgICAgICB9KX1cbi8vICAgICAgICAgICAgIHRpY2tDb21wb25lbnQ9eyh7IGZvcm1hdHRlZFZhbHVlLCB4LCB5IH0pID0+IHtcbi8vICAgICAgICAgICAgICAgaWYgKGZvcm1hdHRlZFZhbHVlID09PSB1bmRlZmluZWQpIHtcbi8vICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDsgXG4vLyAgICAgICAgICAgICAgIH1cblxuLy8gICAgICAgICAgICAgICBjb25zdCBudW1Gb3JtYXR0ZWRWYWx1ZSA9IE51bWJlcihmb3JtYXR0ZWRWYWx1ZSk7IFxuLy8gICAgICAgICAgICAgICBjb25zdCBpc0xQVmFsdWUgPSBudW1Gb3JtYXR0ZWRWYWx1ZSA9PT0gTHBZVmFsdWU7XG4vLyAgICAgICAgICAgICAgIGNvbnN0IGlzTGF0ZXN0VmFsdWUgPSBudW1Gb3JtYXR0ZWRWYWx1ZSA9PT0gTGF0ZXN0VmFsdWU7XG5cbi8vICAgICAgICAgICAgICAgY29uc3QgdGV4dCA9IGlzTFBWYWx1ZVxuLy8gICAgICAgICAgICAgICAgID8gYExQICR7THBZVmFsdWUudG9GaXhlZCgxKX1gXG4vLyAgICAgICAgICAgICAgICAgOiBpc0xhdGVzdFZhbHVlXG4vLyAgICAgICAgICAgICAgICAgPyBgJHtMYXRlc3RWYWx1ZS50b0ZpeGVkKDEpfWBcbi8vICAgICAgICAgICAgICAgICA6IGZvcm1hdHRlZFZhbHVlO1xuXG4vLyAgICAgICAgICAgICAgIGNvbnN0IHBhZGRpbmdYID0gODsgXG4vLyAgICAgICAgICAgICAgIGNvbnN0IHBhZGRpbmdZID0gMjsgXG4vLyAgICAgICAgICAgICAgIGNvbnN0IGZvbnRTaXplID0gOTtcblxuLy8gICAgICAgICAgICAgICBjb25zdCB0ZXh0V2lkdGggPSB0ZXh0Lmxlbmd0aCAqIChmb250U2l6ZSAqIDAuNik7IC8vIEVzdGltYXRlIHRoYXQgZWFjaCBjaGFyYWN0ZXIgaXMgfjYwJSBvZiB0aGUgZm9udCBzaXplXG4vLyAgICAgICAgICAgICAgIGNvbnN0IHJlY3RXaWR0aCA9IHRleHRXaWR0aCArIHBhZGRpbmdYOyAvLyBBZGQgcGFkZGluZyBmb3Igd2lkdGhcbi8vICAgICAgICAgICAgICAgY29uc3QgcmVjdEhlaWdodCA9IGZvbnRTaXplICsgcGFkZGluZ1k7IC8vIEFkZCBwYWRkaW5nIGZvciBoZWlnaHRcblxuLy8gICAgICAgICAgICAgICBpZiAoaXNMUFZhbHVlKSB7XG4vLyAgICAgICAgICAgICAgICAgcmV0dXJuIChcbi8vICAgICAgICAgICAgICAgICAgIDxnIHRyYW5zZm9ybT17YHRyYW5zbGF0ZSgke3h9LCR7eX0pYH0+XG4vLyAgICAgICAgICAgICAgICAgICAgIDxyZWN0XG4vLyAgICAgICAgICAgICAgICAgICAgICAgeD17LXJlY3RXaWR0aCAvIDJ9IFxuLy8gICAgICAgICAgICAgICAgICAgICAgIHk9ey1yZWN0SGVpZ2h0IC8gMn1cbi8vICAgICAgICAgICAgICAgICAgICAgICB3aWR0aD17cmVjdFdpZHRofVxuLy8gICAgICAgICAgICAgICAgICAgICAgIGhlaWdodD17cmVjdEhlaWdodH1cbi8vICAgICAgICAgICAgICAgICAgICAgICBmaWxsPVwiIzRkNGQ0ZFwiXG4vLyAgICAgICAgICAgICAgICAgICAgICAgcng9ezB9IFxuLy8gICAgICAgICAgICAgICAgICAgICAvPlxuLy8gICAgICAgICAgICAgICAgICAgICA8dGV4dFxuLy8gICAgICAgICAgICAgICAgICAgICAgIGZpbGw9XCJ3aGl0ZVwiXG4vLyAgICAgICAgICAgICAgICAgICAgICAgZm9udFNpemU9e2ZvbnRTaXplfVxuLy8gICAgICAgICAgICAgICAgICAgICAgIHRleHRBbmNob3I9XCJtaWRkbGVcIlxuLy8gICAgICAgICAgICAgICAgICAgICAgIGR5PVwiMC4zMmVtXCJcbi8vICAgICAgICAgICAgICAgICAgICAgICB4PXswfSBcbi8vICAgICAgICAgICAgICAgICAgICAgPlxuLy8gICAgICAgICAgICAgICAgICAgICAgIExQIHtMcFlWYWx1ZS50b0ZpeGVkKDEpfVxuLy8gICAgICAgICAgICAgICAgICAgICA8L3RleHQ+XG4vLyAgICAgICAgICAgICAgICAgICA8L2c+XG4vLyAgICAgICAgICAgICAgICAgKTtcbi8vICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpc0xhdGVzdFZhbHVlKSB7XG4vLyAgICAgICAgICAgICAgICAgcmV0dXJuIChcbi8vICAgICAgICAgICAgICAgICAgIDxnIHRyYW5zZm9ybT17YHRyYW5zbGF0ZSgke3h9LCR7eX0pYH0+XG4vLyAgICAgICAgICAgICAgICAgICAgIDxyZWN0XG4vLyAgICAgICAgICAgICAgICAgICAgICAgeD17LXJlY3RXaWR0aCAvIDJ9IFxuLy8gICAgICAgICAgICAgICAgICAgICAgIHk9ey1yZWN0SGVpZ2h0IC8gMn1cbi8vICAgICAgICAgICAgICAgICAgICAgICB3aWR0aD17cmVjdFdpZHRofVxuLy8gICAgICAgICAgICAgICAgICAgICAgIGhlaWdodD17cmVjdEhlaWdodH1cbi8vICAgICAgICAgICAgICAgICAgICAgICBmaWxsPVwid2hpdGVcIlxuLy8gICAgICAgICAgICAgICAgICAgICAgIHJ4PXswfSBcbi8vICAgICAgICAgICAgICAgICAgICAgLz5cbi8vICAgICAgICAgICAgICAgICAgICAgPHRleHRcbi8vICAgICAgICAgICAgICAgICAgICAgICBmaWxsPVwiYmxhY2tcIlxuLy8gICAgICAgICAgICAgICAgICAgICAgIGZvbnRXZWlnaHQ9XCI3MDBcIlxuLy8gICAgICAgICAgICAgICAgICAgICAgIGZvbnRTaXplPXtmb250U2l6ZX1cbi8vICAgICAgICAgICAgICAgICAgICAgICB0ZXh0QW5jaG9yPVwibWlkZGxlXCJcbi8vICAgICAgICAgICAgICAgICAgICAgICBkeT1cIjAuMzJlbVwiXG4vLyAgICAgICAgICAgICAgICAgICAgICAgeD17MH1cbi8vICAgICAgICAgICAgICAgICAgICAgPlxuLy8gICAgICAgICAgICAgICAgICAgICAgIHtMYXRlc3RWYWx1ZS50b0ZpeGVkKDEpfVxuLy8gICAgICAgICAgICAgICAgICAgICA8L3RleHQ+XG4vLyAgICAgICAgICAgICAgICAgICA8L2c+XG4vLyAgICAgICAgICAgICAgICAgKTtcbi8vICAgICAgICAgICAgICAgfSBlbHNlIHtcbi8vICAgICAgICAgICAgICAgICByZXR1cm4gKFxuLy8gICAgICAgICAgICAgICAgICAgPHRleHRcbi8vICAgICAgICAgICAgICAgICAgICAgZmlsbD1cIiNBNkE2QTZcIlxuLy8gICAgICAgICAgICAgICAgICAgICBmb250U2l6ZT17Zm9udFNpemV9XG4vLyAgICAgICAgICAgICAgICAgICAgIHRleHRBbmNob3I9XCJzdGFydFwiXG4vLyAgICAgICAgICAgICAgICAgICAgIGR5PVwiMC4zMmVtXCJcbi8vICAgICAgICAgICAgICAgICAgICAgeD17LTEwfVxuLy8gICAgICAgICAgICAgICAgICAgICB5PXt5fVxuLy8gICAgICAgICAgICAgICAgICAgPlxuLy8gICAgICAgICAgICAgICAgICAgICB7dGV4dH1cbi8vICAgICAgICAgICAgICAgICAgIDwvdGV4dD5cbi8vICAgICAgICAgICAgICAgICApO1xuLy8gICAgICAgICAgICAgICB9XG4vLyAgICAgICAgICAgICB9fVxuLy8gICAgICAgICAgIC8+XG4vLyAgICAgICAgICAgPEF4aXNCb3R0b21cbi8vICAgICAgICAgICAgIHJhbmdlUGFkZGluZz17NDF9XG4vLyAgICAgICAgICAgICB0b3A9e2JvdW5kZWRIZWlnaHR9XG4vLyAgICAgICAgICAgICBoaWRlQXhpc0xpbmU9e3RydWV9XG4vLyAgICAgICAgICAgICBoaWRlVGlja3M9e3RydWV9XG4vLyAgICAgICAgICAgICBzY2FsZT17eFNjYWxlfVxuLy8gICAgICAgICAgICAgdGlja0Zvcm1hdD17KGQpID0+IHtcbi8vICAgICAgICAgICAgICAgcmV0dXJuIGQgaW5zdGFuY2VvZiBEYXRlID8gdGltZUZvcm1hdCgnJUg6JU0nKShkKSA6ICcnO1xuLy8gICAgICAgICAgICAgfX1cbi8vICAgICAgICAgICAgIHRpY2tMYWJlbFByb3BzPXsoKSA9PiAoe1xuLy8gICAgICAgICAgICAgICBmaWxsOiAnd2hpdGUnLFxuLy8gICAgICAgICAgICAgICBmb250U2l6ZTogOCxcbi8vICAgICAgICAgICAgICAgdGV4dEFuY2hvcjogJ21pZGRsZScsXG4vLyAgICAgICAgICAgICB9KX1cbi8vICAgICAgICAgICAvPlxuLy8gICAgICAgICA8L0dyb3VwPlxuLy8gICAgICAgPC9zdmc+XG4vLyAgICAgPC9kaXY+XG4vLyAgIClcbi8vIH1cblxuLy8gZXhwb3J0IHsgTGluZUNoYXJ0IH1cblxuXG4vLyAndXNlIGNsaWVudCdcblxuLy8gaW1wb3J0IFJlYWN0LCB7IHVzZU1lbW8sIHVzZUNhbGxiYWNrIH0gZnJvbSAncmVhY3QnO1xuLy8gaW1wb3J0IHsgZXh0ZW50LCBiaXNlY3RvciwgbWF4LCBtaW4gfSBmcm9tICdkMy1hcnJheSc7XG4vLyBpbXBvcnQgeyB0aW1lRm9ybWF0IH0gZnJvbSAnZDMtdGltZS1mb3JtYXQnO1xuLy8gaW1wb3J0IHsgQXhpc0JvdHRvbSwgQXhpc1JpZ2h0IH0gZnJvbSAnQHZpc3gvYXhpcyc7XG4vLyBpbXBvcnQgeyBMaW5lUGF0aCB9IGZyb20gJ0B2aXN4L3NoYXBlJztcbi8vIGltcG9ydCB7IEdyb3VwIH0gZnJvbSAnQHZpc3gvZ3JvdXAnO1xuLy8gaW1wb3J0IHsgc2NhbGVMaW5lYXIsIHNjYWxlVGltZSB9IGZyb20gJ0B2aXN4L3NjYWxlJztcbi8vIGltcG9ydCB7IEdyaWRSb3dzIH0gZnJvbSAnQHZpc3gvZ3JpZCc7XG4vLyBpbXBvcnQgeyBjdXJ2ZUxpbmVhciB9IGZyb20gJ0B2aXN4L2N1cnZlJztcbi8vIGltcG9ydCB7IHVzZVRvb2x0aXAsIFRvb2x0aXBXaXRoQm91bmRzIH0gZnJvbSAnQHZpc3gvdG9vbHRpcCc7XG4vLyBpbXBvcnQgeyBsb2NhbFBvaW50IH0gZnJvbSAnQHZpc3gvZXZlbnQnO1xuXG4vLyBpbXBvcnQgeyBkYXRhIH0gZnJvbSAnLi4vZGF0YS9saW5lLWNoYXJ0Jztcbi8vIGltcG9ydCB7IGdldERpbWVuc2lvbnMsIHhBY2Nlc3NvciwgeUFjY2Vzc29yIH0gZnJvbSAnIy91dGlscy9saW5lLWNoYXJ0JztcblxuLy8gdHlwZSBQcm9wcyA9IHtcbi8vICAgd2lkdGg6IG51bWJlcjtcbi8vICAgaGVpZ2h0OiBudW1iZXI7XG4vLyB9O1xuXG4vLyBmdW5jdGlvbiBMaW5lQ2hhcnQoeyB3aWR0aCwgaGVpZ2h0IH06IFByb3BzKSB7XG4vLyAgIGNvbnN0IHsgbWFyZ2luLCBib3VuZGVkV2lkdGgsIGJvdW5kZWRIZWlnaHQgfSA9IGdldERpbWVuc2lvbnMoe1xuLy8gICAgIHdpZHRoLFxuLy8gICAgIGhlaWdodCxcbi8vICAgfSk7XG5cbi8vICAgY29uc3QgTHBZVmFsdWUgPSA1NDMwMC4yO1xuLy8gICBjb25zdCBMYXRlc3RWYWx1ZSA9IDU5OTgwLjk7XG5cbi8vICAgY29uc3QgeFNjYWxlID0gdXNlTWVtbyhcbi8vICAgICAoKSA9PlxuLy8gICAgICAgc2NhbGVUaW1lPG51bWJlcj4oe1xuLy8gICAgICAgICBkb21haW46IGV4dGVudChkYXRhLCB4QWNjZXNzb3IpIGFzIFtEYXRlLCBEYXRlXSxcbi8vICAgICAgICAgcmFuZ2U6IFswLCBib3VuZGVkV2lkdGhdLFxuLy8gICAgICAgICBuaWNlOiB0cnVlLFxuLy8gICAgICAgfSksXG4vLyAgICAgW2JvdW5kZWRXaWR0aF1cbi8vICAgKTtcblxuLy8gICBjb25zdCB5U2NhbGUgPSB1c2VNZW1vKFxuLy8gICAgICgpID0+XG4vLyAgICAgICBzY2FsZUxpbmVhcjxudW1iZXI+KHtcbi8vICAgICAgICAgZG9tYWluOiBleHRlbnQoZGF0YSwgeUFjY2Vzc29yKSBhcyBbbnVtYmVyLCBudW1iZXJdLFxuLy8gICAgICAgICByYW5nZTogW2JvdW5kZWRIZWlnaHQsIDBdLFxuLy8gICAgICAgICBuaWNlOiB0cnVlLFxuLy8gICAgICAgfSksXG4vLyAgICAgW2JvdW5kZWRIZWlnaHRdXG4vLyAgICk7XG5cbi8vICAgY29uc3QgeyBzaG93VG9vbHRpcCwgaGlkZVRvb2x0aXAsIHRvb2x0aXBEYXRhLCB0b29sdGlwTGVmdCwgdG9vbHRpcFRvcCB9ID0gdXNlVG9vbHRpcCgpO1xuXG4vLyAgIGNvbnN0IGhhbmRsZVRvb2x0aXAgPSB1c2VDYWxsYmFjayhcbi8vICAgICAoZXZlbnQ6IFJlYWN0Lk1vdXNlRXZlbnQpID0+IHtcbi8vICAgICAgIGNvbnN0IHsgeCB9ID0gbG9jYWxQb2ludChldmVudCkgfHwgeyB4OiAwIH07XG4vLyAgICAgICBjb25zdCB4MCA9IHhTY2FsZS5pbnZlcnQoeCApOyAvLyBDb3JyZWN0bHkgaGFuZGxlIG1hcmdpbiBvZmZzZXRcbiAgXG4vLyAgICAgICBjb25zdCBiaXNlY3REYXRlID0gYmlzZWN0b3IoeEFjY2Vzc29yKS5sZWZ0O1xuLy8gICAgICAgY29uc3QgaW5kZXggPSBiaXNlY3REYXRlKGRhdGEsIHgwLCAxKTtcbi8vICAgICAgIGNvbnN0IGQwID0gZGF0YVtpbmRleCAtIDFdO1xuLy8gICAgICAgY29uc3QgZDEgPSBkYXRhW2luZGV4XTtcblxuLy8gICAgICAgbGV0IGQgPSBkMDtcbi8vICAgICAgIGlmIChkMSAmJiB4QWNjZXNzb3IoZDEpKSB7XG4vLyAgICAgICAgIGQgPSB4MCAtIHhBY2Nlc3NvcihkMCkgPiB4QWNjZXNzb3IoZDEpIC0geDAgPyBkMSA6IGQwO1xuLy8gICAgICAgfVxuICBcbi8vICAgICAgIHNob3dUb29sdGlwKHtcbi8vICAgICAgICAgdG9vbHRpcERhdGE6IGQsXG4vLyAgICAgICAgIHRvb2x0aXBMZWZ0OiB4U2NhbGUoeEFjY2Vzc29yKGQpKSxcbi8vICAgICAgICAgdG9vbHRpcFRvcDogeVNjYWxlKHlBY2Nlc3NvcihkKSksXG4vLyAgICAgICB9KTtcbi8vICAgICB9LFxuLy8gICAgIFt4U2NhbGUsIHlTY2FsZSwgc2hvd1Rvb2x0aXBdXG4vLyAgICk7XG4gIFxuICBcblxuLy8gICBjb25zdCBjdXN0b21ZUG9zaXRpb24gPSB5U2NhbGUoTHBZVmFsdWUpO1xuXG4vLyAgIGNvbnN0IHlUaWNrVmFsdWVzID0geVNjYWxlLnRpY2tzKDgpO1xuLy8gICBpZiAoIXlUaWNrVmFsdWVzLmluY2x1ZGVzKExwWVZhbHVlKSkgeVRpY2tWYWx1ZXMucHVzaChMcFlWYWx1ZSk7XG4vLyAgIGlmICgheVRpY2tWYWx1ZXMuaW5jbHVkZXMoTGF0ZXN0VmFsdWUpKSB5VGlja1ZhbHVlcy5wdXNoKExhdGVzdFZhbHVlKTtcblxuLy8gICByZXR1cm4gKFxuLy8gICAgIDxkaXYgY2xhc3NOYW1lPVwidy1maXRcIj5cbi8vICAgICAgIDxzdmcgY2xhc3NOYW1lPVwiXCIgd2lkdGg9e3dpZHRofSBoZWlnaHQ9e2hlaWdodH0gcm9sZT1cImZpZ3VyZVwiPlxuLy8gICAgICAgICA8cmVjdCB4PXswfSB5PXswfSB3aWR0aD17d2lkdGh9IGhlaWdodD17aGVpZ2h0fSAvPlxuLy8gICAgICAgICA8R3JvdXAgdG9wPXttYXJnaW4udG9wfSBsZWZ0PXttYXJnaW4ubGVmdH0+XG4vLyAgICAgICAgICAgPEdyaWRSb3dzXG4vLyAgICAgICAgICAgICBzY2FsZT17eVNjYWxlfVxuLy8gICAgICAgICAgICAgd2lkdGg9e2JvdW5kZWRXaWR0aH1cbi8vICAgICAgICAgICAgIHN0cm9rZURhc2hhcnJheT1cIjEsM1wiXG4vLyAgICAgICAgICAgICBzdHJva2U9XCIjMjYyNjI2XCJcbi8vICAgICAgICAgICAgIHBvaW50ZXJFdmVudHM9XCJub25lXCJcbi8vICAgICAgICAgICAvPlxuLy8gICAgICAgICAgIDxMaW5lUGF0aFxuLy8gICAgICAgICAgICAgY3VydmU9e2N1cnZlTGluZWFyfVxuLy8gICAgICAgICAgICAgZGF0YT17ZGF0YX1cbi8vICAgICAgICAgICAgIHN0cm9rZT17JyNGRkNBNDMnfVxuLy8gICAgICAgICAgICAgc3Ryb2tlV2lkdGg9ezEuNX1cbi8vICAgICAgICAgICAgIHg9eyhkKSA9PiB4U2NhbGUoeEFjY2Vzc29yKGQpKSA/PyAwfVxuLy8gICAgICAgICAgICAgeT17KGQpID0+IHlTY2FsZSh5QWNjZXNzb3IoZCkpID8/IDB9XG4vLyAgICAgICAgICAgLz5cblxuLy8gICAgICAgICAgIHtjdXN0b21ZUG9zaXRpb24gJiYgKFxuLy8gICAgICAgICAgICAgPGxpbmVcbi8vICAgICAgICAgICAgICAgeDE9ezB9XG4vLyAgICAgICAgICAgICAgIHgyPXtib3VuZGVkV2lkdGh9XG4vLyAgICAgICAgICAgICAgIHkxPXtjdXN0b21ZUG9zaXRpb259XG4vLyAgICAgICAgICAgICAgIHkyPXtjdXN0b21ZUG9zaXRpb259XG4vLyAgICAgICAgICAgICAgIHN0cm9rZT1cIndoaXRlXCJcbi8vICAgICAgICAgICAgICAgc3Ryb2tlV2lkdGg9ezF9XG4vLyAgICAgICAgICAgICAgIHN0cm9rZURhc2hhcnJheT1cIjMsNVwiXG4vLyAgICAgICAgICAgICAvPlxuLy8gICAgICAgICAgICl9XG5cbi8vICAgICAgICAgICA8QXhpc1JpZ2h0XG4vLyAgICAgICAgICAgICBsZWZ0PXtib3VuZGVkV2lkdGggKyBtYXJnaW4ucmlnaHQgLSA0MH1cbi8vICAgICAgICAgICAgIHNjYWxlPXt5U2NhbGV9XG4vLyAgICAgICAgICAgICB0b3A9ezB9XG4vLyAgICAgICAgICAgICBoaWRlQXhpc0xpbmU9e3RydWV9XG4vLyAgICAgICAgICAgICBoaWRlVGlja3M9e3RydWV9XG4vLyAgICAgICAgICAgICB0aWNrVmFsdWVzPXt5VGlja1ZhbHVlc31cbi8vICAgICAgICAgICAgIHRpY2tGb3JtYXQ9eyh2YWx1ZSkgPT4gYCR7TnVtYmVyKHZhbHVlKS50b0ZpeGVkKDEpfWB9XG4vLyAgICAgICAgICAgICB0aWNrTGFiZWxQcm9wcz17KCkgPT4gKHtcbi8vICAgICAgICAgICAgICAgZmlsbDogJyNBNkE2QTYnLFxuLy8gICAgICAgICAgICAgICBmb250U2l6ZTogOSxcbi8vICAgICAgICAgICAgICAgdGV4dEFuY2hvcjogJ3N0YXJ0Jyxcbi8vICAgICAgICAgICAgIH0pfVxuLy8gICAgICAgICAgICAgdGlja0NvbXBvbmVudD17KHtcbi8vICAgICAgICAgICAgICAgZm9ybWF0dGVkVmFsdWUsIHgsIHkgfSkgPT4ge1xuLy8gICAgICAgICAgICAgICAgIGlmIChmb3JtYXR0ZWRWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4vLyAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDsgXG4vLyAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBcbi8vICAgICAgICAgICAgICAgICBjb25zdCBudW1Gb3JtYXR0ZWRWYWx1ZSA9IE51bWJlcihmb3JtYXR0ZWRWYWx1ZSk7IFxuLy8gICAgICAgICAgICAgICAgIGNvbnN0IGlzTFBWYWx1ZSA9IG51bUZvcm1hdHRlZFZhbHVlID09PSBMcFlWYWx1ZTtcbi8vICAgICAgICAgICAgICAgICBjb25zdCBpc0xhdGVzdFZhbHVlID0gbnVtRm9ybWF0dGVkVmFsdWUgPT09IExhdGVzdFZhbHVlO1xuICAgICAgICAgICAgICBcbi8vICAgICAgICAgICAgICAgICBjb25zdCB0ZXh0ID0gaXNMUFZhbHVlXG4vLyAgICAgICAgICAgICAgICAgICA/IGBMUCAke0xwWVZhbHVlLnRvRml4ZWQoMSl9YFxuLy8gICAgICAgICAgICAgICAgICAgOiBpc0xhdGVzdFZhbHVlXG4vLyAgICAgICAgICAgICAgICAgICA/IGAke0xhdGVzdFZhbHVlLnRvRml4ZWQoMSl9YFxuLy8gICAgICAgICAgICAgICAgICAgOiBmb3JtYXR0ZWRWYWx1ZTtcbiAgXG4vLyAgICAgICAgICAgICAgICAgY29uc3QgcGFkZGluZ1ggPSA4OyBcbi8vICAgICAgICAgICAgICAgICBjb25zdCBwYWRkaW5nWSA9IDI7IFxuLy8gICAgICAgICAgICAgICAgIGNvbnN0IGZvbnRTaXplID0gOTtcbiAgICAgICAgICAgICAgXG4vLyAgICAgICAgICAgICAgICAgY29uc3QgdGV4dFdpZHRoID0gdGV4dC5sZW5ndGggKiAoZm9udFNpemUgKiAwLjYpOyAvLyBFc3RpbWF0ZSB0aGF0IGVhY2ggY2hhcmFjdGVyIGlzIH42MCUgb2YgdGhlIGZvbnQgc2l6ZVxuLy8gICAgICAgICAgICAgICAgIGNvbnN0IHJlY3RXaWR0aCA9IHRleHRXaWR0aCArIHBhZGRpbmdYOyAvLyBBZGQgcGFkZGluZyBmb3Igd2lkdGhcbi8vICAgICAgICAgICAgICAgICBjb25zdCByZWN0SGVpZ2h0ID0gZm9udFNpemUgKyBwYWRkaW5nWTsgLy8gQWRkIHBhZGRpbmcgZm9yIGhlaWdodFxuICAgIFxuLy8gICAgICAgICAgICAgICAgIGlmIChpc0xQVmFsdWUpIHtcbi8vICAgICAgICAgICAgICAgICAgIHJldHVybiAoXG4vLyAgICAgICAgICAgICAgICAgICAgIDxnIHRyYW5zZm9ybT17YHRyYW5zbGF0ZSgke3h9LCR7eX0pYH0+XG4vLyAgICAgICAgICAgICAgICAgICAgICAgPHJlY3Rcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIHg9ey1yZWN0V2lkdGggLyAyfSBcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIHk9ey1yZWN0SGVpZ2h0IC8gMn1cbi8vICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoPXtyZWN0V2lkdGh9XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ9e3JlY3RIZWlnaHR9XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBmaWxsPVwiIzRkNGQ0ZFwiXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICByeD17MH0gXG4vLyAgICAgICAgICAgICAgICAgICAgICAgLz5cbi8vICAgICAgICAgICAgICAgICAgICAgICA8dGV4dFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgZmlsbD1cIndoaXRlXCJcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIGZvbnRTaXplPXtmb250U2l6ZX1cbi8vICAgICAgICAgICAgICAgICAgICAgICAgIHRleHRBbmNob3I9XCJtaWRkbGVcIlxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgZHk9XCIwLjMyZW1cIlxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgeD17MH0gXG4vLyAgICAgICAgICAgICAgICAgICAgICAgPlxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgTFAge0xwWVZhbHVlLnRvRml4ZWQoMSl9XG4vLyAgICAgICAgICAgICAgICAgICAgICAgPC90ZXh0PlxuLy8gICAgICAgICAgICAgICAgICAgICA8L2c+XG4vLyAgICAgICAgICAgICAgICAgICApO1xuLy8gICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNMYXRlc3RWYWx1ZSkge1xuLy8gICAgICAgICAgICAgICAgICAgcmV0dXJuIChcbi8vICAgICAgICAgICAgICAgICAgICAgPGcgdHJhbnNmb3JtPXtgdHJhbnNsYXRlKCR7eH0sJHt5fSlgfT5cbi8vICAgICAgICAgICAgICAgICAgICAgICA8cmVjdFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgeD17LXJlY3RXaWR0aCAvIDJ9IFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgeT17LXJlY3RIZWlnaHQgLyAyfVxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg9e3JlY3RXaWR0aH1cbi8vICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodD17cmVjdEhlaWdodH1cbi8vICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGw9XCJ3aGl0ZVwiXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICByeD17MH0gXG4vLyAgICAgICAgICAgICAgICAgICAgICAgLz5cbi8vICAgICAgICAgICAgICAgICAgICAgICA8dGV4dFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgZmlsbD1cImJsYWNrXCJcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIGZvbnRXZWlnaHQ9XCI3MDBcIlxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgZm9udFNpemU9e2ZvbnRTaXplfVxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgdGV4dEFuY2hvcj1cIm1pZGRsZVwiXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBkeT1cIjAuMzJlbVwiXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICB4PXswfVxuLy8gICAgICAgICAgICAgICAgICAgICAgID5cbi8vICAgICAgICAgICAgICAgICAgICAgICAgIHtMYXRlc3RWYWx1ZS50b0ZpeGVkKDEpfVxuLy8gICAgICAgICAgICAgICAgICAgICAgIDwvdGV4dD5cbi8vICAgICAgICAgICAgICAgICAgICAgPC9nPlxuLy8gICAgICAgICAgICAgICAgICAgKTtcbi8vICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuLy8gICAgICAgICAgICAgICAgICAgcmV0dXJuIChcbi8vICAgICAgICAgICAgICAgICAgICAgPHRleHRcbi8vICAgICAgICAgICAgICAgICAgICAgICBmaWxsPVwiI0E2QTZBNlwiXG4vLyAgICAgICAgICAgICAgICAgICAgICAgZm9udFNpemU9e2ZvbnRTaXplfVxuLy8gICAgICAgICAgICAgICAgICAgICAgIHRleHRBbmNob3I9XCJzdGFydFwiXG4vLyAgICAgICAgICAgICAgICAgICAgICAgZHk9XCIwLjMyZW1cIlxuLy8gICAgICAgICAgICAgICAgICAgICAgIHg9ey0xMH1cbi8vICAgICAgICAgICAgICAgICAgICAgICB5PXt5fVxuLy8gICAgICAgICAgICAgICAgICAgICA+XG4vLyAgICAgICAgICAgICAgICAgICAgICAge3RleHR9XG4vLyAgICAgICAgICAgICAgICAgICAgIDwvdGV4dD5cbi8vICAgICAgICAgICAgICAgICAgICk7XG4vLyAgICAgICAgICAgICAgICAgfVxuLy8gICAgICAgICAgICAgfX1cbi8vICAgICAgICAgICAvPlxuLy8gICAgICAgICAgIDxBeGlzQm90dG9tXG4vLyAgICAgICAgICAgICByYW5nZVBhZGRpbmc9ezQxfVxuLy8gICAgICAgICAgICAgdG9wPXtib3VuZGVkSGVpZ2h0fVxuLy8gICAgICAgICAgICAgaGlkZUF4aXNMaW5lPXt0cnVlfVxuLy8gICAgICAgICAgICAgaGlkZVRpY2tzPXt0cnVlfVxuLy8gICAgICAgICAgICAgc2NhbGU9e3hTY2FsZX1cbi8vICAgICAgICAgICAgIHRpY2tGb3JtYXQ9eyhkKSA9PiAoZCBpbnN0YW5jZW9mIERhdGUgPyB0aW1lRm9ybWF0KCclSDolTScpKGQpIDogJycpfVxuLy8gICAgICAgICAgICAgdGlja0xhYmVsUHJvcHM9eygpID0+ICh7XG4vLyAgICAgICAgICAgICAgIGZpbGw6ICd3aGl0ZScsXG4vLyAgICAgICAgICAgICAgIGZvbnRTaXplOiA4LFxuLy8gICAgICAgICAgICAgICB0ZXh0QW5jaG9yOiAnbWlkZGxlJyxcbi8vICAgICAgICAgICAgIH0pfVxuLy8gICAgICAgICAgIC8+XG4vLyAgICAgICAgICAgPHJlY3Rcbi8vICAgICAgICAgICAgIHg9ezB9XG4vLyAgICAgICAgICAgICB5PXswfVxuLy8gICAgICAgICAgICAgd2lkdGg9e2JvdW5kZWRXaWR0aH1cbi8vICAgICAgICAgICAgIGhlaWdodD17Ym91bmRlZEhlaWdodH1cbi8vICAgICAgICAgICAgIGZpbGw9XCJ0cmFuc3BhcmVudFwiXG4vLyAgICAgICAgICAgICBvbk1vdXNlTW92ZT17aGFuZGxlVG9vbHRpcH1cbi8vICAgICAgICAgICAgIG9uTW91c2VMZWF2ZT17KCkgPT4gaGlkZVRvb2x0aXAoKX1cbi8vICAgICAgICAgICAvPlxuLy8gICAgICAgICA8L0dyb3VwPlxuLy8gICAgICAgICB7dG9vbHRpcERhdGEgJiYgKFxuLy8gICAgICAgICAgIDxjaXJjbGVcbi8vICAgICAgICAgICAgIGN4PXt0b29sdGlwTGVmdCArIDE0fVxuLy8gICAgICAgICAgICAgY3k9e3Rvb2x0aXBUb3AgKyAxMiB9XG4vLyAgICAgICAgICAgICByPXs1fVxuLy8gICAgICAgICAgICAgc3Ryb2tlPVwiYmxhY2tcIlxuLy8gICAgICAgICAgICAgZmlsbD1cIiNmZmNiOGZcIlxuLy8gICAgICAgICAgICAgc3Ryb2tlV2lkdGg9ezJ9XG4vLyAgICAgICAgICAgICBwb2ludGVyRXZlbnRzPVwibm9uZVwiXG4vLyAgICAgICAgICAgLz5cbi8vICAgICAgICAgKX1cbi8vICAgICAgIDwvc3ZnPlxuLy8gICAgICAge3Rvb2x0aXBEYXRhICYmIChcbi8vICAgICAgICAgPFRvb2x0aXBXaXRoQm91bmRzXG4vLyAgICAgICAgICAgdG9wPXt0b29sdGlwVG9wLTI1MH1cbi8vICAgICAgICAgICBsZWZ0PXt0b29sdGlwTGVmdH1cbi8vICAgICAgICAgICBzdHlsZT17e1xuLy8gICAgICAgICAgICAgd2lkdGg6ICcxMjBweCcsXG4vLyAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICcjNGQ0ZDRkJyxcbi8vICAgICAgICAgICAgIGNvbG9yOiAnd2hpdGUnLFxuLy8gICAgICAgICAgICAgcGFkZGluZzogJzAuNXJlbScsXG4vLyAgICAgICAgICAgICBib3JkZXJSYWRpdXM6ICc0cHgnLFxuLy8gICAgICAgICAgICAgZm9udFNpemU6ICcxMHB4Jyxcbi8vICAgICAgICAgICB9fVxuLy8gICAgICAgICA+XG4vLyAgICAgICAgICAgPGRpdj5EYXRlOiB7dGltZUZvcm1hdCgnJWIgJWQsICVZJykoeEFjY2Vzc29yKHRvb2x0aXBEYXRhKSl9PC9kaXY+XG4vLyAgICAgICAgICAgPGRpdj5WYWx1ZToge3lBY2Nlc3Nvcih0b29sdGlwRGF0YSl9PC9kaXY+XG4vLyAgICAgICAgIDwvVG9vbHRpcFdpdGhCb3VuZHM+XG4vLyAgICAgICApfVxuLy8gICAgIDwvZGl2PlxuLy8gICApO1xuLy8gfVxuXG4vLyBleHBvcnQgeyBMaW5lQ2hhcnQgfTtcblxuXG5cblxuXG4vLyBpbXBvcnQgUmVhY3QsIHsgdXNlTWVtbywgdXNlQ2FsbGJhY2sgfSBmcm9tICdyZWFjdCc7XG4vLyBpbXBvcnQgeyBleHRlbnQsIGJpc2VjdG9yIH0gZnJvbSAnZDMtYXJyYXknO1xuLy8gaW1wb3J0IHsgdGltZUZvcm1hdCB9IGZyb20gJ2QzLXRpbWUtZm9ybWF0Jztcbi8vIGltcG9ydCB7IEF4aXNCb3R0b20sIEF4aXNSaWdodCB9IGZyb20gJ0B2aXN4L2F4aXMnO1xuLy8gaW1wb3J0IHsgTGluZVBhdGgsIEJhciB9IGZyb20gJ0B2aXN4L3NoYXBlJztcbi8vIGltcG9ydCB7IEdyb3VwIH0gZnJvbSAnQHZpc3gvZ3JvdXAnO1xuLy8gaW1wb3J0IHsgc2NhbGVMaW5lYXIsIHNjYWxlVGltZSB9IGZyb20gJ0B2aXN4L3NjYWxlJztcbi8vIGltcG9ydCB7IEdyaWRSb3dzIH0gZnJvbSBcIkB2aXN4L2dyaWRcIjtcbi8vIGltcG9ydCB7IGN1cnZlTGluZWFyIH0gZnJvbSAnQHZpc3gvY3VydmUnO1xuLy8gaW1wb3J0IHsgd2l0aFRvb2x0aXAsIFRvb2x0aXBXaXRoQm91bmRzLCBkZWZhdWx0U3R5bGVzIH0gZnJvbSAnQHZpc3gvdG9vbHRpcCc7XG4vLyBpbXBvcnQgeyBsb2NhbFBvaW50IH0gZnJvbSAnQHZpc3gvZXZlbnQnO1xuXG4vLyBpbXBvcnQgeyBkYXRhIH0gZnJvbSAnLi4vZGF0YS9saW5lLWNoYXJ0Jztcbi8vIGltcG9ydCB7IGdldERpbWVuc2lvbnMsIHhBY2Nlc3NvciwgeUFjY2Vzc29yIH0gZnJvbSAnIy91dGlscy9saW5lLWNoYXJ0JztcblxuLy8gY29uc3QgZm9ybWF0RGF0ZSA9IHRpbWVGb3JtYXQoJyViICVkLCAlSDolTScpO1xuLy8gY29uc3QgdG9vbHRpcFN0eWxlcyA9IHtcbi8vICAgLi4uZGVmYXVsdFN0eWxlcyxcbi8vICAgYmFja2dyb3VuZDogJ3JnYmEoMCwgMCwgMCwgMC45KScsXG4vLyAgIGJvcmRlclJhZGl1czogJzRweCcsXG4vLyAgIGNvbG9yOiAnd2hpdGUnLFxuLy8gfTtcblxuLy8gY29uc3QgYmlzZWN0RGF0ZSA9IGJpc2VjdG9yKGQgPT4geEFjY2Vzc29yKGQpKS5sZWZ0O1xuXG4vLyB0eXBlIFByb3BzID0ge1xuLy8gICB3aWR0aDogbnVtYmVyO1xuLy8gICBoZWlnaHQ6IG51bWJlcjtcbi8vIH07XG5cbi8vIGZ1bmN0aW9uIExpbmVDaGFydCh7IHdpZHRoLCBoZWlnaHQsIHNob3dUb29sdGlwLCBoaWRlVG9vbHRpcCwgdG9vbHRpcERhdGEsIHRvb2x0aXBMZWZ0LCB0b29sdGlwVG9wIH06IFByb3BzICYgYW55KSB7XG4vLyAgIGNvbnN0IHsgbWFyZ2luLCBib3VuZGVkV2lkdGgsIGJvdW5kZWRIZWlnaHQgfSA9IGdldERpbWVuc2lvbnMoeyB3aWR0aCwgaGVpZ2h0IH0pO1xuLy8gICBjb25zdCBMcFlWYWx1ZSA9IDU0MzAwLjI7IFxuLy8gICBjb25zdCBMYXRlc3RWYWx1ZSA9IDU5OTgwLjk7XG5cbi8vICAgY29uc3QgeFNjYWxlID0gdXNlTWVtbygoKSA9PiBzY2FsZVRpbWUoe1xuLy8gICAgIGRvbWFpbjogZXh0ZW50KGRhdGEsIHhBY2Nlc3NvcikgYXMgW0RhdGUsIERhdGVdLFxuLy8gICAgIHJhbmdlOiBbMCwgYm91bmRlZFdpZHRoXSxcbi8vICAgICBuaWNlOiB0cnVlLFxuLy8gICB9KSwgW2JvdW5kZWRXaWR0aF0pO1xuXG4vLyAgIGNvbnN0IHlTY2FsZSA9IHVzZU1lbW8oKCkgPT4gc2NhbGVMaW5lYXIoe1xuLy8gICAgIGRvbWFpbjogZXh0ZW50KGRhdGEsIHlBY2Nlc3NvcikgYXMgW251bWJlciwgbnVtYmVyXSxcbi8vICAgICByYW5nZTogW2JvdW5kZWRIZWlnaHQsIDBdLFxuLy8gICAgIG5pY2U6IHRydWUsXG4vLyAgIH0pLCBbYm91bmRlZEhlaWdodF0pO1xuXG4vLyAgIGNvbnN0IGhhbmRsZVRvb2x0aXAgPSB1c2VDYWxsYmFjaygoZXZlbnQpID0+IHtcbi8vICAgICBjb25zdCB7IHggfSA9IGxvY2FsUG9pbnQoZXZlbnQpIHx8IHsgeDogMCB9O1xuLy8gICAgIGNvbnN0IHgwID0geFNjYWxlLmludmVydCh4KTtcbi8vICAgICBjb25zdCBpbmRleCA9IGJpc2VjdERhdGUoZGF0YSwgeDAsIDEpO1xuLy8gICAgIGNvbnN0IGQwID0gZGF0YVtpbmRleCAtIDFdO1xuLy8gICAgIGNvbnN0IGQxID0gZGF0YVtpbmRleF07XG4vLyAgICAgbGV0IGQgPSBkMDtcbi8vICAgICBpZiAoZDEgJiYgeEFjY2Vzc29yKGQxKSkge1xuLy8gICAgICAgZCA9IHgwLnZhbHVlT2YoKSAtIHhBY2Nlc3NvcihkMCkudmFsdWVPZigpID4geEFjY2Vzc29yKGQxKS52YWx1ZU9mKCkgLSB4MC52YWx1ZU9mKCkgPyBkMSA6IGQwO1xuLy8gICAgIH1cbi8vICAgICBzaG93VG9vbHRpcCh7XG4vLyAgICAgICB0b29sdGlwRGF0YTogZCxcbi8vICAgICAgIHRvb2x0aXBMZWZ0OiB4LFxuLy8gICAgICAgdG9vbHRpcFRvcDogeVNjYWxlKHlBY2Nlc3NvcihkKSksXG4vLyAgICAgfSk7XG4vLyAgIH0sIFtzaG93VG9vbHRpcCwgeVNjYWxlLCB4U2NhbGVdKTtcblxuLy8gICBjb25zdCBjdXN0b21ZUG9zaXRpb24gPSB5U2NhbGUoTHBZVmFsdWUpOyBcbi8vICAgY29uc3QgeVRpY2tWYWx1ZXMgPSB5U2NhbGUudGlja3MoOCk7XG5cbi8vICAgaWYgKCF5VGlja1ZhbHVlcy5pbmNsdWRlcyhMcFlWYWx1ZSkpIHtcbi8vICAgICB5VGlja1ZhbHVlcy5wdXNoKExwWVZhbHVlKTtcbi8vICAgfVxuLy8gICBpZiAoIXlUaWNrVmFsdWVzLmluY2x1ZGVzKExhdGVzdFZhbHVlKSkge1xuLy8gICAgIHlUaWNrVmFsdWVzLnB1c2goTGF0ZXN0VmFsdWUpO1xuLy8gICB9XG5cbi8vICAgcmV0dXJuIChcbi8vICAgICA8ZGl2IGNsYXNzTmFtZT1cInctZml0XCI+XG4vLyAgICAgICA8c3ZnIHdpZHRoPXt3aWR0aH0gaGVpZ2h0PXtoZWlnaHR9IHJvbGU9XCJmaWd1cmVcIj5cbi8vICAgICAgICAgPHJlY3QgeD17MH0geT17MH0gd2lkdGg9e3dpZHRofSBoZWlnaHQ9e2hlaWdodH0gZmlsbD1cInRyYW5zcGFyZW50XCIgLz5cbi8vICAgICAgICAgPEdyb3VwIHRvcD17bWFyZ2luLnRvcH0gbGVmdD17bWFyZ2luLmxlZnR9PlxuLy8gICAgICAgICAgIDxHcmlkUm93cyBzY2FsZT17eVNjYWxlfSB3aWR0aD17Ym91bmRlZFdpZHRofSBzdHJva2VEYXNoYXJyYXk9XCIxLDNcIiBzdHJva2U9XCIjMjYyNjI2XCIgcG9pbnRlckV2ZW50cz1cIm5vbmVcIiAvPlxuLy8gICAgICAgICAgIDxMaW5lUGF0aFxuLy8gICAgICAgICAgICAgY3VydmU9e2N1cnZlTGluZWFyfVxuLy8gICAgICAgICAgICAgZGF0YT17ZGF0YX1cbi8vICAgICAgICAgICAgIHN0cm9rZT17XCIjRkZDQTQzXCJ9XG4vLyAgICAgICAgICAgICBzdHJva2VXaWR0aD17MS41fVxuLy8gICAgICAgICAgICAgeD17KGQpID0+IHhTY2FsZSh4QWNjZXNzb3IoZCkpID8/IDB9XG4vLyAgICAgICAgICAgICB5PXsoZCkgPT4geVNjYWxlKHlBY2Nlc3NvcihkKSkgPz8gMH1cbi8vICAgICAgICAgICAvPlxuLy8gICAgICAgICAgIDxCYXJcbi8vICAgICAgICAgICAgIHg9ezB9XG4vLyAgICAgICAgICAgICB5PXswfVxuLy8gICAgICAgICAgICAgd2lkdGg9e2JvdW5kZWRXaWR0aH1cbi8vICAgICAgICAgICAgIGhlaWdodD17Ym91bmRlZEhlaWdodH1cbi8vICAgICAgICAgICAgIGZpbGw9XCJ0cmFuc3BhcmVudFwiXG4vLyAgICAgICAgICAgICBvbk1vdXNlTW92ZT17aGFuZGxlVG9vbHRpcH1cbi8vICAgICAgICAgICAgIG9uTW91c2VMZWF2ZT17aGlkZVRvb2x0aXB9XG4vLyAgICAgICAgICAgLz5cbi8vICAgICAgICAgICB7Y3VzdG9tWVBvc2l0aW9uICYmIChcbi8vICAgICAgICAgICAgIDxsaW5lXG4vLyAgICAgICAgICAgICAgIHgxPXswfVxuLy8gICAgICAgICAgICAgICB4Mj17Ym91bmRlZFdpZHRofVxuLy8gICAgICAgICAgICAgICB5MT17Y3VzdG9tWVBvc2l0aW9ufVxuLy8gICAgICAgICAgICAgICB5Mj17Y3VzdG9tWVBvc2l0aW9ufVxuLy8gICAgICAgICAgICAgICBzdHJva2U9XCJ3aGl0ZVwiXG4vLyAgICAgICAgICAgICAgIHN0cm9rZVdpZHRoPXsxfVxuLy8gICAgICAgICAgICAgICBzdHJva2VEYXNoYXJyYXk9XCIzLDVcIlxuLy8gICAgICAgICAgICAgLz5cbi8vICAgICAgICAgICApfVxuLy8gICAgICAgICAgIDxBeGlzUmlnaHRcbi8vICAgICAgICAgICAgIGxlZnQ9e2JvdW5kZWRXaWR0aCArIG1hcmdpbi5yaWdodCAtIDQwfVxuLy8gICAgICAgICAgICAgc2NhbGU9e3lTY2FsZX1cbi8vICAgICAgICAgICAgIHRvcD17MH1cbi8vICAgICAgICAgICAgIGhpZGVBeGlzTGluZT17dHJ1ZX1cbi8vICAgICAgICAgICAgIGhpZGVUaWNrcz17dHJ1ZX1cbi8vICAgICAgICAgICAgIHRpY2tWYWx1ZXM9e3lUaWNrVmFsdWVzfVxuLy8gICAgICAgICAgICAgdGlja0Zvcm1hdD17KHZhbHVlKSA9PiBgJHtOdW1iZXIodmFsdWUpLnRvRml4ZWQoMSl9YH1cbi8vICAgICAgICAgICAgIHRpY2tMYWJlbFByb3BzPXsoKSA9PiAoe1xuLy8gICAgICAgICAgICAgICBmaWxsOiAnI0E2QTZBNicsXG4vLyAgICAgICAgICAgICAgIGZvbnRTaXplOiA5LFxuLy8gICAgICAgICAgICAgICB0ZXh0QW5jaG9yOiAnc3RhcnQnLFxuLy8gICAgICAgICAgICAgfSl9XG4vLyAgICAgICAgICAgICB0aWNrQ29tcG9uZW50PXsoeyBmb3JtYXR0ZWRWYWx1ZSwgeCwgeSB9KSA9PiB7XG4vLyAgICAgICAgICAgICAgIGlmIChmb3JtYXR0ZWRWYWx1ZSA9PT0gdW5kZWZpbmVkKSByZXR1cm4gbnVsbDtcbi8vICAgICAgICAgICAgICAgY29uc3QgbnVtRm9ybWF0dGVkVmFsdWUgPSBOdW1iZXIoZm9ybWF0dGVkVmFsdWUpOyBcbi8vICAgICAgICAgICAgICAgY29uc3QgaXNMUFZhbHVlID0gbnVtRm9ybWF0dGVkVmFsdWUgPT09IExwWVZhbHVlO1xuLy8gICAgICAgICAgICAgICBjb25zdCBpc0xhdGVzdFZhbHVlID0gbnVtRm9ybWF0dGVkVmFsdWUgPT09IExhdGVzdFZhbHVlO1xuLy8gICAgICAgICAgICAgICBjb25zdCB0ZXh0ID0gaXNMUFZhbHVlID8gYExQICR7THBZVmFsdWUudG9GaXhlZCgxKX1gIDogaXNMYXRlc3RWYWx1ZSA/IGAke0xhdGVzdFZhbHVlLnRvRml4ZWQoMSl9YCA6IGZvcm1hdHRlZFZhbHVlO1xuXG4vLyAgICAgICAgICAgICAgIHJldHVybiAoXG4vLyAgICAgICAgICAgICAgICAgPHRleHRcbi8vICAgICAgICAgICAgICAgICAgIGZpbGw9e2lzTFBWYWx1ZSA/ICd3aGl0ZScgOiBpc0xhdGVzdFZhbHVlID8gJ3BpbmsnIDogJyNBNkE2QTYnfVxuLy8gICAgICAgICAgICAgICAgICAgZm9udFNpemU9ezl9XG4vLyAgICAgICAgICAgICAgICAgICBmb250V2VpZ2h0PXtpc0xhdGVzdFZhbHVlID8gJzcwMCcgOiAnbm9ybWFsJ31cbi8vICAgICAgICAgICAgICAgICAgIHg9e3ggLSAxMH1cbi8vICAgICAgICAgICAgICAgICAgIHk9e3l9XG4vLyAgICAgICAgICAgICAgICAgPlxuLy8gICAgICAgICAgICAgICAgICAge3RleHR9XG4vLyAgICAgICAgICAgICAgICAgPC90ZXh0PlxuLy8gICAgICAgICAgICAgICApO1xuLy8gICAgICAgICAgICAgfX1cbi8vICAgICAgICAgICAvPlxuLy8gICAgICAgICAgIDxBeGlzQm90dG9tXG4vLyAgICAgICAgICAgICByYW5nZVBhZGRpbmc9ezQxfVxuLy8gICAgICAgICAgICAgdG9wPXtib3VuZGVkSGVpZ2h0fVxuLy8gICAgICAgICAgICAgaGlkZUF4aXNMaW5lPXt0cnVlfVxuLy8gICAgICAgICAgICAgaGlkZVRpY2tzPXt0cnVlfVxuLy8gICAgICAgICAgICAgc2NhbGU9e3hTY2FsZX1cbi8vICAgICAgICAgICAgIHRpY2tGb3JtYXQ9eyhkKSA9PiAoZCBpbnN0YW5jZW9mIERhdGUgPyB0aW1lRm9ybWF0KCclSDolTScpKGQpIDogJycpfVxuLy8gICAgICAgICAgICAgdGlja0xhYmVsUHJvcHM9eygpID0+ICh7XG4vLyAgICAgICAgICAgICAgIGZpbGw6ICd3aGl0ZScsXG4vLyAgICAgICAgICAgICAgIGZvbnRTaXplOiA4LFxuLy8gICAgICAgICAgICAgICB0ZXh0QW5jaG9yOiAnbWlkZGxlJyxcbi8vICAgICAgICAgICAgIH0pfVxuLy8gICAgICAgICAgIC8+XG4vLyAgICAgICAgIDwvR3JvdXA+XG4vLyAgICAgICAgIHt0b29sdGlwRGF0YSAmJiAoXG4vLyAgICAgICAgICAgPGc+XG4vLyAgICAgICAgICAgICA8Y2lyY2xlIGN4PXt0b29sdGlwTGVmdH0gY3k9e3Rvb2x0aXBUb3ArMTB9IHI9ezR9IGZpbGw9XCJncmF5XCIgc3Ryb2tlPVwiYmxhY2tcIiBzdHJva2VXaWR0aD17MX0gLz5cbi8vICAgICAgICAgICA8L2c+XG4vLyAgICAgICAgICl9XG4vLyAgICAgICA8L3N2Zz5cbi8vICAgICAgIHt0b29sdGlwRGF0YSAmJiAoXG4vLyAgICAgICAgIDxkaXY+XG4vLyAgICAgICAgICAgPFRvb2x0aXBXaXRoQm91bmRzIHRvcD17dG9vbHRpcFRvcH0gbGVmdD17dG9vbHRpcExlZnR9IHN0eWxlPXt0b29sdGlwU3R5bGVzfT5cbi8vICAgICAgICAgICAgIHtgVmFsdWU6ICR7eUFjY2Vzc29yKHRvb2x0aXBEYXRhKX1gfVxuLy8gICAgICAgICAgIDwvVG9vbHRpcFdpdGhCb3VuZHM+XG4vLyAgICAgICAgIDwvZGl2PlxuLy8gICAgICAgKX1cbi8vICAgICA8L2Rpdj5cbi8vICAgKTtcbi8vIH1cblxuLy8gZXhwb3J0IGRlZmF1bHQgd2l0aFRvb2x0aXAoTGluZUNoYXJ0KTtcblxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/line-chart.tsx\n",
        ),
      );

      /***/
    },
});
