"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page", {
  /***/ "(app-pages-browser)/./src/components/line-chart.tsx":
    /*!***************************************!*\
  !*** ./src/components/line-chart.tsx ***!
  \***************************************/
    /***/ function (module, __webpack_exports__, __webpack_require__) {
      eval(
        __webpack_require__.ts(
          '__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ "(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! d3-array */ "(app-pages-browser)/./node_modules/d3-array/src/bisector.js");\n/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! d3-array */ "(app-pages-browser)/./node_modules/d3-array/src/extent.js");\n/* harmony import */ var d3_time_format__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-time-format */ "(app-pages-browser)/./node_modules/d3-time-format/src/defaultLocale.js");\n/* harmony import */ var _visx_axis__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! @visx/axis */ "(app-pages-browser)/./node_modules/@visx/axis/esm/axis/AxisRight.js");\n/* harmony import */ var _visx_axis__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! @visx/axis */ "(app-pages-browser)/./node_modules/@visx/axis/esm/axis/AxisBottom.js");\n/* harmony import */ var _visx_shape__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @visx/shape */ "(app-pages-browser)/./node_modules/@visx/shape/esm/shapes/LinePath.js");\n/* harmony import */ var _visx_shape__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! @visx/shape */ "(app-pages-browser)/./node_modules/@visx/shape/esm/shapes/Bar.js");\n/* harmony import */ var _visx_group__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @visx/group */ "(app-pages-browser)/./node_modules/@visx/group/esm/Group.js");\n/* harmony import */ var _visx_scale__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @visx/scale */ "(app-pages-browser)/./node_modules/@visx/scale/esm/scales/time.js");\n/* harmony import */ var _visx_scale__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @visx/scale */ "(app-pages-browser)/./node_modules/@visx/scale/esm/scales/linear.js");\n/* harmony import */ var _visx_grid__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @visx/grid */ "(app-pages-browser)/./node_modules/@visx/grid/esm/grids/GridRows.js");\n/* harmony import */ var _visx_curve__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! @visx/curve */ "(app-pages-browser)/./node_modules/d3-shape/src/curve/linear.js");\n/* harmony import */ var _visx_tooltip__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @visx/tooltip */ "(app-pages-browser)/./node_modules/@visx/tooltip/esm/tooltips/Tooltip.js");\n/* harmony import */ var _visx_tooltip__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! @visx/tooltip */ "(app-pages-browser)/./node_modules/@visx/tooltip/esm/tooltips/TooltipWithBounds.js");\n/* harmony import */ var _visx_tooltip__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! @visx/tooltip */ "(app-pages-browser)/./node_modules/@visx/tooltip/esm/enhancers/withTooltip.js");\n/* harmony import */ var _visx_event__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @visx/event */ "(app-pages-browser)/./node_modules/@visx/event/esm/localPoint.js");\n/* harmony import */ var _data_line_chart__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../data/line-chart */ "(app-pages-browser)/./src/data/line-chart.ts");\n/* harmony import */ var _utils_line_chart__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! #/utils/line-chart */ "(app-pages-browser)/./src/utils/line-chart.ts");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n// import React, { useMemo } from \'react\'\n// import { extent } from \'d3-array\'\n// import { timeFormat } from \'d3-time-format\'\n// import { AxisBottom, AxisRight } from \'@visx/axis\'\n// import { LinePath } from \'@visx/shape\'\n// import { Group } from \'@visx/group\'\n// import { scaleLinear, scaleTime } from \'@visx/scale\'\n// import { GridRows } from "@visx/grid";\n// import { curveLinear } from \'@visx/curve\'\n// import { data } from \'../data/line-chart\'\n// import { getDimensions, xAccessor, yAccessor } from \'#/utils/line-chart\'\n// type Props = {\n//   width: number\n//   height: number\n// }\n// function LineChart({ width, height }: Props) {\n//   const { margin, boundedWidth, boundedHeight } = getDimensions({\n//     width,\n//     height,\n//   })\n//   const LpYValue = 54300.2; \n//   const LatestValue = 59980.9;\n//   const xScale = useMemo(\n//     () =>\n//       scaleTime<number>({\n//         domain: extent(data, xAccessor) as [Date, Date],\n//         range: [0, boundedWidth],\n//         nice: true,\n//       }),\n//     [boundedWidth]\n//   )\n//   const yScale = useMemo(\n//     () =>\n//       scaleLinear<number>({\n//         domain: extent(data, yAccessor) as [number, number],\n//         range: [boundedHeight, 0],\n//         nice: true,\n//       }),\n//     [boundedHeight]\n//   )\n//   const customYPosition = yScale(LpYValue); \n//   // Generate y-axis tick values and ensure both LpYValue and LatestValue are included\n//   const yTickValues = yScale.ticks(8);\n//   if (!yTickValues.includes(LpYValue)) {\n//     yTickValues.push(LpYValue);\n//   }\n//   if (!yTickValues.includes(LatestValue)) {\n//     yTickValues.push(LatestValue);\n//   }\n//   return (\n//     <div className="w-fit">\n//       <svg\n//         className=\'\'\n//         width={width}\n//         height={height}\n//         role="figure"\n//       >\n//         <rect\n//             x={0}\n//             y={0}\n//             width={width}\n//             height={height}\n//         />\n//         <title>line chart looking at the distribution of max temperature</title>\n//         <Group top={margin.top} left={margin.left}>\n//           <GridRows\n//             scale={yScale}\n//             width={boundedWidth}\n//             strokeDasharray="1,3"\n//             stroke="#262626"\n//             pointerEvents="none"\n//           />\n//           <LinePath\n//             curve={curveLinear}\n//             data={data}\n//             stroke={"#FFCA43"}\n//             strokeWidth={1.5}\n//             x={(d) => xScale(xAccessor(d)) ?? 0}\n//             y={(d) => yScale(yAccessor(d)) ?? 0}\n//           />\n//           {customYPosition && (\n//             <line\n//               x1={0}\n//               x2={boundedWidth}\n//               y1={customYPosition}\n//               y2={customYPosition}\n//               stroke="white"\n//               strokeWidth={1}\n//               strokeDasharray="3,5" \n//             />\n//           )}\n//           <AxisRight\n//             left={boundedWidth + margin.right - 40}\n//             scale={yScale}\n//             top={0}\n//             hideAxisLine={true}\n//             hideTicks={true}\n//             labelOffset={0}\n//             tickValues={yTickValues}\n//             tickFormat={(value) => `${Number(value).toFixed(1)}`} \n//             tickLabelProps={() => ({\n//               fill: \'#A6A6A6\',\n//               fontSize: 9,\n//               textAnchor: \'start\',\n//             })}\n//             tickComponent={({ formattedValue, x, y }) => {\n//               if (formattedValue === undefined) {\n//                 return null; \n//               }\n//               const numFormattedValue = Number(formattedValue); \n//               const isLPValue = numFormattedValue === LpYValue;\n//               const isLatestValue = numFormattedValue === LatestValue;\n//               const text = isLPValue\n//                 ? `LP ${LpYValue.toFixed(1)}`\n//                 : isLatestValue\n//                 ? `${LatestValue.toFixed(1)}`\n//                 : formattedValue;\n//               const paddingX = 8; \n//               const paddingY = 2; \n//               const fontSize = 9;\n//               const textWidth = text.length * (fontSize * 0.6); // Estimate that each character is ~60% of the font size\n//               const rectWidth = textWidth + paddingX; // Add padding for width\n//               const rectHeight = fontSize + paddingY; // Add padding for height\n//               if (isLPValue) {\n//                 return (\n//                   <g transform={`translate(${x},${y})`}>\n//                     <rect\n//                       x={-rectWidth / 2} \n//                       y={-rectHeight / 2}\n//                       width={rectWidth}\n//                       height={rectHeight}\n//                       fill="#4d4d4d"\n//                       rx={0} \n//                     />\n//                     <text\n//                       fill="white"\n//                       fontSize={fontSize}\n//                       textAnchor="middle"\n//                       dy="0.32em"\n//                       x={0} \n//                     >\n//                       LP {LpYValue.toFixed(1)}\n//                     </text>\n//                   </g>\n//                 );\n//               } else if (isLatestValue) {\n//                 return (\n//                   <g transform={`translate(${x},${y})`}>\n//                     <rect\n//                       x={-rectWidth / 2} \n//                       y={-rectHeight / 2}\n//                       width={rectWidth}\n//                       height={rectHeight}\n//                       fill="white"\n//                       rx={0} \n//                     />\n//                     <text\n//                       fill="black"\n//                       fontWeight="700"\n//                       fontSize={fontSize}\n//                       textAnchor="middle"\n//                       dy="0.32em"\n//                       x={0}\n//                     >\n//                       {LatestValue.toFixed(1)}\n//                     </text>\n//                   </g>\n//                 );\n//               } else {\n//                 return (\n//                   <text\n//                     fill="#A6A6A6"\n//                     fontSize={fontSize}\n//                     textAnchor="start"\n//                     dy="0.32em"\n//                     x={-10}\n//                     y={y}\n//                   >\n//                     {text}\n//                   </text>\n//                 );\n//               }\n//             }}\n//           />\n//           <AxisBottom\n//             rangePadding={41}\n//             top={boundedHeight}\n//             hideAxisLine={true}\n//             hideTicks={true}\n//             scale={xScale}\n//             tickFormat={(d) => {\n//               return d instanceof Date ? timeFormat(\'%H:%M\')(d) : \'\';\n//             }}\n//             tickLabelProps={() => ({\n//               fill: \'white\',\n//               fontSize: 8,\n//               textAnchor: \'middle\',\n//             })}\n//           />\n//         </Group>\n//       </svg>\n//     </div>\n//   )\n// }\n// export { LineChart }\n// \'use client\'\n// import React, { useMemo, useCallback } from \'react\';\n// import { extent, bisector, max, min } from \'d3-array\';\n// import { timeFormat } from \'d3-time-format\';\n// import { AxisBottom, AxisRight } from \'@visx/axis\';\n// import { LinePath } from \'@visx/shape\';\n// import { Group } from \'@visx/group\';\n// import { scaleLinear, scaleTime } from \'@visx/scale\';\n// import { GridRows } from \'@visx/grid\';\n// import { curveLinear } from \'@visx/curve\';\n// import { useTooltip, TooltipWithBounds } from \'@visx/tooltip\';\n// import { localPoint } from \'@visx/event\';\n// import { data } from \'../data/line-chart\';\n// import { getDimensions, xAccessor, yAccessor } from \'#/utils/line-chart\';\n// type Props = {\n//   width: number;\n//   height: number;\n// };\n// function LineChart({ width, height }: Props) {\n//   const { margin, boundedWidth, boundedHeight } = getDimensions({\n//     width,\n//     height,\n//   });\n//   const LpYValue = 54300.2;\n//   const LatestValue = 59980.9;\n//   const xScale = useMemo(\n//     () =>\n//       scaleTime<number>({\n//         domain: extent(data, xAccessor) as [Date, Date],\n//         range: [0, boundedWidth],\n//         nice: true,\n//       }),\n//     [boundedWidth]\n//   );\n//   const yScale = useMemo(\n//     () =>\n//       scaleLinear<number>({\n//         domain: extent(data, yAccessor) as [number, number],\n//         range: [boundedHeight, 0],\n//         nice: true,\n//       }),\n//     [boundedHeight]\n//   );\n//   const { showTooltip, hideTooltip, tooltipData, tooltipLeft, tooltipTop } = useTooltip();\n//   const handleTooltip = useCallback(\n//     (event: React.MouseEvent) => {\n//       const { x } = localPoint(event) || { x: 0 };\n//       const x0 = xScale.invert(x - margin.left); // Get the date from x position\n//       const bisectDate = bisector(xAccessor).left;\n//       const index = bisectDate(data, x0, 1);\n//       const d0 = data[index - 1];\n//       const d1 = data[index];\n//       const d = x0 - xAccessor(d0) > xAccessor(d1) - x0 ? d1 : d0; // Get closest data point\n//       showTooltip({\n//         tooltipData: d,\n//         tooltipLeft: xScale(xAccessor(d)),\n//         tooltipTop: yScale(yAccessor(d)),\n//       });\n//     },\n//     [xScale, yScale, showTooltip]\n//   );\n//   const customYPosition = yScale(LpYValue);\n//   const yTickValues = yScale.ticks(8);\n//   if (!yTickValues.includes(LpYValue)) yTickValues.push(LpYValue);\n//   if (!yTickValues.includes(LatestValue)) yTickValues.push(LatestValue);\n//   return (\n//     <div className="w-fit">\n//       <svg className="" width={width} height={height} role="figure">\n//         <rect x={0} y={0} width={width} height={height} />\n//         <Group top={margin.top} left={margin.left}>\n//           <GridRows\n//             scale={yScale}\n//             width={boundedWidth}\n//             strokeDasharray="1,3"\n//             stroke="#262626"\n//             pointerEvents="none"\n//           />\n//           <LinePath\n//             curve={curveLinear}\n//             data={data}\n//             stroke={\'#FFCA43\'}\n//             strokeWidth={1.5}\n//             x={(d) => xScale(xAccessor(d)) ?? 0}\n//             y={(d) => yScale(yAccessor(d)) ?? 0}\n//           />\n//           {customYPosition && (\n//             <line\n//               x1={0}\n//               x2={boundedWidth}\n//               y1={customYPosition}\n//               y2={customYPosition}\n//               stroke="white"\n//               strokeWidth={1}\n//               strokeDasharray="3,5"\n//             />\n//           )}\n//           <AxisRight\n//             left={boundedWidth + margin.right - 40}\n//             scale={yScale}\n//             top={0}\n//             hideAxisLine={true}\n//             hideTicks={true}\n//             tickValues={yTickValues}\n//             tickFormat={(value) => `${Number(value).toFixed(1)}`}\n//             tickLabelProps={() => ({\n//               fill: \'#A6A6A6\',\n//               fontSize: 9,\n//               textAnchor: \'start\',\n//             })}\n//             tickComponent={({ formattedValue, x, y }) => {\n//                             if (formattedValue === undefined) {\n//                               return null; \n//                             }\n//                             const numFormattedValue = Number(formattedValue); \n//                             const isLPValue = numFormattedValue === LpYValue;\n//                             const isLatestValue = numFormattedValue === LatestValue;\n//                             const text = isLPValue\n//                               ? `LP ${LpYValue.toFixed(1)}`\n//                               : isLatestValue\n//                               ? `${LatestValue.toFixed(1)}`\n//                               : formattedValue;\n//                             const paddingX = 8; \n//                             const paddingY = 2; \n//                             const fontSize = 9;\n//                             const textWidth = text.length * (fontSize * 0.6); // Estimate that each character is ~60% of the font size\n//                             const rectWidth = textWidth + paddingX; // Add padding for width\n//                             const rectHeight = fontSize + paddingY; // Add padding for height\n//                             if (isLPValue) {\n//                               return (\n//                                 <g transform={`translate(${x},${y})`}>\n//                                   <rect\n//                                     x={-rectWidth / 2} \n//                                     y={-rectHeight / 2}\n//                                     width={rectWidth}\n//                                     height={rectHeight}\n//                                     fill="#4d4d4d"\n//                                     rx={0} \n//                                   />\n//                                   <text\n//                                     fill="white"\n//                                     fontSize={fontSize}\n//                                     textAnchor="middle"\n//                                     dy="0.32em"\n//                                     x={0} \n//                                   >\n//                                     LP {LpYValue.toFixed(1)}\n//                                   </text>\n//                                 </g>\n//                               );\n//                             } else if (isLatestValue) {\n//                               return (\n//                                 <g transform={`translate(${x},${y})`}>\n//                                   <rect\n//                                     x={-rectWidth / 2} \n//                                     y={-rectHeight / 2}\n//                                     width={rectWidth}\n//                                     height={rectHeight}\n//                                     fill="white"\n//                                     rx={0} \n//                                   />\n//                                   <text\n//                                     fill="black"\n//                                     fontWeight="700"\n//                                     fontSize={fontSize}\n//                                     textAnchor="middle"\n//                                     dy="0.32em"\n//                                     x={0}\n//                                   >\n//                                     {LatestValue.toFixed(1)}\n//                                   </text>\n//                                 </g>\n//                               );\n//                             } else {\n//                               return (\n//                                 <text\n//                                   fill="#A6A6A6"\n//                                   fontSize={fontSize}\n//                                   textAnchor="start"\n//                                   dy="0.32em"\n//                                   x={-10}\n//                                   y={y}\n//                                 >\n//                                   {text}\n//                                 </text>\n//                               );\n//                             }\n//                           }}\n//           />\n//           <AxisBottom\n//             rangePadding={41}\n//             top={boundedHeight}\n//             hideAxisLine={true}\n//             hideTicks={true}\n//             scale={xScale}\n//             tickFormat={(d) => (d instanceof Date ? timeFormat(\'%H:%M\')(d) : \'\')}\n//             tickLabelProps={() => ({\n//               fill: \'white\',\n//               fontSize: 8,\n//               textAnchor: \'middle\',\n//             })}\n//           />\n//           <rect\n//             x={0}\n//             y={0}\n//             width={boundedWidth}\n//             height={boundedHeight}\n//             fill="transparent"\n//             onMouseMove={handleTooltip}\n//             onMouseLeave={() => hideTooltip()}\n//           />\n//         </Group>\n//         {tooltipData && (\n//           <circle\n//             cx={tooltipLeft}\n//             cy={tooltipTop}\n//             r={5}\n//             stroke="black"\n//             fill="#ffcb8f"\n//             strokeWidth={2}\n//             pointerEvents="none"\n//           />\n//         )}\n//       </svg>\n//       {tooltipData && (\n//         <TooltipWithBounds\n//           top={tooltipTop - 12}\n//           left={tooltipLeft + 12}\n//           style={{\n//             backgroundColor: \'#4d4d4d\',\n//             color: \'white\',\n//             padding: \'0.5rem\',\n//             borderRadius: \'4px\',\n//             fontSize: \'10px\',\n//           }}\n//         >\n//           <div>Date: {timeFormat(\'%b %d, %Y\')(xAccessor(tooltipData))}</div>\n//           <div>Value: {yAccessor(tooltipData)}</div>\n//         </TooltipWithBounds>\n//       )}\n//     </div>\n//   );\n// }\n// export { LineChart };\n// import React, { useMemo } from \'react\'\n// import { extent } from \'d3-array\'\n// import { timeFormat } from \'d3-time-format\'\n// import { AxisBottom, AxisRight } from \'@visx/axis\'\n// import { LinePath } from \'@visx/shape\'\n// import { Group } from \'@visx/group\'\n// import { scaleLinear, scaleTime } from \'@visx/scale\'\n// import { GridRows } from "@visx/grid";\n// import { curveLinear } from \'@visx/curve\'\n// import { data } from \'../data/line-chart\'\n// import { getDimensions, xAccessor, yAccessor } from \'#/utils/line-chart\'\n// type Props = {\n//   width: number\n//   height: number\n// }\n// function LineChart({ width, height }: Props) {\n//   const { margin, boundedWidth, boundedHeight } = getDimensions({\n//     width,\n//     height,\n//   })\n//   const LpYValue = 54300.2; \n//   const LatestValue = 59980.9;\n//   const xScale = useMemo(\n//     () =>\n//       scaleTime<number>({\n//         domain: extent(data, xAccessor) as [Date, Date],\n//         range: [0, boundedWidth],\n//         nice: true,\n//       }),\n//     [boundedWidth]\n//   )\n//   const yScale = useMemo(\n//     () =>\n//       scaleLinear<number>({\n//         domain: extent(data, yAccessor) as [number, number],\n//         range: [boundedHeight, 0],\n//         nice: true,\n//       }),\n//     [boundedHeight]\n//   )\n//   const customYPosition = yScale(LpYValue); \n//   // Generate y-axis tick values and ensure both LpYValue and LatestValue are included\n//   const yTickValues = yScale.ticks(8);\n//   if (!yTickValues.includes(LpYValue)) {\n//     yTickValues.push(LpYValue);\n//   }\n//   if (!yTickValues.includes(LatestValue)) {\n//     yTickValues.push(LatestValue);\n//   }\n//   return (\n//     <div className="w-fit">\n//       <svg\n//         className=\'\'\n//         width={width}\n//         height={height}\n//         role="figure"\n//       >\n//         <rect\n//             x={0}\n//             y={0}\n//             width={width}\n//             height={height}\n//         />\n//         <title>line chart looking at the distribution of max temperature</title>\n//         <Group top={margin.top} left={margin.left}>\n//           <GridRows\n//             scale={yScale}\n//             width={boundedWidth}\n//             strokeDasharray="1,3"\n//             stroke="#262626"\n//             pointerEvents="none"\n//           />\n//           <LinePath\n//             curve={curveLinear}\n//             data={data}\n//             stroke={"#FFCA43"}\n//             strokeWidth={1.5}\n//             x={(d) => xScale(xAccessor(d)) ?? 0}\n//             y={(d) => yScale(yAccessor(d)) ?? 0}\n//           />\n//           {customYPosition && (\n//             <line\n//               x1={0}\n//               x2={boundedWidth}\n//               y1={customYPosition}\n//               y2={customYPosition}\n//               stroke="white"\n//               strokeWidth={1}\n//               strokeDasharray="3,5" \n//             />\n//           )}\n//           <AxisRight\n//             left={boundedWidth + margin.right - 40}\n//             scale={yScale}\n//             top={0}\n//             hideAxisLine={true}\n//             hideTicks={true}\n//             labelOffset={0}\n//             tickValues={yTickValues}\n//             tickFormat={(value) => `${Number(value).toFixed(1)}`} \n//             tickLabelProps={() => ({\n//               fill: \'#A6A6A6\',\n//               fontSize: 9,\n//               textAnchor: \'start\',\n//             })}\n//             tickComponent={({ formattedValue, x, y }) => {\n//               if (formattedValue === undefined) {\n//                 return null; \n//               }\n//               const numFormattedValue = Number(formattedValue); \n//               const isLPValue = numFormattedValue === LpYValue;\n//               const isLatestValue = numFormattedValue === LatestValue;\n//               const text = isLPValue\n//                 ? `LP ${LpYValue.toFixed(1)}`\n//                 : isLatestValue\n//                 ? `${LatestValue.toFixed(1)}`\n//                 : formattedValue;\n//               const paddingX = 8; \n//               const paddingY = 2; \n//               const fontSize = 9;\n//               const textWidth = text.length * (fontSize * 0.6); // Estimate that each character is ~60% of the font size\n//               const rectWidth = textWidth + paddingX; // Add padding for width\n//               const rectHeight = fontSize + paddingY; // Add padding for height\n//               if (isLPValue) {\n//                 return (\n//                   <g transform={`translate(${x},${y})`}>\n//                     <rect\n//                       x={-rectWidth / 2} \n//                       y={-rectHeight / 2}\n//                       width={rectWidth}\n//                       height={rectHeight}\n//                       fill="#4d4d4d"\n//                       rx={0} \n//                     />\n//                     <text\n//                       fill="white"\n//                       fontSize={fontSize}\n//                       textAnchor="middle"\n//                       dy="0.32em"\n//                       x={0} \n//                     >\n//                       LP {LpYValue.toFixed(1)}\n//                     </text>\n//                   </g>\n//                 );\n//               } else if (isLatestValue) {\n//                 return (\n//                   <g transform={`translate(${x},${y})`}>\n//                     <rect\n//                       x={-rectWidth / 2} \n//                       y={-rectHeight / 2}\n//                       width={rectWidth}\n//                       height={rectHeight}\n//                       fill="white"\n//                       rx={0} \n//                     />\n//                     <text\n//                       fill="black"\n//                       fontWeight="700"\n//                       fontSize={fontSize}\n//                       textAnchor="middle"\n//                       dy="0.32em"\n//                       x={0}\n//                     >\n//                       {LatestValue.toFixed(1)}\n//                     </text>\n//                   </g>\n//                 );\n//               } else {\n//                 return (\n//                   <text\n//                     fill="#A6A6A6"\n//                     fontSize={fontSize}\n//                     textAnchor="start"\n//                     dy="0.32em"\n//                     x={-10}\n//                     y={y}\n//                   >\n//                     {text}\n//                   </text>\n//                 );\n//               }\n//             }}\n//           />\n//           <AxisBottom\n//             rangePadding={41}\n//             top={boundedHeight}\n//             hideAxisLine={true}\n//             hideTicks={true}\n//             scale={xScale}\n//             tickFormat={(d) => {\n//               return d instanceof Date ? timeFormat(\'%H:%M\')(d) : \'\';\n//             }}\n//             tickLabelProps={() => ({\n//               fill: \'white\',\n//               fontSize: 8,\n//               textAnchor: \'middle\',\n//             })}\n//           />\n//         </Group>\n//       </svg>\n//     </div>\n//   )\n// }\n// export { LineChart }\n// \'use client\'\n// import React, { useMemo, useCallback } from \'react\';\n// import { extent, bisector, max, min } from \'d3-array\';\n// import { timeFormat } from \'d3-time-format\';\n// import { AxisBottom, AxisRight } from \'@visx/axis\';\n// import { LinePath } from \'@visx/shape\';\n// import { Group } from \'@visx/group\';\n// import { scaleLinear, scaleTime } from \'@visx/scale\';\n// import { GridRows } from \'@visx/grid\';\n// import { curveLinear } from \'@visx/curve\';\n// import { useTooltip, TooltipWithBounds } from \'@visx/tooltip\';\n// import { localPoint } from \'@visx/event\';\n// import { data } from \'../data/line-chart\';\n// import { getDimensions, xAccessor, yAccessor } from \'#/utils/line-chart\';\n// type Props = {\n//   width: number;\n//   height: number;\n// };\n// function LineChart({ width, height }: Props) {\n//   const { margin, boundedWidth, boundedHeight } = getDimensions({\n//     width,\n//     height,\n//   });\n//   const LpYValue = 54300.2;\n//   const LatestValue = 59980.9;\n//   const xScale = useMemo(\n//     () =>\n//       scaleTime<number>({\n//         domain: extent(data, xAccessor) as [Date, Date],\n//         range: [0, boundedWidth],\n//         nice: true,\n//       }),\n//     [boundedWidth]\n//   );\n//   const yScale = useMemo(\n//     () =>\n//       scaleLinear<number>({\n//         domain: extent(data, yAccessor) as [number, number],\n//         range: [boundedHeight, 0],\n//         nice: true,\n//       }),\n//     [boundedHeight]\n//   );\n//   const { showTooltip, hideTooltip, tooltipData, tooltipLeft, tooltipTop } = useTooltip();\n//   const handleTooltip = useCallback(\n//     (event: React.MouseEvent) => {\n//       const { x } = localPoint(event) || { x: 0 };\n//       const x0 = xScale.invert(x ); // Correctly handle margin offset\n//       const bisectDate = bisector(xAccessor).left;\n//       const index = bisectDate(data, x0, 1);\n//       const d0 = data[index - 1];\n//       const d1 = data[index];\n//       let d = d0;\n//       if (d1 && xAccessor(d1)) {\n//         d = x0 - xAccessor(d0) > xAccessor(d1) - x0 ? d1 : d0;\n//       }\n//       showTooltip({\n//         tooltipData: d,\n//         tooltipLeft: xScale(xAccessor(d)),\n//         tooltipTop: yScale(yAccessor(d)),\n//       });\n//     },\n//     [xScale, yScale, showTooltip]\n//   );\n//   const customYPosition = yScale(LpYValue);\n//   const yTickValues = yScale.ticks(8);\n//   if (!yTickValues.includes(LpYValue)) yTickValues.push(LpYValue);\n//   if (!yTickValues.includes(LatestValue)) yTickValues.push(LatestValue);\n//   return (\n//     <div className="w-fit">\n//       <svg className="" width={width} height={height} role="figure">\n//         <rect x={0} y={0} width={width} height={height} />\n//         <Group top={margin.top} left={margin.left}>\n//           <GridRows\n//             scale={yScale}\n//             width={boundedWidth}\n//             strokeDasharray="1,3"\n//             stroke="#262626"\n//             pointerEvents="none"\n//           />\n//           <LinePath\n//             curve={curveLinear}\n//             data={data}\n//             stroke={\'#FFCA43\'}\n//             strokeWidth={1.5}\n//             x={(d) => xScale(xAccessor(d)) ?? 0}\n//             y={(d) => yScale(yAccessor(d)) ?? 0}\n//           />\n//           {customYPosition && (\n//             <line\n//               x1={0}\n//               x2={boundedWidth}\n//               y1={customYPosition}\n//               y2={customYPosition}\n//               stroke="white"\n//               strokeWidth={1}\n//               strokeDasharray="3,5"\n//             />\n//           )}\n//           <AxisRight\n//             left={boundedWidth + margin.right - 40}\n//             scale={yScale}\n//             top={0}\n//             hideAxisLine={true}\n//             hideTicks={true}\n//             tickValues={yTickValues}\n//             tickFormat={(value) => `${Number(value).toFixed(1)}`}\n//             tickLabelProps={() => ({\n//               fill: \'#A6A6A6\',\n//               fontSize: 9,\n//               textAnchor: \'start\',\n//             })}\n//             tickComponent={({\n//               formattedValue, x, y }) => {\n//                 if (formattedValue === undefined) {\n//                   return null; \n//                 }\n//                 const numFormattedValue = Number(formattedValue); \n//                 const isLPValue = numFormattedValue === LpYValue;\n//                 const isLatestValue = numFormattedValue === LatestValue;\n//                 const text = isLPValue\n//                   ? `LP ${LpYValue.toFixed(1)}`\n//                   : isLatestValue\n//                   ? `${LatestValue.toFixed(1)}`\n//                   : formattedValue;\n//                 const paddingX = 8; \n//                 const paddingY = 2; \n//                 const fontSize = 9;\n//                 const textWidth = text.length * (fontSize * 0.6); // Estimate that each character is ~60% of the font size\n//                 const rectWidth = textWidth + paddingX; // Add padding for width\n//                 const rectHeight = fontSize + paddingY; // Add padding for height\n//                 if (isLPValue) {\n//                   return (\n//                     <g transform={`translate(${x},${y})`}>\n//                       <rect\n//                         x={-rectWidth / 2} \n//                         y={-rectHeight / 2}\n//                         width={rectWidth}\n//                         height={rectHeight}\n//                         fill="#4d4d4d"\n//                         rx={0} \n//                       />\n//                       <text\n//                         fill="white"\n//                         fontSize={fontSize}\n//                         textAnchor="middle"\n//                         dy="0.32em"\n//                         x={0} \n//                       >\n//                         LP {LpYValue.toFixed(1)}\n//                       </text>\n//                     </g>\n//                   );\n//                 } else if (isLatestValue) {\n//                   return (\n//                     <g transform={`translate(${x},${y})`}>\n//                       <rect\n//                         x={-rectWidth / 2} \n//                         y={-rectHeight / 2}\n//                         width={rectWidth}\n//                         height={rectHeight}\n//                         fill="white"\n//                         rx={0} \n//                       />\n//                       <text\n//                         fill="black"\n//                         fontWeight="700"\n//                         fontSize={fontSize}\n//                         textAnchor="middle"\n//                         dy="0.32em"\n//                         x={0}\n//                       >\n//                         {LatestValue.toFixed(1)}\n//                       </text>\n//                     </g>\n//                   );\n//                 } else {\n//                   return (\n//                     <text\n//                       fill="#A6A6A6"\n//                       fontSize={fontSize}\n//                       textAnchor="start"\n//                       dy="0.32em"\n//                       x={-10}\n//                       y={y}\n//                     >\n//                       {text}\n//                     </text>\n//                   );\n//                 }\n//             }}\n//           />\n//           <AxisBottom\n//             rangePadding={41}\n//             top={boundedHeight}\n//             hideAxisLine={true}\n//             hideTicks={true}\n//             scale={xScale}\n//             tickFormat={(d) => (d instanceof Date ? timeFormat(\'%H:%M\')(d) : \'\')}\n//             tickLabelProps={() => ({\n//               fill: \'white\',\n//               fontSize: 8,\n//               textAnchor: \'middle\',\n//             })}\n//           />\n//           <rect\n//             x={0}\n//             y={0}\n//             width={boundedWidth}\n//             height={boundedHeight}\n//             fill="transparent"\n//             onMouseMove={handleTooltip}\n//             onMouseLeave={() => hideTooltip()}\n//           />\n//         </Group>\n//         {tooltipData && (\n//           <circle\n//             cx={tooltipLeft + 14}\n//             cy={tooltipTop + 12 }\n//             r={5}\n//             stroke="black"\n//             fill="#ffcb8f"\n//             strokeWidth={2}\n//             pointerEvents="none"\n//           />\n//         )}\n//       </svg>\n//       {tooltipData && (\n//         <TooltipWithBounds\n//           top={tooltipTop-250}\n//           left={tooltipLeft}\n//           style={{\n//             width: \'120px\',\n//             backgroundColor: \'#4d4d4d\',\n//             color: \'white\',\n//             padding: \'0.5rem\',\n//             borderRadius: \'4px\',\n//             fontSize: \'10px\',\n//           }}\n//         >\n//           <div>Date: {timeFormat(\'%b %d, %Y\')(xAccessor(tooltipData))}</div>\n//           <div>Value: {yAccessor(tooltipData)}</div>\n//         </TooltipWithBounds>\n//       )}\n//     </div>\n//   );\n// }\n// export { LineChart };\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst formatDate = (0,d3_time_format__WEBPACK_IMPORTED_MODULE_4__.timeFormat)("%b %d, %H:%M");\nconst tooltipStyles = {\n    ..._visx_tooltip__WEBPACK_IMPORTED_MODULE_5__.defaultStyles,\n    background: "rgba(0, 0, 0, 0.9)",\n    borderRadius: "4px",\n    color: "white"\n};\nconst bisectDate = (0,d3_array__WEBPACK_IMPORTED_MODULE_6__["default"])((d)=>(0,_utils_line_chart__WEBPACK_IMPORTED_MODULE_3__.xAccessor)(d)).left;\nfunction LineChart(param) {\n    let { width, height, showTooltip, hideTooltip, tooltipData, tooltipLeft, tooltipTop } = param;\n    _s();\n    const { margin, boundedWidth, boundedHeight } = (0,_utils_line_chart__WEBPACK_IMPORTED_MODULE_3__.getDimensions)({\n        width,\n        height\n    });\n    const LpYValue = 54300.2;\n    const LatestValue = 59980.9;\n    const xScale = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>(0,_visx_scale__WEBPACK_IMPORTED_MODULE_7__["default"])({\n            domain: (0,d3_array__WEBPACK_IMPORTED_MODULE_8__["default"])(_data_line_chart__WEBPACK_IMPORTED_MODULE_2__.data, _utils_line_chart__WEBPACK_IMPORTED_MODULE_3__.xAccessor),\n            range: [\n                0,\n                boundedWidth\n            ],\n            nice: true\n        }), [\n        boundedWidth\n    ]);\n    const yScale = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>(0,_visx_scale__WEBPACK_IMPORTED_MODULE_9__["default"])({\n            domain: (0,d3_array__WEBPACK_IMPORTED_MODULE_8__["default"])(_data_line_chart__WEBPACK_IMPORTED_MODULE_2__.data, _utils_line_chart__WEBPACK_IMPORTED_MODULE_3__.yAccessor),\n            range: [\n                boundedHeight,\n                0\n            ],\n            nice: true\n        }), [\n        boundedHeight\n    ]);\n    const handleTooltip = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((event)=>{\n        const { x } = (0,_visx_event__WEBPACK_IMPORTED_MODULE_10__["default"])(event) || {\n            x: 0\n        };\n        const x0 = xScale.invert(x);\n        const index = bisectDate(_data_line_chart__WEBPACK_IMPORTED_MODULE_2__.data, x0, 1);\n        const d0 = _data_line_chart__WEBPACK_IMPORTED_MODULE_2__.data[index - 1];\n        const d1 = _data_line_chart__WEBPACK_IMPORTED_MODULE_2__.data[index];\n        let d = d0;\n        if (d1 && (0,_utils_line_chart__WEBPACK_IMPORTED_MODULE_3__.xAccessor)(d1)) {\n            d = x0.valueOf() - (0,_utils_line_chart__WEBPACK_IMPORTED_MODULE_3__.xAccessor)(d0).valueOf() > (0,_utils_line_chart__WEBPACK_IMPORTED_MODULE_3__.xAccessor)(d1).valueOf() - x0.valueOf() ? d1 : d0;\n        }\n        showTooltip({\n            tooltipData: d,\n            tooltipLeft: x,\n            tooltipTop: yScale((0,_utils_line_chart__WEBPACK_IMPORTED_MODULE_3__.yAccessor)(d))\n        });\n    }, [\n        showTooltip,\n        yScale,\n        xScale\n    ]);\n    const customYPosition = yScale(LpYValue);\n    const yTickValues = yScale.ticks(8);\n    if (!yTickValues.includes(LpYValue)) {\n        yTickValues.push(LpYValue);\n    }\n    if (!yTickValues.includes(LatestValue)) {\n        yTickValues.push(LatestValue);\n    }\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)("div", {\n        className: "w-fit",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)("svg", {\n                width: width,\n                height: height,\n                role: "figure",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)("rect", {\n                        x: 0,\n                        y: 0,\n                        width: width,\n                        height: height,\n                        fill: "transparent"\n                    }, void 0, false, {\n                        fileName: "/Users/aluaorazbek/Desktop/charts/src/components/line-chart.tsx",\n                        lineNumber: 1077,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_visx_group__WEBPACK_IMPORTED_MODULE_11__["default"], {\n                        top: margin.top,\n                        left: margin.left,\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_visx_grid__WEBPACK_IMPORTED_MODULE_12__["default"], {\n                                scale: yScale,\n                                width: boundedWidth,\n                                strokeDasharray: "1,3",\n                                stroke: "#262626",\n                                pointerEvents: "none"\n                            }, void 0, false, {\n                                fileName: "/Users/aluaorazbek/Desktop/charts/src/components/line-chart.tsx",\n                                lineNumber: 1079,\n                                columnNumber: 11\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_visx_shape__WEBPACK_IMPORTED_MODULE_13__["default"], {\n                                curve: _visx_curve__WEBPACK_IMPORTED_MODULE_14__["default"],\n                                data: _data_line_chart__WEBPACK_IMPORTED_MODULE_2__.data,\n                                stroke: "#FFCA43",\n                                strokeWidth: 1.5,\n                                x: (d)=>{\n                                    var _xScale;\n                                    return (_xScale = xScale((0,_utils_line_chart__WEBPACK_IMPORTED_MODULE_3__.xAccessor)(d))) !== null && _xScale !== void 0 ? _xScale : 0;\n                                },\n                                y: (d)=>{\n                                    var _yScale;\n                                    return (_yScale = yScale((0,_utils_line_chart__WEBPACK_IMPORTED_MODULE_3__.yAccessor)(d))) !== null && _yScale !== void 0 ? _yScale : 0;\n                                }\n                            }, void 0, false, {\n                                fileName: "/Users/aluaorazbek/Desktop/charts/src/components/line-chart.tsx",\n                                lineNumber: 1080,\n                                columnNumber: 11\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_visx_shape__WEBPACK_IMPORTED_MODULE_15__["default"], {\n                                x: 0,\n                                y: 0,\n                                width: boundedWidth,\n                                height: boundedHeight,\n                                fill: "transparent",\n                                onMouseMove: handleTooltip,\n                                onMouseLeave: hideTooltip\n                            }, void 0, false, {\n                                fileName: "/Users/aluaorazbek/Desktop/charts/src/components/line-chart.tsx",\n                                lineNumber: 1088,\n                                columnNumber: 11\n                            }, this),\n                            customYPosition && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)("line", {\n                                x1: 0,\n                                x2: boundedWidth,\n                                y1: customYPosition,\n                                y2: customYPosition,\n                                stroke: "white",\n                                strokeWidth: 1,\n                                strokeDasharray: "3,5"\n                            }, void 0, false, {\n                                fileName: "/Users/aluaorazbek/Desktop/charts/src/components/line-chart.tsx",\n                                lineNumber: 1098,\n                                columnNumber: 13\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_visx_axis__WEBPACK_IMPORTED_MODULE_16__["default"], {\n                                left: boundedWidth + margin.right - 40,\n                                scale: yScale,\n                                top: 0,\n                                hideAxisLine: true,\n                                hideTicks: true,\n                                tickValues: yTickValues,\n                                tickFormat: (value)=>"".concat(Number(value).toFixed(1)),\n                                tickLabelProps: ()=>({\n                                        fill: "#A6A6A6",\n                                        fontSize: 9,\n                                        textAnchor: "start"\n                                    }),\n                                tickComponent: (param)=>{\n                                    let { formattedValue, x, y } = param;\n                                    if (formattedValue === undefined) return null;\n                                    const numFormattedValue = Number(formattedValue);\n                                    const isLPValue = numFormattedValue === LpYValue;\n                                    const isLatestValue = numFormattedValue === LatestValue;\n                                    const text = isLPValue ? "LP ".concat(LpYValue.toFixed(1)) : isLatestValue ? "".concat(LatestValue.toFixed(1)) : formattedValue;\n                                    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)("text", {\n                                        fill: isLPValue ? "white" : isLatestValue ? "pink" : "#A6A6A6",\n                                        fontSize: 9,\n                                        fontWeight: isLatestValue ? "700" : "normal",\n                                        x: x - 10,\n                                        y: y,\n                                        children: text\n                                    }, void 0, false, {\n                                        fileName: "/Users/aluaorazbek/Desktop/charts/src/components/line-chart.tsx",\n                                        lineNumber: 1129,\n                                        columnNumber: 17\n                                    }, void 0);\n                                }\n                            }, void 0, false, {\n                                fileName: "/Users/aluaorazbek/Desktop/charts/src/components/line-chart.tsx",\n                                lineNumber: 1108,\n                                columnNumber: 11\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_visx_axis__WEBPACK_IMPORTED_MODULE_17__["default"], {\n                                rangePadding: 41,\n                                top: boundedHeight,\n                                hideAxisLine: true,\n                                hideTicks: true,\n                                scale: xScale,\n                                tickFormat: (d)=>d instanceof Date ? (0,d3_time_format__WEBPACK_IMPORTED_MODULE_4__.timeFormat)("%H:%M")(d) : "",\n                                tickLabelProps: ()=>({\n                                        fill: "white",\n                                        fontSize: 8,\n                                        textAnchor: "middle"\n                                    })\n                            }, void 0, false, {\n                                fileName: "/Users/aluaorazbek/Desktop/charts/src/components/line-chart.tsx",\n                                lineNumber: 1141,\n                                columnNumber: 11\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: "/Users/aluaorazbek/Desktop/charts/src/components/line-chart.tsx",\n                        lineNumber: 1078,\n                        columnNumber: 9\n                    }, this),\n                    tooltipData && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)("g", {\n                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)("circle", {\n                            cx: tooltipLeft,\n                            cy: tooltipTop,\n                            r: 4,\n                            fill: "white",\n                            stroke: "black",\n                            strokeWidth: 1\n                        }, void 0, false, {\n                            fileName: "/Users/aluaorazbek/Desktop/charts/src/components/line-chart.tsx",\n                            lineNumber: 1157,\n                            columnNumber: 13\n                        }, this)\n                    }, void 0, false, {\n                        fileName: "/Users/aluaorazbek/Desktop/charts/src/components/line-chart.tsx",\n                        lineNumber: 1156,\n                        columnNumber: 11\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: "/Users/aluaorazbek/Desktop/charts/src/components/line-chart.tsx",\n                lineNumber: 1076,\n                columnNumber: 7\n            }, this),\n            tooltipData && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)("div", {\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_visx_tooltip__WEBPACK_IMPORTED_MODULE_18__["default"], {\n                    top: tooltipTop + 10,\n                    left: tooltipLeft,\n                    style: tooltipStyles,\n                    children: "Value: ".concat((0,_utils_line_chart__WEBPACK_IMPORTED_MODULE_3__.yAccessor)(tooltipData))\n                }, void 0, false, {\n                    fileName: "/Users/aluaorazbek/Desktop/charts/src/components/line-chart.tsx",\n                    lineNumber: 1163,\n                    columnNumber: 11\n                }, this)\n            }, void 0, false, {\n                fileName: "/Users/aluaorazbek/Desktop/charts/src/components/line-chart.tsx",\n                lineNumber: 1162,\n                columnNumber: 9\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: "/Users/aluaorazbek/Desktop/charts/src/components/line-chart.tsx",\n        lineNumber: 1075,\n        columnNumber: 5\n    }, this);\n}\n_s(LineChart, "7mlZ5+yjidC/0PpUnFy3WfOdW68=");\n_c = LineChart;\n/* harmony default export */ __webpack_exports__["default"] = (_c1 = (0,_visx_tooltip__WEBPACK_IMPORTED_MODULE_19__["default"])(LineChart));\nvar _c, _c1;\n$RefreshReg$(_c, "LineChart");\n$RefreshReg$(_c1, "%default%");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we\'re in a\n        // browser context before continuing.\n        if (typeof self !== \'undefined\' &&\n            // AMP / No-JS mode does not inject these helpers:\n            \'$RefreshHelpers$\' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we\'ll check if it\'s\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we\'ll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it\'s possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL2xpbmUtY2hhcnQudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUVBLHlDQUF5QztBQUN6QyxvQ0FBb0M7QUFDcEMsOENBQThDO0FBQzlDLHFEQUFxRDtBQUNyRCx5Q0FBeUM7QUFDekMsc0NBQXNDO0FBQ3RDLHVEQUF1RDtBQUN2RCx5Q0FBeUM7QUFDekMsNENBQTRDO0FBRTVDLDRDQUE0QztBQUM1QywyRUFBMkU7QUFFM0UsaUJBQWlCO0FBQ2pCLGtCQUFrQjtBQUNsQixtQkFBbUI7QUFDbkIsSUFBSTtBQUVKLGlEQUFpRDtBQUNqRCxvRUFBb0U7QUFDcEUsYUFBYTtBQUNiLGNBQWM7QUFDZCxPQUFPO0FBRVAsK0JBQStCO0FBQy9CLGlDQUFpQztBQUVqQyw0QkFBNEI7QUFDNUIsWUFBWTtBQUNaLDRCQUE0QjtBQUM1QiwyREFBMkQ7QUFDM0Qsb0NBQW9DO0FBQ3BDLHNCQUFzQjtBQUN0QixZQUFZO0FBQ1oscUJBQXFCO0FBQ3JCLE1BQU07QUFFTiw0QkFBNEI7QUFDNUIsWUFBWTtBQUNaLDhCQUE4QjtBQUM5QiwrREFBK0Q7QUFDL0QscUNBQXFDO0FBQ3JDLHNCQUFzQjtBQUN0QixZQUFZO0FBQ1osc0JBQXNCO0FBQ3RCLE1BQU07QUFFTiwrQ0FBK0M7QUFFL0MseUZBQXlGO0FBQ3pGLHlDQUF5QztBQUV6QywyQ0FBMkM7QUFDM0Msa0NBQWtDO0FBQ2xDLE1BQU07QUFDTiw4Q0FBOEM7QUFDOUMscUNBQXFDO0FBQ3JDLE1BQU07QUFFTixhQUFhO0FBQ2IsOEJBQThCO0FBQzlCLGFBQWE7QUFDYix1QkFBdUI7QUFDdkIsd0JBQXdCO0FBQ3hCLDBCQUEwQjtBQUMxQix3QkFBd0I7QUFDeEIsVUFBVTtBQUNWLGdCQUFnQjtBQUNoQixvQkFBb0I7QUFDcEIsb0JBQW9CO0FBQ3BCLDRCQUE0QjtBQUM1Qiw4QkFBOEI7QUFDOUIsYUFBYTtBQUNiLG1GQUFtRjtBQUNuRixz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LENBQUMsTUFBT1MsZ0JBQWdCLEdBQTBCLE9BQXZCekQsWUFBWWdELE9BQU8sQ0FBQyxNQUFPSztvQ0FFckcscUJBQ0UsOERBQUNLO3dDQUNDaEMsTUFBTThCLFlBQVksVUFBVUMsZ0JBQWdCLFNBQVM7d0NBQ3JEUCxVQUFVO3dDQUNWUyxZQUFZRixnQkFBZ0IsUUFBUTt3Q0FDcENqRCxHQUFHQSxJQUFJO3dDQUNQaUIsR0FBR0E7a0RBRUZpQzs7Ozs7O2dDQUdQOzs7Ozs7MENBRUYsOERBQUMvRixtREFBVUE7Z0NBQ1RpRyxjQUFjO2dDQUNkakMsS0FBSzdCO2dDQUNMNEMsY0FBYztnQ0FDZEMsV0FBVztnQ0FDWGYsT0FBTzNCO2dDQUNQNEMsWUFBWSxDQUFDM0QsSUFBT0EsYUFBYTJFLE9BQU9uRywwREFBVUEsQ0FBQyxTQUFTd0IsS0FBSztnQ0FDakUrRCxnQkFBZ0IsSUFBTzt3Q0FDckJ2QixNQUFNO3dDQUNOd0IsVUFBVTt3Q0FDVkMsWUFBWTtvQ0FDZDs7Ozs7Ozs7Ozs7O29CQUdIMUQsNkJBQ0MsOERBQUNxRTtrQ0FDQyw0RUFBQ0M7NEJBQU9DLElBQUl0RTs0QkFBYXVFLElBQUl0RTs0QkFBWXVFLEdBQUc7NEJBQUd4QyxNQUFLOzRCQUFRSSxRQUFPOzRCQUFRRyxhQUFhOzs7Ozs7Ozs7Ozs7Ozs7OztZQUk3RnhDLDZCQUNDLDhEQUFDMkI7MEJBQ0MsNEVBQUMvQyxzREFBaUJBO29CQUFDc0QsS0FBS2hDLGFBQVc7b0JBQUlSLE1BQU1PO29CQUFheUUsT0FBT3RGOzhCQUM5RCxVQUFpQyxPQUF2QkYsNERBQVNBLENBQUNjOzs7Ozs7Ozs7Ozs7Ozs7OztBQU1qQztHQTVJU0w7S0FBQUE7QUE4SVQsK0RBQWUsTUFBQWhCLDBEQUFXQSxDQUFDZ0IsVUFBVUEsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvY29tcG9uZW50cy9saW5lLWNoYXJ0LnRzeD9jODVjIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50J1xuXG4vLyBpbXBvcnQgUmVhY3QsIHsgdXNlTWVtbyB9IGZyb20gJ3JlYWN0J1xuLy8gaW1wb3J0IHsgZXh0ZW50IH0gZnJvbSAnZDMtYXJyYXknXG4vLyBpbXBvcnQgeyB0aW1lRm9ybWF0IH0gZnJvbSAnZDMtdGltZS1mb3JtYXQnXG4vLyBpbXBvcnQgeyBBeGlzQm90dG9tLCBBeGlzUmlnaHQgfSBmcm9tICdAdmlzeC9heGlzJ1xuLy8gaW1wb3J0IHsgTGluZVBhdGggfSBmcm9tICdAdmlzeC9zaGFwZSdcbi8vIGltcG9ydCB7IEdyb3VwIH0gZnJvbSAnQHZpc3gvZ3JvdXAnXG4vLyBpbXBvcnQgeyBzY2FsZUxpbmVhciwgc2NhbGVUaW1lIH0gZnJvbSAnQHZpc3gvc2NhbGUnXG4vLyBpbXBvcnQgeyBHcmlkUm93cyB9IGZyb20gXCJAdmlzeC9ncmlkXCI7XG4vLyBpbXBvcnQgeyBjdXJ2ZUxpbmVhciB9IGZyb20gJ0B2aXN4L2N1cnZlJ1xuXG4vLyBpbXBvcnQgeyBkYXRhIH0gZnJvbSAnLi4vZGF0YS9saW5lLWNoYXJ0J1xuLy8gaW1wb3J0IHsgZ2V0RGltZW5zaW9ucywgeEFjY2Vzc29yLCB5QWNjZXNzb3IgfSBmcm9tICcjL3V0aWxzL2xpbmUtY2hhcnQnXG5cbi8vIHR5cGUgUHJvcHMgPSB7XG4vLyAgIHdpZHRoOiBudW1iZXJcbi8vICAgaGVpZ2h0OiBudW1iZXJcbi8vIH1cblxuLy8gZnVuY3Rpb24gTGluZUNoYXJ0KHsgd2lkdGgsIGhlaWdodCB9OiBQcm9wcykge1xuLy8gICBjb25zdCB7IG1hcmdpbiwgYm91bmRlZFdpZHRoLCBib3VuZGVkSGVpZ2h0IH0gPSBnZXREaW1lbnNpb25zKHtcbi8vICAgICB3aWR0aCxcbi8vICAgICBoZWlnaHQsXG4vLyAgIH0pXG5cbi8vICAgY29uc3QgTHBZVmFsdWUgPSA1NDMwMC4yOyBcbi8vICAgY29uc3QgTGF0ZXN0VmFsdWUgPSA1OTk4MC45O1xuXG4vLyAgIGNvbnN0IHhTY2FsZSA9IHVzZU1lbW8oXG4vLyAgICAgKCkgPT5cbi8vICAgICAgIHNjYWxlVGltZTxudW1iZXI+KHtcbi8vICAgICAgICAgZG9tYWluOiBleHRlbnQoZGF0YSwgeEFjY2Vzc29yKSBhcyBbRGF0ZSwgRGF0ZV0sXG4vLyAgICAgICAgIHJhbmdlOiBbMCwgYm91bmRlZFdpZHRoXSxcbi8vICAgICAgICAgbmljZTogdHJ1ZSxcbi8vICAgICAgIH0pLFxuLy8gICAgIFtib3VuZGVkV2lkdGhdXG4vLyAgIClcblxuLy8gICBjb25zdCB5U2NhbGUgPSB1c2VNZW1vKFxuLy8gICAgICgpID0+XG4vLyAgICAgICBzY2FsZUxpbmVhcjxudW1iZXI+KHtcbi8vICAgICAgICAgZG9tYWluOiBleHRlbnQoZGF0YSwgeUFjY2Vzc29yKSBhcyBbbnVtYmVyLCBudW1iZXJdLFxuLy8gICAgICAgICByYW5nZTogW2JvdW5kZWRIZWlnaHQsIDBdLFxuLy8gICAgICAgICBuaWNlOiB0cnVlLFxuLy8gICAgICAgfSksXG4vLyAgICAgW2JvdW5kZWRIZWlnaHRdXG4vLyAgIClcblxuLy8gICBjb25zdCBjdXN0b21ZUG9zaXRpb24gPSB5U2NhbGUoTHBZVmFsdWUpOyBcblxuLy8gICAvLyBHZW5lcmF0ZSB5LWF4aXMgdGljayB2YWx1ZXMgYW5kIGVuc3VyZSBib3RoIExwWVZhbHVlIGFuZCBMYXRlc3RWYWx1ZSBhcmUgaW5jbHVkZWRcbi8vICAgY29uc3QgeVRpY2tWYWx1ZXMgPSB5U2NhbGUudGlja3MoOCk7XG5cbi8vICAgaWYgKCF5VGlja1ZhbHVlcy5pbmNsdWRlcyhMcFlWYWx1ZSkpIHtcbi8vICAgICB5VGlja1ZhbHVlcy5wdXNoKExwWVZhbHVlKTtcbi8vICAgfVxuLy8gICBpZiAoIXlUaWNrVmFsdWVzLmluY2x1ZGVzKExhdGVzdFZhbHVlKSkge1xuLy8gICAgIHlUaWNrVmFsdWVzLnB1c2goTGF0ZXN0VmFsdWUpO1xuLy8gICB9XG5cbi8vICAgcmV0dXJuIChcbi8vICAgICA8ZGl2IGNsYXNzTmFtZT1cInctZml0XCI+XG4vLyAgICAgICA8c3ZnXG4vLyAgICAgICAgIGNsYXNzTmFtZT0nJ1xuLy8gICAgICAgICB3aWR0aD17d2lkdGh9XG4vLyAgICAgICAgIGhlaWdodD17aGVpZ2h0fVxuLy8gICAgICAgICByb2xlPVwiZmlndXJlXCJcbi8vICAgICAgID5cbi8vICAgICAgICAgPHJlY3Rcbi8vICAgICAgICAgICAgIHg9ezB9XG4vLyAgICAgICAgICAgICB5PXswfVxuLy8gICAgICAgICAgICAgd2lkdGg9e3dpZHRofVxuLy8gICAgICAgICAgICAgaGVpZ2h0PXtoZWlnaHR9XG4vLyAgICAgICAgIC8+XG4vLyAgICAgICAgIDx0aXRsZT5saW5lIGNoYXJ0IGxvb2tpbmcgYXQgdGhlIGRpc3RyaWJ1dGlvbiBvZiBtYXggdGVtcGVyYXR1cmU8L3RpdGxlPlxuLy8gICAgICAgICA8R3JvdXAgdG9wPXttYXJnaW4udG9wfSBsZWZ0PXttYXJnaW4ubGVmdH0+XG4vLyAgICAgICAgICAgPEdyaWRSb3dzXG4vLyAgICAgICAgICAgICBzY2FsZT17eVNjYWxlfVxuLy8gICAgICAgICAgICAgd2lkdGg9e2JvdW5kZWRXaWR0aH1cbi8vICAgICAgICAgICAgIHN0cm9rZURhc2hhcnJheT1cIjEsM1wiXG4vLyAgICAgICAgICAgICBzdHJva2U9XCIjMjYyNjI2XCJcbi8vICAgICAgICAgICAgIHBvaW50ZXJFdmVudHM9XCJub25lXCJcbi8vICAgICAgICAgICAvPlxuLy8gICAgICAgICAgIDxMaW5lUGF0aFxuLy8gICAgICAgICAgICAgY3VydmU9e2N1cnZlTGluZWFyfVxuLy8gICAgICAgICAgICAgZGF0YT17ZGF0YX1cbi8vICAgICAgICAgICAgIHN0cm9rZT17XCIjRkZDQTQzXCJ9XG4vLyAgICAgICAgICAgICBzdHJva2VXaWR0aD17MS41fVxuLy8gICAgICAgICAgICAgeD17KGQpID0+IHhTY2FsZSh4QWNjZXNzb3IoZCkpID8/IDB9XG4vLyAgICAgICAgICAgICB5PXsoZCkgPT4geVNjYWxlKHlBY2Nlc3NvcihkKSkgPz8gMH1cbi8vICAgICAgICAgICAvPlxuXG4vLyAgICAgICAgICAge2N1c3RvbVlQb3NpdGlvbiAmJiAoXG4vLyAgICAgICAgICAgICA8bGluZVxuLy8gICAgICAgICAgICAgICB4MT17MH1cbi8vICAgICAgICAgICAgICAgeDI9e2JvdW5kZWRXaWR0aH1cbi8vICAgICAgICAgICAgICAgeTE9e2N1c3RvbVlQb3NpdGlvbn1cbi8vICAgICAgICAgICAgICAgeTI9e2N1c3RvbVlQb3NpdGlvbn1cbi8vICAgICAgICAgICAgICAgc3Ryb2tlPVwid2hpdGVcIlxuLy8gICAgICAgICAgICAgICBzdHJva2VXaWR0aD17MX1cbi8vICAgICAgICAgICAgICAgc3Ryb2tlRGFzaGFycmF5PVwiMyw1XCIgXG4vLyAgICAgICAgICAgICAvPlxuLy8gICAgICAgICAgICl9XG5cbi8vICAgICAgICAgICA8QXhpc1JpZ2h0XG4vLyAgICAgICAgICAgICBsZWZ0PXtib3VuZGVkV2lkdGggKyBtYXJnaW4ucmlnaHQgLSA0MH1cbi8vICAgICAgICAgICAgIHNjYWxlPXt5U2NhbGV9XG4vLyAgICAgICAgICAgICB0b3A9ezB9XG4vLyAgICAgICAgICAgICBoaWRlQXhpc0xpbmU9e3RydWV9XG4vLyAgICAgICAgICAgICBoaWRlVGlja3M9e3RydWV9XG4vLyAgICAgICAgICAgICBsYWJlbE9mZnNldD17MH1cbi8vICAgICAgICAgICAgIHRpY2tWYWx1ZXM9e3lUaWNrVmFsdWVzfVxuLy8gICAgICAgICAgICAgdGlja0Zvcm1hdD17KHZhbHVlKSA9PiBgJHtOdW1iZXIodmFsdWUpLnRvRml4ZWQoMSl9YH0gXG4vLyAgICAgICAgICAgICB0aWNrTGFiZWxQcm9wcz17KCkgPT4gKHtcbi8vICAgICAgICAgICAgICAgZmlsbDogJyNBNkE2QTYnLFxuLy8gICAgICAgICAgICAgICBmb250U2l6ZTogOSxcbi8vICAgICAgICAgICAgICAgdGV4dEFuY2hvcjogJ3N0YXJ0Jyxcbi8vICAgICAgICAgICAgIH0pfVxuLy8gICAgICAgICAgICAgdGlja0NvbXBvbmVudD17KHsgZm9ybWF0dGVkVmFsdWUsIHgsIHkgfSkgPT4ge1xuLy8gICAgICAgICAgICAgICBpZiAoZm9ybWF0dGVkVmFsdWUgPT09IHVuZGVmaW5lZCkge1xuLy8gICAgICAgICAgICAgICAgIHJldHVybiBudWxsOyBcbi8vICAgICAgICAgICAgICAgfVxuXG4vLyAgICAgICAgICAgICAgIGNvbnN0IG51bUZvcm1hdHRlZFZhbHVlID0gTnVtYmVyKGZvcm1hdHRlZFZhbHVlKTsgXG4vLyAgICAgICAgICAgICAgIGNvbnN0IGlzTFBWYWx1ZSA9IG51bUZvcm1hdHRlZFZhbHVlID09PSBMcFlWYWx1ZTtcbi8vICAgICAgICAgICAgICAgY29uc3QgaXNMYXRlc3RWYWx1ZSA9IG51bUZvcm1hdHRlZFZhbHVlID09PSBMYXRlc3RWYWx1ZTtcblxuLy8gICAgICAgICAgICAgICBjb25zdCB0ZXh0ID0gaXNMUFZhbHVlXG4vLyAgICAgICAgICAgICAgICAgPyBgTFAgJHtMcFlWYWx1ZS50b0ZpeGVkKDEpfWBcbi8vICAgICAgICAgICAgICAgICA6IGlzTGF0ZXN0VmFsdWVcbi8vICAgICAgICAgICAgICAgICA/IGAke0xhdGVzdFZhbHVlLnRvRml4ZWQoMSl9YFxuLy8gICAgICAgICAgICAgICAgIDogZm9ybWF0dGVkVmFsdWU7XG5cbi8vICAgICAgICAgICAgICAgY29uc3QgcGFkZGluZ1ggPSA4OyBcbi8vICAgICAgICAgICAgICAgY29uc3QgcGFkZGluZ1kgPSAyOyBcbi8vICAgICAgICAgICAgICAgY29uc3QgZm9udFNpemUgPSA5O1xuXG4vLyAgICAgICAgICAgICAgIGNvbnN0IHRleHRXaWR0aCA9IHRleHQubGVuZ3RoICogKGZvbnRTaXplICogMC42KTsgLy8gRXN0aW1hdGUgdGhhdCBlYWNoIGNoYXJhY3RlciBpcyB+NjAlIG9mIHRoZSBmb250IHNpemVcbi8vICAgICAgICAgICAgICAgY29uc3QgcmVjdFdpZHRoID0gdGV4dFdpZHRoICsgcGFkZGluZ1g7IC8vIEFkZCBwYWRkaW5nIGZvciB3aWR0aFxuLy8gICAgICAgICAgICAgICBjb25zdCByZWN0SGVpZ2h0ID0gZm9udFNpemUgKyBwYWRkaW5nWTsgLy8gQWRkIHBhZGRpbmcgZm9yIGhlaWdodFxuXG4vLyAgICAgICAgICAgICAgIGlmIChpc0xQVmFsdWUpIHtcbi8vICAgICAgICAgICAgICAgICByZXR1cm4gKFxuLy8gICAgICAgICAgICAgICAgICAgPGcgdHJhbnNmb3JtPXtgdHJhbnNsYXRlKCR7eH0sJHt5fSlgfT5cbi8vICAgICAgICAgICAgICAgICAgICAgPHJlY3Rcbi8vICAgICAgICAgICAgICAgICAgICAgICB4PXstcmVjdFdpZHRoIC8gMn0gXG4vLyAgICAgICAgICAgICAgICAgICAgICAgeT17LXJlY3RIZWlnaHQgLyAyfVxuLy8gICAgICAgICAgICAgICAgICAgICAgIHdpZHRoPXtyZWN0V2lkdGh9XG4vLyAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0PXtyZWN0SGVpZ2h0fVxuLy8gICAgICAgICAgICAgICAgICAgICAgIGZpbGw9XCIjNGQ0ZDRkXCJcbi8vICAgICAgICAgICAgICAgICAgICAgICByeD17MH0gXG4vLyAgICAgICAgICAgICAgICAgICAgIC8+XG4vLyAgICAgICAgICAgICAgICAgICAgIDx0ZXh0XG4vLyAgICAgICAgICAgICAgICAgICAgICAgZmlsbD1cIndoaXRlXCJcbi8vICAgICAgICAgICAgICAgICAgICAgICBmb250U2l6ZT17Zm9udFNpemV9XG4vLyAgICAgICAgICAgICAgICAgICAgICAgdGV4dEFuY2hvcj1cIm1pZGRsZVwiXG4vLyAgICAgICAgICAgICAgICAgICAgICAgZHk9XCIwLjMyZW1cIlxuLy8gICAgICAgICAgICAgICAgICAgICAgIHg9ezB9IFxuLy8gICAgICAgICAgICAgICAgICAgICA+XG4vLyAgICAgICAgICAgICAgICAgICAgICAgTFAge0xwWVZhbHVlLnRvRml4ZWQoMSl9XG4vLyAgICAgICAgICAgICAgICAgICAgIDwvdGV4dD5cbi8vICAgICAgICAgICAgICAgICAgIDwvZz5cbi8vICAgICAgICAgICAgICAgICApO1xuLy8gICAgICAgICAgICAgICB9IGVsc2UgaWYgKGlzTGF0ZXN0VmFsdWUpIHtcbi8vICAgICAgICAgICAgICAgICByZXR1cm4gKFxuLy8gICAgICAgICAgICAgICAgICAgPGcgdHJhbnNmb3JtPXtgdHJhbnNsYXRlKCR7eH0sJHt5fSlgfT5cbi8vICAgICAgICAgICAgICAgICAgICAgPHJlY3Rcbi8vICAgICAgICAgICAgICAgICAgICAgICB4PXstcmVjdFdpZHRoIC8gMn0gXG4vLyAgICAgICAgICAgICAgICAgICAgICAgeT17LXJlY3RIZWlnaHQgLyAyfVxuLy8gICAgICAgICAgICAgICAgICAgICAgIHdpZHRoPXtyZWN0V2lkdGh9XG4vLyAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0PXtyZWN0SGVpZ2h0fVxuLy8gICAgICAgICAgICAgICAgICAgICAgIGZpbGw9XCJ3aGl0ZVwiXG4vLyAgICAgICAgICAgICAgICAgICAgICAgcng9ezB9IFxuLy8gICAgICAgICAgICAgICAgICAgICAvPlxuLy8gICAgICAgICAgICAgICAgICAgICA8dGV4dFxuLy8gICAgICAgICAgICAgICAgICAgICAgIGZpbGw9XCJibGFja1wiXG4vLyAgICAgICAgICAgICAgICAgICAgICAgZm9udFdlaWdodD1cIjcwMFwiXG4vLyAgICAgICAgICAgICAgICAgICAgICAgZm9udFNpemU9e2ZvbnRTaXplfVxuLy8gICAgICAgICAgICAgICAgICAgICAgIHRleHRBbmNob3I9XCJtaWRkbGVcIlxuLy8gICAgICAgICAgICAgICAgICAgICAgIGR5PVwiMC4zMmVtXCJcbi8vICAgICAgICAgICAgICAgICAgICAgICB4PXswfVxuLy8gICAgICAgICAgICAgICAgICAgICA+XG4vLyAgICAgICAgICAgICAgICAgICAgICAge0xhdGVzdFZhbHVlLnRvRml4ZWQoMSl9XG4vLyAgICAgICAgICAgICAgICAgICAgIDwvdGV4dD5cbi8vICAgICAgICAgICAgICAgICAgIDwvZz5cbi8vICAgICAgICAgICAgICAgICApO1xuLy8gICAgICAgICAgICAgICB9IGVsc2Uge1xuLy8gICAgICAgICAgICAgICAgIHJldHVybiAoXG4vLyAgICAgICAgICAgICAgICAgICA8dGV4dFxuLy8gICAgICAgICAgICAgICAgICAgICBmaWxsPVwiI0E2QTZBNlwiXG4vLyAgICAgICAgICAgICAgICAgICAgIGZvbnRTaXplPXtmb250U2l6ZX1cbi8vICAgICAgICAgICAgICAgICAgICAgdGV4dEFuY2hvcj1cInN0YXJ0XCJcbi8vICAgICAgICAgICAgICAgICAgICAgZHk9XCIwLjMyZW1cIlxuLy8gICAgICAgICAgICAgICAgICAgICB4PXstMTB9XG4vLyAgICAgICAgICAgICAgICAgICAgIHk9e3l9XG4vLyAgICAgICAgICAgICAgICAgICA+XG4vLyAgICAgICAgICAgICAgICAgICAgIHt0ZXh0fVxuLy8gICAgICAgICAgICAgICAgICAgPC90ZXh0PlxuLy8gICAgICAgICAgICAgICAgICk7XG4vLyAgICAgICAgICAgICAgIH1cbi8vICAgICAgICAgICAgIH19XG4vLyAgICAgICAgICAgLz5cbi8vICAgICAgICAgICA8QXhpc0JvdHRvbVxuLy8gICAgICAgICAgICAgcmFuZ2VQYWRkaW5nPXs0MX1cbi8vICAgICAgICAgICAgIHRvcD17Ym91bmRlZEhlaWdodH1cbi8vICAgICAgICAgICAgIGhpZGVBeGlzTGluZT17dHJ1ZX1cbi8vICAgICAgICAgICAgIGhpZGVUaWNrcz17dHJ1ZX1cbi8vICAgICAgICAgICAgIHNjYWxlPXt4U2NhbGV9XG4vLyAgICAgICAgICAgICB0aWNrRm9ybWF0PXsoZCkgPT4ge1xuLy8gICAgICAgICAgICAgICByZXR1cm4gZCBpbnN0YW5jZW9mIERhdGUgPyB0aW1lRm9ybWF0KCclSDolTScpKGQpIDogJyc7XG4vLyAgICAgICAgICAgICB9fVxuLy8gICAgICAgICAgICAgdGlja0xhYmVsUHJvcHM9eygpID0+ICh7XG4vLyAgICAgICAgICAgICAgIGZpbGw6ICd3aGl0ZScsXG4vLyAgICAgICAgICAgICAgIGZvbnRTaXplOiA4LFxuLy8gICAgICAgICAgICAgICB0ZXh0QW5jaG9yOiAnbWlkZGxlJyxcbi8vICAgICAgICAgICAgIH0pfVxuLy8gICAgICAgICAgIC8+XG4vLyAgICAgICAgIDwvR3JvdXA+XG4vLyAgICAgICA8L3N2Zz5cbi8vICAgICA8L2Rpdj5cbi8vICAgKVxuLy8gfVxuXG4vLyBleHBvcnQgeyBMaW5lQ2hhcnQgfVxuXG5cbi8vICd1c2UgY2xpZW50J1xuXG4vLyBpbXBvcnQgUmVhY3QsIHsgdXNlTWVtbywgdXNlQ2FsbGJhY2sgfSBmcm9tICdyZWFjdCc7XG4vLyBpbXBvcnQgeyBleHRlbnQsIGJpc2VjdG9yLCBtYXgsIG1pbiB9IGZyb20gJ2QzLWFycmF5Jztcbi8vIGltcG9ydCB7IHRpbWVGb3JtYXQgfSBmcm9tICdkMy10aW1lLWZvcm1hdCc7XG4vLyBpbXBvcnQgeyBBeGlzQm90dG9tLCBBeGlzUmlnaHQgfSBmcm9tICdAdmlzeC9heGlzJztcbi8vIGltcG9ydCB7IExpbmVQYXRoIH0gZnJvbSAnQHZpc3gvc2hhcGUnO1xuLy8gaW1wb3J0IHsgR3JvdXAgfSBmcm9tICdAdmlzeC9ncm91cCc7XG4vLyBpbXBvcnQgeyBzY2FsZUxpbmVhciwgc2NhbGVUaW1lIH0gZnJvbSAnQHZpc3gvc2NhbGUnO1xuLy8gaW1wb3J0IHsgR3JpZFJvd3MgfSBmcm9tICdAdmlzeC9ncmlkJztcbi8vIGltcG9ydCB7IGN1cnZlTGluZWFyIH0gZnJvbSAnQHZpc3gvY3VydmUnO1xuLy8gaW1wb3J0IHsgdXNlVG9vbHRpcCwgVG9vbHRpcFdpdGhCb3VuZHMgfSBmcm9tICdAdmlzeC90b29sdGlwJztcbi8vIGltcG9ydCB7IGxvY2FsUG9pbnQgfSBmcm9tICdAdmlzeC9ldmVudCc7XG5cbi8vIGltcG9ydCB7IGRhdGEgfSBmcm9tICcuLi9kYXRhL2xpbmUtY2hhcnQnO1xuLy8gaW1wb3J0IHsgZ2V0RGltZW5zaW9ucywgeEFjY2Vzc29yLCB5QWNjZXNzb3IgfSBmcm9tICcjL3V0aWxzL2xpbmUtY2hhcnQnO1xuXG4vLyB0eXBlIFByb3BzID0ge1xuLy8gICB3aWR0aDogbnVtYmVyO1xuLy8gICBoZWlnaHQ6IG51bWJlcjtcbi8vIH07XG5cbi8vIGZ1bmN0aW9uIExpbmVDaGFydCh7IHdpZHRoLCBoZWlnaHQgfTogUHJvcHMpIHtcbi8vICAgY29uc3QgeyBtYXJnaW4sIGJvdW5kZWRXaWR0aCwgYm91bmRlZEhlaWdodCB9ID0gZ2V0RGltZW5zaW9ucyh7XG4vLyAgICAgd2lkdGgsXG4vLyAgICAgaGVpZ2h0LFxuLy8gICB9KTtcblxuLy8gICBjb25zdCBMcFlWYWx1ZSA9IDU0MzAwLjI7XG4vLyAgIGNvbnN0IExhdGVzdFZhbHVlID0gNTk5ODAuOTtcblxuLy8gICBjb25zdCB4U2NhbGUgPSB1c2VNZW1vKFxuLy8gICAgICgpID0+XG4vLyAgICAgICBzY2FsZVRpbWU8bnVtYmVyPih7XG4vLyAgICAgICAgIGRvbWFpbjogZXh0ZW50KGRhdGEsIHhBY2Nlc3NvcikgYXMgW0RhdGUsIERhdGVdLFxuLy8gICAgICAgICByYW5nZTogWzAsIGJvdW5kZWRXaWR0aF0sXG4vLyAgICAgICAgIG5pY2U6IHRydWUsXG4vLyAgICAgICB9KSxcbi8vICAgICBbYm91bmRlZFdpZHRoXVxuLy8gICApO1xuXG4vLyAgIGNvbnN0IHlTY2FsZSA9IHVzZU1lbW8oXG4vLyAgICAgKCkgPT5cbi8vICAgICAgIHNjYWxlTGluZWFyPG51bWJlcj4oe1xuLy8gICAgICAgICBkb21haW46IGV4dGVudChkYXRhLCB5QWNjZXNzb3IpIGFzIFtudW1iZXIsIG51bWJlcl0sXG4vLyAgICAgICAgIHJhbmdlOiBbYm91bmRlZEhlaWdodCwgMF0sXG4vLyAgICAgICAgIG5pY2U6IHRydWUsXG4vLyAgICAgICB9KSxcbi8vICAgICBbYm91bmRlZEhlaWdodF1cbi8vICAgKTtcblxuLy8gICBjb25zdCB7IHNob3dUb29sdGlwLCBoaWRlVG9vbHRpcCwgdG9vbHRpcERhdGEsIHRvb2x0aXBMZWZ0LCB0b29sdGlwVG9wIH0gPSB1c2VUb29sdGlwKCk7XG5cbi8vICAgY29uc3QgaGFuZGxlVG9vbHRpcCA9IHVzZUNhbGxiYWNrKFxuLy8gICAgIChldmVudDogUmVhY3QuTW91c2VFdmVudCkgPT4ge1xuLy8gICAgICAgY29uc3QgeyB4IH0gPSBsb2NhbFBvaW50KGV2ZW50KSB8fCB7IHg6IDAgfTtcbi8vICAgICAgIGNvbnN0IHgwID0geFNjYWxlLmludmVydCh4IC0gbWFyZ2luLmxlZnQpOyAvLyBHZXQgdGhlIGRhdGUgZnJvbSB4IHBvc2l0aW9uXG5cbi8vICAgICAgIGNvbnN0IGJpc2VjdERhdGUgPSBiaXNlY3Rvcih4QWNjZXNzb3IpLmxlZnQ7XG4vLyAgICAgICBjb25zdCBpbmRleCA9IGJpc2VjdERhdGUoZGF0YSwgeDAsIDEpO1xuLy8gICAgICAgY29uc3QgZDAgPSBkYXRhW2luZGV4IC0gMV07XG4vLyAgICAgICBjb25zdCBkMSA9IGRhdGFbaW5kZXhdO1xuLy8gICAgICAgY29uc3QgZCA9IHgwIC0geEFjY2Vzc29yKGQwKSA+IHhBY2Nlc3NvcihkMSkgLSB4MCA/IGQxIDogZDA7IC8vIEdldCBjbG9zZXN0IGRhdGEgcG9pbnRcblxuLy8gICAgICAgc2hvd1Rvb2x0aXAoe1xuLy8gICAgICAgICB0b29sdGlwRGF0YTogZCxcbi8vICAgICAgICAgdG9vbHRpcExlZnQ6IHhTY2FsZSh4QWNjZXNzb3IoZCkpLFxuLy8gICAgICAgICB0b29sdGlwVG9wOiB5U2NhbGUoeUFjY2Vzc29yKGQpKSxcbi8vICAgICAgIH0pO1xuLy8gICAgIH0sXG4vLyAgICAgW3hTY2FsZSwgeVNjYWxlLCBzaG93VG9vbHRpcF1cbi8vICAgKTtcblxuLy8gICBjb25zdCBjdXN0b21ZUG9zaXRpb24gPSB5U2NhbGUoTHBZVmFsdWUpO1xuXG4vLyAgIGNvbnN0IHlUaWNrVmFsdWVzID0geVNjYWxlLnRpY2tzKDgpO1xuLy8gICBpZiAoIXlUaWNrVmFsdWVzLmluY2x1ZGVzKExwWVZhbHVlKSkgeVRpY2tWYWx1ZXMucHVzaChMcFlWYWx1ZSk7XG4vLyAgIGlmICgheVRpY2tWYWx1ZXMuaW5jbHVkZXMoTGF0ZXN0VmFsdWUpKSB5VGlja1ZhbHVlcy5wdXNoKExhdGVzdFZhbHVlKTtcblxuLy8gICByZXR1cm4gKFxuLy8gICAgIDxkaXYgY2xhc3NOYW1lPVwidy1maXRcIj5cbi8vICAgICAgIDxzdmcgY2xhc3NOYW1lPVwiXCIgd2lkdGg9e3dpZHRofSBoZWlnaHQ9e2hlaWdodH0gcm9sZT1cImZpZ3VyZVwiPlxuLy8gICAgICAgICA8cmVjdCB4PXswfSB5PXswfSB3aWR0aD17d2lkdGh9IGhlaWdodD17aGVpZ2h0fSAvPlxuLy8gICAgICAgICA8R3JvdXAgdG9wPXttYXJnaW4udG9wfSBsZWZ0PXttYXJnaW4ubGVmdH0+XG4vLyAgICAgICAgICAgPEdyaWRSb3dzXG4vLyAgICAgICAgICAgICBzY2FsZT17eVNjYWxlfVxuLy8gICAgICAgICAgICAgd2lkdGg9e2JvdW5kZWRXaWR0aH1cbi8vICAgICAgICAgICAgIHN0cm9rZURhc2hhcnJheT1cIjEsM1wiXG4vLyAgICAgICAgICAgICBzdHJva2U9XCIjMjYyNjI2XCJcbi8vICAgICAgICAgICAgIHBvaW50ZXJFdmVudHM9XCJub25lXCJcbi8vICAgICAgICAgICAvPlxuLy8gICAgICAgICAgIDxMaW5lUGF0aFxuLy8gICAgICAgICAgICAgY3VydmU9e2N1cnZlTGluZWFyfVxuLy8gICAgICAgICAgICAgZGF0YT17ZGF0YX1cbi8vICAgICAgICAgICAgIHN0cm9rZT17JyNGRkNBNDMnfVxuLy8gICAgICAgICAgICAgc3Ryb2tlV2lkdGg9ezEuNX1cbi8vICAgICAgICAgICAgIHg9eyhkKSA9PiB4U2NhbGUoeEFjY2Vzc29yKGQpKSA/PyAwfVxuLy8gICAgICAgICAgICAgeT17KGQpID0+IHlTY2FsZSh5QWNjZXNzb3IoZCkpID8/IDB9XG4vLyAgICAgICAgICAgLz5cblxuLy8gICAgICAgICAgIHtjdXN0b21ZUG9zaXRpb24gJiYgKFxuLy8gICAgICAgICAgICAgPGxpbmVcbi8vICAgICAgICAgICAgICAgeDE9ezB9XG4vLyAgICAgICAgICAgICAgIHgyPXtib3VuZGVkV2lkdGh9XG4vLyAgICAgICAgICAgICAgIHkxPXtjdXN0b21ZUG9zaXRpb259XG4vLyAgICAgICAgICAgICAgIHkyPXtjdXN0b21ZUG9zaXRpb259XG4vLyAgICAgICAgICAgICAgIHN0cm9rZT1cIndoaXRlXCJcbi8vICAgICAgICAgICAgICAgc3Ryb2tlV2lkdGg9ezF9XG4vLyAgICAgICAgICAgICAgIHN0cm9rZURhc2hhcnJheT1cIjMsNVwiXG4vLyAgICAgICAgICAgICAvPlxuLy8gICAgICAgICAgICl9XG5cbi8vICAgICAgICAgICA8QXhpc1JpZ2h0XG4vLyAgICAgICAgICAgICBsZWZ0PXtib3VuZGVkV2lkdGggKyBtYXJnaW4ucmlnaHQgLSA0MH1cbi8vICAgICAgICAgICAgIHNjYWxlPXt5U2NhbGV9XG4vLyAgICAgICAgICAgICB0b3A9ezB9XG4vLyAgICAgICAgICAgICBoaWRlQXhpc0xpbmU9e3RydWV9XG4vLyAgICAgICAgICAgICBoaWRlVGlja3M9e3RydWV9XG4vLyAgICAgICAgICAgICB0aWNrVmFsdWVzPXt5VGlja1ZhbHVlc31cbi8vICAgICAgICAgICAgIHRpY2tGb3JtYXQ9eyh2YWx1ZSkgPT4gYCR7TnVtYmVyKHZhbHVlKS50b0ZpeGVkKDEpfWB9XG4vLyAgICAgICAgICAgICB0aWNrTGFiZWxQcm9wcz17KCkgPT4gKHtcbi8vICAgICAgICAgICAgICAgZmlsbDogJyNBNkE2QTYnLFxuLy8gICAgICAgICAgICAgICBmb250U2l6ZTogOSxcbi8vICAgICAgICAgICAgICAgdGV4dEFuY2hvcjogJ3N0YXJ0Jyxcbi8vICAgICAgICAgICAgIH0pfVxuLy8gICAgICAgICAgICAgdGlja0NvbXBvbmVudD17KHsgZm9ybWF0dGVkVmFsdWUsIHgsIHkgfSkgPT4ge1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmb3JtYXR0ZWRWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDsgXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBudW1Gb3JtYXR0ZWRWYWx1ZSA9IE51bWJlcihmb3JtYXR0ZWRWYWx1ZSk7IFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGlzTFBWYWx1ZSA9IG51bUZvcm1hdHRlZFZhbHVlID09PSBMcFlWYWx1ZTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpc0xhdGVzdFZhbHVlID0gbnVtRm9ybWF0dGVkVmFsdWUgPT09IExhdGVzdFZhbHVlO1xuICAgICAgICAgICAgICBcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0ZXh0ID0gaXNMUFZhbHVlXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGBMUCAke0xwWVZhbHVlLnRvRml4ZWQoMSl9YFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBpc0xhdGVzdFZhbHVlXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGAke0xhdGVzdFZhbHVlLnRvRml4ZWQoMSl9YFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBmb3JtYXR0ZWRWYWx1ZTtcbiAgICAgICAgICAgICAgXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFkZGluZ1ggPSA4OyBcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwYWRkaW5nWSA9IDI7IFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGZvbnRTaXplID0gOTtcbiAgICAgICAgICAgICAgXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdGV4dFdpZHRoID0gdGV4dC5sZW5ndGggKiAoZm9udFNpemUgKiAwLjYpOyAvLyBFc3RpbWF0ZSB0aGF0IGVhY2ggY2hhcmFjdGVyIGlzIH42MCUgb2YgdGhlIGZvbnQgc2l6ZVxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlY3RXaWR0aCA9IHRleHRXaWR0aCArIHBhZGRpbmdYOyAvLyBBZGQgcGFkZGluZyBmb3Igd2lkdGhcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZWN0SGVpZ2h0ID0gZm9udFNpemUgKyBwYWRkaW5nWTsgLy8gQWRkIHBhZGRpbmcgZm9yIGhlaWdodFxuICAgICAgICAgICAgICBcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNMUFZhbHVlKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZyB0cmFuc2Zvcm09e2B0cmFuc2xhdGUoJHt4fSwke3l9KWB9PlxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxyZWN0XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4PXstcmVjdFdpZHRoIC8gMn0gXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5PXstcmVjdEhlaWdodCAvIDJ9XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aD17cmVjdFdpZHRofVxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0PXtyZWN0SGVpZ2h0fVxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsbD1cIiM0ZDRkNGRcIlxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcng9ezB9IFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8+XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRleHRcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGw9XCJ3aGl0ZVwiXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb250U2l6ZT17Zm9udFNpemV9XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0QW5jaG9yPVwibWlkZGxlXCJcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGR5PVwiMC4zMmVtXCJcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHg9ezB9IFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID5cbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIExQIHtMcFlWYWx1ZS50b0ZpeGVkKDEpfVxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdGV4dD5cbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9nPlxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGlzTGF0ZXN0VmFsdWUpIHtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxnIHRyYW5zZm9ybT17YHRyYW5zbGF0ZSgke3h9LCR7eX0pYH0+XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHJlY3Rcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHg9ey1yZWN0V2lkdGggLyAyfSBcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHk9ey1yZWN0SGVpZ2h0IC8gMn1cbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoPXtyZWN0V2lkdGh9XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ9e3JlY3RIZWlnaHR9XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxsPVwid2hpdGVcIlxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcng9ezB9IFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8+XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRleHRcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGw9XCJibGFja1wiXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb250V2VpZ2h0PVwiNzAwXCJcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvbnRTaXplPXtmb250U2l6ZX1cbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHRBbmNob3I9XCJtaWRkbGVcIlxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZHk9XCIwLjMyZW1cIlxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeD17MH1cbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA+XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7TGF0ZXN0VmFsdWUudG9GaXhlZCgxKX1cbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3RleHQ+XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZz5cbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZXh0XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsbD1cIiNBNkE2QTZcIlxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvbnRTaXplPXtmb250U2l6ZX1cbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0QW5jaG9yPVwic3RhcnRcIlxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGR5PVwiMC4zMmVtXCJcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4PXstMTB9XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeT17eX1cbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPlxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHt0ZXh0fVxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3RleHQ+XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgfX1cbi8vICAgICAgICAgICAvPlxuLy8gICAgICAgICAgIDxBeGlzQm90dG9tXG4vLyAgICAgICAgICAgICByYW5nZVBhZGRpbmc9ezQxfVxuLy8gICAgICAgICAgICAgdG9wPXtib3VuZGVkSGVpZ2h0fVxuLy8gICAgICAgICAgICAgaGlkZUF4aXNMaW5lPXt0cnVlfVxuLy8gICAgICAgICAgICAgaGlkZVRpY2tzPXt0cnVlfVxuLy8gICAgICAgICAgICAgc2NhbGU9e3hTY2FsZX1cbi8vICAgICAgICAgICAgIHRpY2tGb3JtYXQ9eyhkKSA9PiAoZCBpbnN0YW5jZW9mIERhdGUgPyB0aW1lRm9ybWF0KCclSDolTScpKGQpIDogJycpfVxuLy8gICAgICAgICAgICAgdGlja0xhYmVsUHJvcHM9eygpID0+ICh7XG4vLyAgICAgICAgICAgICAgIGZpbGw6ICd3aGl0ZScsXG4vLyAgICAgICAgICAgICAgIGZvbnRTaXplOiA4LFxuLy8gICAgICAgICAgICAgICB0ZXh0QW5jaG9yOiAnbWlkZGxlJyxcbi8vICAgICAgICAgICAgIH0pfVxuLy8gICAgICAgICAgIC8+XG4vLyAgICAgICAgICAgPHJlY3Rcbi8vICAgICAgICAgICAgIHg9ezB9XG4vLyAgICAgICAgICAgICB5PXswfVxuLy8gICAgICAgICAgICAgd2lkdGg9e2JvdW5kZWRXaWR0aH1cbi8vICAgICAgICAgICAgIGhlaWdodD17Ym91bmRlZEhlaWdodH1cbi8vICAgICAgICAgICAgIGZpbGw9XCJ0cmFuc3BhcmVudFwiXG4vLyAgICAgICAgICAgICBvbk1vdXNlTW92ZT17aGFuZGxlVG9vbHRpcH1cbi8vICAgICAgICAgICAgIG9uTW91c2VMZWF2ZT17KCkgPT4gaGlkZVRvb2x0aXAoKX1cbi8vICAgICAgICAgICAvPlxuLy8gICAgICAgICA8L0dyb3VwPlxuLy8gICAgICAgICB7dG9vbHRpcERhdGEgJiYgKFxuLy8gICAgICAgICAgIDxjaXJjbGVcbi8vICAgICAgICAgICAgIGN4PXt0b29sdGlwTGVmdH1cbi8vICAgICAgICAgICAgIGN5PXt0b29sdGlwVG9wfVxuLy8gICAgICAgICAgICAgcj17NX1cbi8vICAgICAgICAgICAgIHN0cm9rZT1cImJsYWNrXCJcbi8vICAgICAgICAgICAgIGZpbGw9XCIjZmZjYjhmXCJcbi8vICAgICAgICAgICAgIHN0cm9rZVdpZHRoPXsyfVxuLy8gICAgICAgICAgICAgcG9pbnRlckV2ZW50cz1cIm5vbmVcIlxuLy8gICAgICAgICAgIC8+XG4vLyAgICAgICAgICl9XG4vLyAgICAgICA8L3N2Zz5cbi8vICAgICAgIHt0b29sdGlwRGF0YSAmJiAoXG4vLyAgICAgICAgIDxUb29sdGlwV2l0aEJvdW5kc1xuLy8gICAgICAgICAgIHRvcD17dG9vbHRpcFRvcCAtIDEyfVxuLy8gICAgICAgICAgIGxlZnQ9e3Rvb2x0aXBMZWZ0ICsgMTJ9XG4vLyAgICAgICAgICAgc3R5bGU9e3tcbi8vICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJyM0ZDRkNGQnLFxuLy8gICAgICAgICAgICAgY29sb3I6ICd3aGl0ZScsXG4vLyAgICAgICAgICAgICBwYWRkaW5nOiAnMC41cmVtJyxcbi8vICAgICAgICAgICAgIGJvcmRlclJhZGl1czogJzRweCcsXG4vLyAgICAgICAgICAgICBmb250U2l6ZTogJzEwcHgnLFxuLy8gICAgICAgICAgIH19XG4vLyAgICAgICAgID5cbi8vICAgICAgICAgICA8ZGl2PkRhdGU6IHt0aW1lRm9ybWF0KCclYiAlZCwgJVknKSh4QWNjZXNzb3IodG9vbHRpcERhdGEpKX08L2Rpdj5cbi8vICAgICAgICAgICA8ZGl2PlZhbHVlOiB7eUFjY2Vzc29yKHRvb2x0aXBEYXRhKX08L2Rpdj5cbi8vICAgICAgICAgPC9Ub29sdGlwV2l0aEJvdW5kcz5cbi8vICAgICAgICl9XG4vLyAgICAgPC9kaXY+XG4vLyAgICk7XG4vLyB9XG5cbi8vIGV4cG9ydCB7IExpbmVDaGFydCB9O1xuXG5cblxuXG4vLyBpbXBvcnQgUmVhY3QsIHsgdXNlTWVtbyB9IGZyb20gJ3JlYWN0J1xuLy8gaW1wb3J0IHsgZXh0ZW50IH0gZnJvbSAnZDMtYXJyYXknXG4vLyBpbXBvcnQgeyB0aW1lRm9ybWF0IH0gZnJvbSAnZDMtdGltZS1mb3JtYXQnXG4vLyBpbXBvcnQgeyBBeGlzQm90dG9tLCBBeGlzUmlnaHQgfSBmcm9tICdAdmlzeC9heGlzJ1xuLy8gaW1wb3J0IHsgTGluZVBhdGggfSBmcm9tICdAdmlzeC9zaGFwZSdcbi8vIGltcG9ydCB7IEdyb3VwIH0gZnJvbSAnQHZpc3gvZ3JvdXAnXG4vLyBpbXBvcnQgeyBzY2FsZUxpbmVhciwgc2NhbGVUaW1lIH0gZnJvbSAnQHZpc3gvc2NhbGUnXG4vLyBpbXBvcnQgeyBHcmlkUm93cyB9IGZyb20gXCJAdmlzeC9ncmlkXCI7XG4vLyBpbXBvcnQgeyBjdXJ2ZUxpbmVhciB9IGZyb20gJ0B2aXN4L2N1cnZlJ1xuXG4vLyBpbXBvcnQgeyBkYXRhIH0gZnJvbSAnLi4vZGF0YS9saW5lLWNoYXJ0J1xuLy8gaW1wb3J0IHsgZ2V0RGltZW5zaW9ucywgeEFjY2Vzc29yLCB5QWNjZXNzb3IgfSBmcm9tICcjL3V0aWxzL2xpbmUtY2hhcnQnXG5cbi8vIHR5cGUgUHJvcHMgPSB7XG4vLyAgIHdpZHRoOiBudW1iZXJcbi8vICAgaGVpZ2h0OiBudW1iZXJcbi8vIH1cblxuLy8gZnVuY3Rpb24gTGluZUNoYXJ0KHsgd2lkdGgsIGhlaWdodCB9OiBQcm9wcykge1xuLy8gICBjb25zdCB7IG1hcmdpbiwgYm91bmRlZFdpZHRoLCBib3VuZGVkSGVpZ2h0IH0gPSBnZXREaW1lbnNpb25zKHtcbi8vICAgICB3aWR0aCxcbi8vICAgICBoZWlnaHQsXG4vLyAgIH0pXG5cbi8vICAgY29uc3QgTHBZVmFsdWUgPSA1NDMwMC4yOyBcbi8vICAgY29uc3QgTGF0ZXN0VmFsdWUgPSA1OTk4MC45O1xuXG4vLyAgIGNvbnN0IHhTY2FsZSA9IHVzZU1lbW8oXG4vLyAgICAgKCkgPT5cbi8vICAgICAgIHNjYWxlVGltZTxudW1iZXI+KHtcbi8vICAgICAgICAgZG9tYWluOiBleHRlbnQoZGF0YSwgeEFjY2Vzc29yKSBhcyBbRGF0ZSwgRGF0ZV0sXG4vLyAgICAgICAgIHJhbmdlOiBbMCwgYm91bmRlZFdpZHRoXSxcbi8vICAgICAgICAgbmljZTogdHJ1ZSxcbi8vICAgICAgIH0pLFxuLy8gICAgIFtib3VuZGVkV2lkdGhdXG4vLyAgIClcblxuLy8gICBjb25zdCB5U2NhbGUgPSB1c2VNZW1vKFxuLy8gICAgICgpID0+XG4vLyAgICAgICBzY2FsZUxpbmVhcjxudW1iZXI+KHtcbi8vICAgICAgICAgZG9tYWluOiBleHRlbnQoZGF0YSwgeUFjY2Vzc29yKSBhcyBbbnVtYmVyLCBudW1iZXJdLFxuLy8gICAgICAgICByYW5nZTogW2JvdW5kZWRIZWlnaHQsIDBdLFxuLy8gICAgICAgICBuaWNlOiB0cnVlLFxuLy8gICAgICAgfSksXG4vLyAgICAgW2JvdW5kZWRIZWlnaHRdXG4vLyAgIClcblxuLy8gICBjb25zdCBjdXN0b21ZUG9zaXRpb24gPSB5U2NhbGUoTHBZVmFsdWUpOyBcblxuLy8gICAvLyBHZW5lcmF0ZSB5LWF4aXMgdGljayB2YWx1ZXMgYW5kIGVuc3VyZSBib3RoIExwWVZhbHVlIGFuZCBMYXRlc3RWYWx1ZSBhcmUgaW5jbHVkZWRcbi8vICAgY29uc3QgeVRpY2tWYWx1ZXMgPSB5U2NhbGUudGlja3MoOCk7XG5cbi8vICAgaWYgKCF5VGlja1ZhbHVlcy5pbmNsdWRlcyhMcFlWYWx1ZSkpIHtcbi8vICAgICB5VGlja1ZhbHVlcy5wdXNoKExwWVZhbHVlKTtcbi8vICAgfVxuLy8gICBpZiAoIXlUaWNrVmFsdWVzLmluY2x1ZGVzKExhdGVzdFZhbHVlKSkge1xuLy8gICAgIHlUaWNrVmFsdWVzLnB1c2goTGF0ZXN0VmFsdWUpO1xuLy8gICB9XG5cbi8vICAgcmV0dXJuIChcbi8vICAgICA8ZGl2IGNsYXNzTmFtZT1cInctZml0XCI+XG4vLyAgICAgICA8c3ZnXG4vLyAgICAgICAgIGNsYXNzTmFtZT0nJ1xuLy8gICAgICAgICB3aWR0aD17d2lkdGh9XG4vLyAgICAgICAgIGhlaWdodD17aGVpZ2h0fVxuLy8gICAgICAgICByb2xlPVwiZmlndXJlXCJcbi8vICAgICAgID5cbi8vICAgICAgICAgPHJlY3Rcbi8vICAgICAgICAgICAgIHg9ezB9XG4vLyAgICAgICAgICAgICB5PXswfVxuLy8gICAgICAgICAgICAgd2lkdGg9e3dpZHRofVxuLy8gICAgICAgICAgICAgaGVpZ2h0PXtoZWlnaHR9XG4vLyAgICAgICAgIC8+XG4vLyAgICAgICAgIDx0aXRsZT5saW5lIGNoYXJ0IGxvb2tpbmcgYXQgdGhlIGRpc3RyaWJ1dGlvbiBvZiBtYXggdGVtcGVyYXR1cmU8L3RpdGxlPlxuLy8gICAgICAgICA8R3JvdXAgdG9wPXttYXJnaW4udG9wfSBsZWZ0PXttYXJnaW4ubGVmdH0+XG4vLyAgICAgICAgICAgPEdyaWRSb3dzXG4vLyAgICAgICAgICAgICBzY2FsZT17eVNjYWxlfVxuLy8gICAgICAgICAgICAgd2lkdGg9e2JvdW5kZWRXaWR0aH1cbi8vICAgICAgICAgICAgIHN0cm9rZURhc2hhcnJheT1cIjEsM1wiXG4vLyAgICAgICAgICAgICBzdHJva2U9XCIjMjYyNjI2XCJcbi8vICAgICAgICAgICAgIHBvaW50ZXJFdmVudHM9XCJub25lXCJcbi8vICAgICAgICAgICAvPlxuLy8gICAgICAgICAgIDxMaW5lUGF0aFxuLy8gICAgICAgICAgICAgY3VydmU9e2N1cnZlTGluZWFyfVxuLy8gICAgICAgICAgICAgZGF0YT17ZGF0YX1cbi8vICAgICAgICAgICAgIHN0cm9rZT17XCIjRkZDQTQzXCJ9XG4vLyAgICAgICAgICAgICBzdHJva2VXaWR0aD17MS41fVxuLy8gICAgICAgICAgICAgeD17KGQpID0+IHhTY2FsZSh4QWNjZXNzb3IoZCkpID8/IDB9XG4vLyAgICAgICAgICAgICB5PXsoZCkgPT4geVNjYWxlKHlBY2Nlc3NvcihkKSkgPz8gMH1cbi8vICAgICAgICAgICAvPlxuXG4vLyAgICAgICAgICAge2N1c3RvbVlQb3NpdGlvbiAmJiAoXG4vLyAgICAgICAgICAgICA8bGluZVxuLy8gICAgICAgICAgICAgICB4MT17MH1cbi8vICAgICAgICAgICAgICAgeDI9e2JvdW5kZWRXaWR0aH1cbi8vICAgICAgICAgICAgICAgeTE9e2N1c3RvbVlQb3NpdGlvbn1cbi8vICAgICAgICAgICAgICAgeTI9e2N1c3RvbVlQb3NpdGlvbn1cbi8vICAgICAgICAgICAgICAgc3Ryb2tlPVwid2hpdGVcIlxuLy8gICAgICAgICAgICAgICBzdHJva2VXaWR0aD17MX1cbi8vICAgICAgICAgICAgICAgc3Ryb2tlRGFzaGFycmF5PVwiMyw1XCIgXG4vLyAgICAgICAgICAgICAvPlxuLy8gICAgICAgICAgICl9XG5cbi8vICAgICAgICAgICA8QXhpc1JpZ2h0XG4vLyAgICAgICAgICAgICBsZWZ0PXtib3VuZGVkV2lkdGggKyBtYXJnaW4ucmlnaHQgLSA0MH1cbi8vICAgICAgICAgICAgIHNjYWxlPXt5U2NhbGV9XG4vLyAgICAgICAgICAgICB0b3A9ezB9XG4vLyAgICAgICAgICAgICBoaWRlQXhpc0xpbmU9e3RydWV9XG4vLyAgICAgICAgICAgICBoaWRlVGlja3M9e3RydWV9XG4vLyAgICAgICAgICAgICBsYWJlbE9mZnNldD17MH1cbi8vICAgICAgICAgICAgIHRpY2tWYWx1ZXM9e3lUaWNrVmFsdWVzfVxuLy8gICAgICAgICAgICAgdGlja0Zvcm1hdD17KHZhbHVlKSA9PiBgJHtOdW1iZXIodmFsdWUpLnRvRml4ZWQoMSl9YH0gXG4vLyAgICAgICAgICAgICB0aWNrTGFiZWxQcm9wcz17KCkgPT4gKHtcbi8vICAgICAgICAgICAgICAgZmlsbDogJyNBNkE2QTYnLFxuLy8gICAgICAgICAgICAgICBmb250U2l6ZTogOSxcbi8vICAgICAgICAgICAgICAgdGV4dEFuY2hvcjogJ3N0YXJ0Jyxcbi8vICAgICAgICAgICAgIH0pfVxuLy8gICAgICAgICAgICAgdGlja0NvbXBvbmVudD17KHsgZm9ybWF0dGVkVmFsdWUsIHgsIHkgfSkgPT4ge1xuLy8gICAgICAgICAgICAgICBpZiAoZm9ybWF0dGVkVmFsdWUgPT09IHVuZGVmaW5lZCkge1xuLy8gICAgICAgICAgICAgICAgIHJldHVybiBudWxsOyBcbi8vICAgICAgICAgICAgICAgfVxuXG4vLyAgICAgICAgICAgICAgIGNvbnN0IG51bUZvcm1hdHRlZFZhbHVlID0gTnVtYmVyKGZvcm1hdHRlZFZhbHVlKTsgXG4vLyAgICAgICAgICAgICAgIGNvbnN0IGlzTFBWYWx1ZSA9IG51bUZvcm1hdHRlZFZhbHVlID09PSBMcFlWYWx1ZTtcbi8vICAgICAgICAgICAgICAgY29uc3QgaXNMYXRlc3RWYWx1ZSA9IG51bUZvcm1hdHRlZFZhbHVlID09PSBMYXRlc3RWYWx1ZTtcblxuLy8gICAgICAgICAgICAgICBjb25zdCB0ZXh0ID0gaXNMUFZhbHVlXG4vLyAgICAgICAgICAgICAgICAgPyBgTFAgJHtMcFlWYWx1ZS50b0ZpeGVkKDEpfWBcbi8vICAgICAgICAgICAgICAgICA6IGlzTGF0ZXN0VmFsdWVcbi8vICAgICAgICAgICAgICAgICA/IGAke0xhdGVzdFZhbHVlLnRvRml4ZWQoMSl9YFxuLy8gICAgICAgICAgICAgICAgIDogZm9ybWF0dGVkVmFsdWU7XG5cbi8vICAgICAgICAgICAgICAgY29uc3QgcGFkZGluZ1ggPSA4OyBcbi8vICAgICAgICAgICAgICAgY29uc3QgcGFkZGluZ1kgPSAyOyBcbi8vICAgICAgICAgICAgICAgY29uc3QgZm9udFNpemUgPSA5O1xuXG4vLyAgICAgICAgICAgICAgIGNvbnN0IHRleHRXaWR0aCA9IHRleHQubGVuZ3RoICogKGZvbnRTaXplICogMC42KTsgLy8gRXN0aW1hdGUgdGhhdCBlYWNoIGNoYXJhY3RlciBpcyB+NjAlIG9mIHRoZSBmb250IHNpemVcbi8vICAgICAgICAgICAgICAgY29uc3QgcmVjdFdpZHRoID0gdGV4dFdpZHRoICsgcGFkZGluZ1g7IC8vIEFkZCBwYWRkaW5nIGZvciB3aWR0aFxuLy8gICAgICAgICAgICAgICBjb25zdCByZWN0SGVpZ2h0ID0gZm9udFNpemUgKyBwYWRkaW5nWTsgLy8gQWRkIHBhZGRpbmcgZm9yIGhlaWdodFxuXG4vLyAgICAgICAgICAgICAgIGlmIChpc0xQVmFsdWUpIHtcbi8vICAgICAgICAgICAgICAgICByZXR1cm4gKFxuLy8gICAgICAgICAgICAgICAgICAgPGcgdHJhbnNmb3JtPXtgdHJhbnNsYXRlKCR7eH0sJHt5fSlgfT5cbi8vICAgICAgICAgICAgICAgICAgICAgPHJlY3Rcbi8vICAgICAgICAgICAgICAgICAgICAgICB4PXstcmVjdFdpZHRoIC8gMn0gXG4vLyAgICAgICAgICAgICAgICAgICAgICAgeT17LXJlY3RIZWlnaHQgLyAyfVxuLy8gICAgICAgICAgICAgICAgICAgICAgIHdpZHRoPXtyZWN0V2lkdGh9XG4vLyAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0PXtyZWN0SGVpZ2h0fVxuLy8gICAgICAgICAgICAgICAgICAgICAgIGZpbGw9XCIjNGQ0ZDRkXCJcbi8vICAgICAgICAgICAgICAgICAgICAgICByeD17MH0gXG4vLyAgICAgICAgICAgICAgICAgICAgIC8+XG4vLyAgICAgICAgICAgICAgICAgICAgIDx0ZXh0XG4vLyAgICAgICAgICAgICAgICAgICAgICAgZmlsbD1cIndoaXRlXCJcbi8vICAgICAgICAgICAgICAgICAgICAgICBmb250U2l6ZT17Zm9udFNpemV9XG4vLyAgICAgICAgICAgICAgICAgICAgICAgdGV4dEFuY2hvcj1cIm1pZGRsZVwiXG4vLyAgICAgICAgICAgICAgICAgICAgICAgZHk9XCIwLjMyZW1cIlxuLy8gICAgICAgICAgICAgICAgICAgICAgIHg9ezB9IFxuLy8gICAgICAgICAgICAgICAgICAgICA+XG4vLyAgICAgICAgICAgICAgICAgICAgICAgTFAge0xwWVZhbHVlLnRvRml4ZWQoMSl9XG4vLyAgICAgICAgICAgICAgICAgICAgIDwvdGV4dD5cbi8vICAgICAgICAgICAgICAgICAgIDwvZz5cbi8vICAgICAgICAgICAgICAgICApO1xuLy8gICAgICAgICAgICAgICB9IGVsc2UgaWYgKGlzTGF0ZXN0VmFsdWUpIHtcbi8vICAgICAgICAgICAgICAgICByZXR1cm4gKFxuLy8gICAgICAgICAgICAgICAgICAgPGcgdHJhbnNmb3JtPXtgdHJhbnNsYXRlKCR7eH0sJHt5fSlgfT5cbi8vICAgICAgICAgICAgICAgICAgICAgPHJlY3Rcbi8vICAgICAgICAgICAgICAgICAgICAgICB4PXstcmVjdFdpZHRoIC8gMn0gXG4vLyAgICAgICAgICAgICAgICAgICAgICAgeT17LXJlY3RIZWlnaHQgLyAyfVxuLy8gICAgICAgICAgICAgICAgICAgICAgIHdpZHRoPXtyZWN0V2lkdGh9XG4vLyAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0PXtyZWN0SGVpZ2h0fVxuLy8gICAgICAgICAgICAgICAgICAgICAgIGZpbGw9XCJ3aGl0ZVwiXG4vLyAgICAgICAgICAgICAgICAgICAgICAgcng9ezB9IFxuLy8gICAgICAgICAgICAgICAgICAgICAvPlxuLy8gICAgICAgICAgICAgICAgICAgICA8dGV4dFxuLy8gICAgICAgICAgICAgICAgICAgICAgIGZpbGw9XCJibGFja1wiXG4vLyAgICAgICAgICAgICAgICAgICAgICAgZm9udFdlaWdodD1cIjcwMFwiXG4vLyAgICAgICAgICAgICAgICAgICAgICAgZm9udFNpemU9e2ZvbnRTaXplfVxuLy8gICAgICAgICAgICAgICAgICAgICAgIHRleHRBbmNob3I9XCJtaWRkbGVcIlxuLy8gICAgICAgICAgICAgICAgICAgICAgIGR5PVwiMC4zMmVtXCJcbi8vICAgICAgICAgICAgICAgICAgICAgICB4PXswfVxuLy8gICAgICAgICAgICAgICAgICAgICA+XG4vLyAgICAgICAgICAgICAgICAgICAgICAge0xhdGVzdFZhbHVlLnRvRml4ZWQoMSl9XG4vLyAgICAgICAgICAgICAgICAgICAgIDwvdGV4dD5cbi8vICAgICAgICAgICAgICAgICAgIDwvZz5cbi8vICAgICAgICAgICAgICAgICApO1xuLy8gICAgICAgICAgICAgICB9IGVsc2Uge1xuLy8gICAgICAgICAgICAgICAgIHJldHVybiAoXG4vLyAgICAgICAgICAgICAgICAgICA8dGV4dFxuLy8gICAgICAgICAgICAgICAgICAgICBmaWxsPVwiI0E2QTZBNlwiXG4vLyAgICAgICAgICAgICAgICAgICAgIGZvbnRTaXplPXtmb250U2l6ZX1cbi8vICAgICAgICAgICAgICAgICAgICAgdGV4dEFuY2hvcj1cInN0YXJ0XCJcbi8vICAgICAgICAgICAgICAgICAgICAgZHk9XCIwLjMyZW1cIlxuLy8gICAgICAgICAgICAgICAgICAgICB4PXstMTB9XG4vLyAgICAgICAgICAgICAgICAgICAgIHk9e3l9XG4vLyAgICAgICAgICAgICAgICAgICA+XG4vLyAgICAgICAgICAgICAgICAgICAgIHt0ZXh0fVxuLy8gICAgICAgICAgICAgICAgICAgPC90ZXh0PlxuLy8gICAgICAgICAgICAgICAgICk7XG4vLyAgICAgICAgICAgICAgIH1cbi8vICAgICAgICAgICAgIH19XG4vLyAgICAgICAgICAgLz5cbi8vICAgICAgICAgICA8QXhpc0JvdHRvbVxuLy8gICAgICAgICAgICAgcmFuZ2VQYWRkaW5nPXs0MX1cbi8vICAgICAgICAgICAgIHRvcD17Ym91bmRlZEhlaWdodH1cbi8vICAgICAgICAgICAgIGhpZGVBeGlzTGluZT17dHJ1ZX1cbi8vICAgICAgICAgICAgIGhpZGVUaWNrcz17dHJ1ZX1cbi8vICAgICAgICAgICAgIHNjYWxlPXt4U2NhbGV9XG4vLyAgICAgICAgICAgICB0aWNrRm9ybWF0PXsoZCkgPT4ge1xuLy8gICAgICAgICAgICAgICByZXR1cm4gZCBpbnN0YW5jZW9mIERhdGUgPyB0aW1lRm9ybWF0KCclSDolTScpKGQpIDogJyc7XG4vLyAgICAgICAgICAgICB9fVxuLy8gICAgICAgICAgICAgdGlja0xhYmVsUHJvcHM9eygpID0+ICh7XG4vLyAgICAgICAgICAgICAgIGZpbGw6ICd3aGl0ZScsXG4vLyAgICAgICAgICAgICAgIGZvbnRTaXplOiA4LFxuLy8gICAgICAgICAgICAgICB0ZXh0QW5jaG9yOiAnbWlkZGxlJyxcbi8vICAgICAgICAgICAgIH0pfVxuLy8gICAgICAgICAgIC8+XG4vLyAgICAgICAgIDwvR3JvdXA+XG4vLyAgICAgICA8L3N2Zz5cbi8vICAgICA8L2Rpdj5cbi8vICAgKVxuLy8gfVxuXG4vLyBleHBvcnQgeyBMaW5lQ2hhcnQgfVxuXG5cbi8vICd1c2UgY2xpZW50J1xuXG4vLyBpbXBvcnQgUmVhY3QsIHsgdXNlTWVtbywgdXNlQ2FsbGJhY2sgfSBmcm9tICdyZWFjdCc7XG4vLyBpbXBvcnQgeyBleHRlbnQsIGJpc2VjdG9yLCBtYXgsIG1pbiB9IGZyb20gJ2QzLWFycmF5Jztcbi8vIGltcG9ydCB7IHRpbWVGb3JtYXQgfSBmcm9tICdkMy10aW1lLWZvcm1hdCc7XG4vLyBpbXBvcnQgeyBBeGlzQm90dG9tLCBBeGlzUmlnaHQgfSBmcm9tICdAdmlzeC9heGlzJztcbi8vIGltcG9ydCB7IExpbmVQYXRoIH0gZnJvbSAnQHZpc3gvc2hhcGUnO1xuLy8gaW1wb3J0IHsgR3JvdXAgfSBmcm9tICdAdmlzeC9ncm91cCc7XG4vLyBpbXBvcnQgeyBzY2FsZUxpbmVhciwgc2NhbGVUaW1lIH0gZnJvbSAnQHZpc3gvc2NhbGUnO1xuLy8gaW1wb3J0IHsgR3JpZFJvd3MgfSBmcm9tICdAdmlzeC9ncmlkJztcbi8vIGltcG9ydCB7IGN1cnZlTGluZWFyIH0gZnJvbSAnQHZpc3gvY3VydmUnO1xuLy8gaW1wb3J0IHsgdXNlVG9vbHRpcCwgVG9vbHRpcFdpdGhCb3VuZHMgfSBmcm9tICdAdmlzeC90b29sdGlwJztcbi8vIGltcG9ydCB7IGxvY2FsUG9pbnQgfSBmcm9tICdAdmlzeC9ldmVudCc7XG5cbi8vIGltcG9ydCB7IGRhdGEgfSBmcm9tICcuLi9kYXRhL2xpbmUtY2hhcnQnO1xuLy8gaW1wb3J0IHsgZ2V0RGltZW5zaW9ucywgeEFjY2Vzc29yLCB5QWNjZXNzb3IgfSBmcm9tICcjL3V0aWxzL2xpbmUtY2hhcnQnO1xuXG4vLyB0eXBlIFByb3BzID0ge1xuLy8gICB3aWR0aDogbnVtYmVyO1xuLy8gICBoZWlnaHQ6IG51bWJlcjtcbi8vIH07XG5cbi8vIGZ1bmN0aW9uIExpbmVDaGFydCh7IHdpZHRoLCBoZWlnaHQgfTogUHJvcHMpIHtcbi8vICAgY29uc3QgeyBtYXJnaW4sIGJvdW5kZWRXaWR0aCwgYm91bmRlZEhlaWdodCB9ID0gZ2V0RGltZW5zaW9ucyh7XG4vLyAgICAgd2lkdGgsXG4vLyAgICAgaGVpZ2h0LFxuLy8gICB9KTtcblxuLy8gICBjb25zdCBMcFlWYWx1ZSA9IDU0MzAwLjI7XG4vLyAgIGNvbnN0IExhdGVzdFZhbHVlID0gNTk5ODAuOTtcblxuLy8gICBjb25zdCB4U2NhbGUgPSB1c2VNZW1vKFxuLy8gICAgICgpID0+XG4vLyAgICAgICBzY2FsZVRpbWU8bnVtYmVyPih7XG4vLyAgICAgICAgIGRvbWFpbjogZXh0ZW50KGRhdGEsIHhBY2Nlc3NvcikgYXMgW0RhdGUsIERhdGVdLFxuLy8gICAgICAgICByYW5nZTogWzAsIGJvdW5kZWRXaWR0aF0sXG4vLyAgICAgICAgIG5pY2U6IHRydWUsXG4vLyAgICAgICB9KSxcbi8vICAgICBbYm91bmRlZFdpZHRoXVxuLy8gICApO1xuXG4vLyAgIGNvbnN0IHlTY2FsZSA9IHVzZU1lbW8oXG4vLyAgICAgKCkgPT5cbi8vICAgICAgIHNjYWxlTGluZWFyPG51bWJlcj4oe1xuLy8gICAgICAgICBkb21haW46IGV4dGVudChkYXRhLCB5QWNjZXNzb3IpIGFzIFtudW1iZXIsIG51bWJlcl0sXG4vLyAgICAgICAgIHJhbmdlOiBbYm91bmRlZEhlaWdodCwgMF0sXG4vLyAgICAgICAgIG5pY2U6IHRydWUsXG4vLyAgICAgICB9KSxcbi8vICAgICBbYm91bmRlZEhlaWdodF1cbi8vICAgKTtcblxuLy8gICBjb25zdCB7IHNob3dUb29sdGlwLCBoaWRlVG9vbHRpcCwgdG9vbHRpcERhdGEsIHRvb2x0aXBMZWZ0LCB0b29sdGlwVG9wIH0gPSB1c2VUb29sdGlwKCk7XG5cbi8vICAgY29uc3QgaGFuZGxlVG9vbHRpcCA9IHVzZUNhbGxiYWNrKFxuLy8gICAgIChldmVudDogUmVhY3QuTW91c2VFdmVudCkgPT4ge1xuLy8gICAgICAgY29uc3QgeyB4IH0gPSBsb2NhbFBvaW50KGV2ZW50KSB8fCB7IHg6IDAgfTtcbi8vICAgICAgIGNvbnN0IHgwID0geFNjYWxlLmludmVydCh4ICk7IC8vIENvcnJlY3RseSBoYW5kbGUgbWFyZ2luIG9mZnNldFxuICBcbi8vICAgICAgIGNvbnN0IGJpc2VjdERhdGUgPSBiaXNlY3Rvcih4QWNjZXNzb3IpLmxlZnQ7XG4vLyAgICAgICBjb25zdCBpbmRleCA9IGJpc2VjdERhdGUoZGF0YSwgeDAsIDEpO1xuLy8gICAgICAgY29uc3QgZDAgPSBkYXRhW2luZGV4IC0gMV07XG4vLyAgICAgICBjb25zdCBkMSA9IGRhdGFbaW5kZXhdO1xuXG4vLyAgICAgICBsZXQgZCA9IGQwO1xuLy8gICAgICAgaWYgKGQxICYmIHhBY2Nlc3NvcihkMSkpIHtcbi8vICAgICAgICAgZCA9IHgwIC0geEFjY2Vzc29yKGQwKSA+IHhBY2Nlc3NvcihkMSkgLSB4MCA/IGQxIDogZDA7XG4vLyAgICAgICB9XG4gIFxuLy8gICAgICAgc2hvd1Rvb2x0aXAoe1xuLy8gICAgICAgICB0b29sdGlwRGF0YTogZCxcbi8vICAgICAgICAgdG9vbHRpcExlZnQ6IHhTY2FsZSh4QWNjZXNzb3IoZCkpLFxuLy8gICAgICAgICB0b29sdGlwVG9wOiB5U2NhbGUoeUFjY2Vzc29yKGQpKSxcbi8vICAgICAgIH0pO1xuLy8gICAgIH0sXG4vLyAgICAgW3hTY2FsZSwgeVNjYWxlLCBzaG93VG9vbHRpcF1cbi8vICAgKTtcbiAgXG4gIFxuXG4vLyAgIGNvbnN0IGN1c3RvbVlQb3NpdGlvbiA9IHlTY2FsZShMcFlWYWx1ZSk7XG5cbi8vICAgY29uc3QgeVRpY2tWYWx1ZXMgPSB5U2NhbGUudGlja3MoOCk7XG4vLyAgIGlmICgheVRpY2tWYWx1ZXMuaW5jbHVkZXMoTHBZVmFsdWUpKSB5VGlja1ZhbHVlcy5wdXNoKExwWVZhbHVlKTtcbi8vICAgaWYgKCF5VGlja1ZhbHVlcy5pbmNsdWRlcyhMYXRlc3RWYWx1ZSkpIHlUaWNrVmFsdWVzLnB1c2goTGF0ZXN0VmFsdWUpO1xuXG4vLyAgIHJldHVybiAoXG4vLyAgICAgPGRpdiBjbGFzc05hbWU9XCJ3LWZpdFwiPlxuLy8gICAgICAgPHN2ZyBjbGFzc05hbWU9XCJcIiB3aWR0aD17d2lkdGh9IGhlaWdodD17aGVpZ2h0fSByb2xlPVwiZmlndXJlXCI+XG4vLyAgICAgICAgIDxyZWN0IHg9ezB9IHk9ezB9IHdpZHRoPXt3aWR0aH0gaGVpZ2h0PXtoZWlnaHR9IC8+XG4vLyAgICAgICAgIDxHcm91cCB0b3A9e21hcmdpbi50b3B9IGxlZnQ9e21hcmdpbi5sZWZ0fT5cbi8vICAgICAgICAgICA8R3JpZFJvd3Ncbi8vICAgICAgICAgICAgIHNjYWxlPXt5U2NhbGV9XG4vLyAgICAgICAgICAgICB3aWR0aD17Ym91bmRlZFdpZHRofVxuLy8gICAgICAgICAgICAgc3Ryb2tlRGFzaGFycmF5PVwiMSwzXCJcbi8vICAgICAgICAgICAgIHN0cm9rZT1cIiMyNjI2MjZcIlxuLy8gICAgICAgICAgICAgcG9pbnRlckV2ZW50cz1cIm5vbmVcIlxuLy8gICAgICAgICAgIC8+XG4vLyAgICAgICAgICAgPExpbmVQYXRoXG4vLyAgICAgICAgICAgICBjdXJ2ZT17Y3VydmVMaW5lYXJ9XG4vLyAgICAgICAgICAgICBkYXRhPXtkYXRhfVxuLy8gICAgICAgICAgICAgc3Ryb2tlPXsnI0ZGQ0E0Myd9XG4vLyAgICAgICAgICAgICBzdHJva2VXaWR0aD17MS41fVxuLy8gICAgICAgICAgICAgeD17KGQpID0+IHhTY2FsZSh4QWNjZXNzb3IoZCkpID8/IDB9XG4vLyAgICAgICAgICAgICB5PXsoZCkgPT4geVNjYWxlKHlBY2Nlc3NvcihkKSkgPz8gMH1cbi8vICAgICAgICAgICAvPlxuXG4vLyAgICAgICAgICAge2N1c3RvbVlQb3NpdGlvbiAmJiAoXG4vLyAgICAgICAgICAgICA8bGluZVxuLy8gICAgICAgICAgICAgICB4MT17MH1cbi8vICAgICAgICAgICAgICAgeDI9e2JvdW5kZWRXaWR0aH1cbi8vICAgICAgICAgICAgICAgeTE9e2N1c3RvbVlQb3NpdGlvbn1cbi8vICAgICAgICAgICAgICAgeTI9e2N1c3RvbVlQb3NpdGlvbn1cbi8vICAgICAgICAgICAgICAgc3Ryb2tlPVwid2hpdGVcIlxuLy8gICAgICAgICAgICAgICBzdHJva2VXaWR0aD17MX1cbi8vICAgICAgICAgICAgICAgc3Ryb2tlRGFzaGFycmF5PVwiMyw1XCJcbi8vICAgICAgICAgICAgIC8+XG4vLyAgICAgICAgICAgKX1cblxuLy8gICAgICAgICAgIDxBeGlzUmlnaHRcbi8vICAgICAgICAgICAgIGxlZnQ9e2JvdW5kZWRXaWR0aCArIG1hcmdpbi5yaWdodCAtIDQwfVxuLy8gICAgICAgICAgICAgc2NhbGU9e3lTY2FsZX1cbi8vICAgICAgICAgICAgIHRvcD17MH1cbi8vICAgICAgICAgICAgIGhpZGVBeGlzTGluZT17dHJ1ZX1cbi8vICAgICAgICAgICAgIGhpZGVUaWNrcz17dHJ1ZX1cbi8vICAgICAgICAgICAgIHRpY2tWYWx1ZXM9e3lUaWNrVmFsdWVzfVxuLy8gICAgICAgICAgICAgdGlja0Zvcm1hdD17KHZhbHVlKSA9PiBgJHtOdW1iZXIodmFsdWUpLnRvRml4ZWQoMSl9YH1cbi8vICAgICAgICAgICAgIHRpY2tMYWJlbFByb3BzPXsoKSA9PiAoe1xuLy8gICAgICAgICAgICAgICBmaWxsOiAnI0E2QTZBNicsXG4vLyAgICAgICAgICAgICAgIGZvbnRTaXplOiA5LFxuLy8gICAgICAgICAgICAgICB0ZXh0QW5jaG9yOiAnc3RhcnQnLFxuLy8gICAgICAgICAgICAgfSl9XG4vLyAgICAgICAgICAgICB0aWNrQ29tcG9uZW50PXsoe1xuLy8gICAgICAgICAgICAgICBmb3JtYXR0ZWRWYWx1ZSwgeCwgeSB9KSA9PiB7XG4vLyAgICAgICAgICAgICAgICAgaWYgKGZvcm1hdHRlZFZhbHVlID09PSB1bmRlZmluZWQpIHtcbi8vICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsOyBcbi8vICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIFxuLy8gICAgICAgICAgICAgICAgIGNvbnN0IG51bUZvcm1hdHRlZFZhbHVlID0gTnVtYmVyKGZvcm1hdHRlZFZhbHVlKTsgXG4vLyAgICAgICAgICAgICAgICAgY29uc3QgaXNMUFZhbHVlID0gbnVtRm9ybWF0dGVkVmFsdWUgPT09IExwWVZhbHVlO1xuLy8gICAgICAgICAgICAgICAgIGNvbnN0IGlzTGF0ZXN0VmFsdWUgPSBudW1Gb3JtYXR0ZWRWYWx1ZSA9PT0gTGF0ZXN0VmFsdWU7XG4gICAgICAgICAgICAgIFxuLy8gICAgICAgICAgICAgICAgIGNvbnN0IHRleHQgPSBpc0xQVmFsdWVcbi8vICAgICAgICAgICAgICAgICAgID8gYExQICR7THBZVmFsdWUudG9GaXhlZCgxKX1gXG4vLyAgICAgICAgICAgICAgICAgICA6IGlzTGF0ZXN0VmFsdWVcbi8vICAgICAgICAgICAgICAgICAgID8gYCR7TGF0ZXN0VmFsdWUudG9GaXhlZCgxKX1gXG4vLyAgICAgICAgICAgICAgICAgICA6IGZvcm1hdHRlZFZhbHVlO1xuICBcbi8vICAgICAgICAgICAgICAgICBjb25zdCBwYWRkaW5nWCA9IDg7IFxuLy8gICAgICAgICAgICAgICAgIGNvbnN0IHBhZGRpbmdZID0gMjsgXG4vLyAgICAgICAgICAgICAgICAgY29uc3QgZm9udFNpemUgPSA5O1xuICAgICAgICAgICAgICBcbi8vICAgICAgICAgICAgICAgICBjb25zdCB0ZXh0V2lkdGggPSB0ZXh0Lmxlbmd0aCAqIChmb250U2l6ZSAqIDAuNik7IC8vIEVzdGltYXRlIHRoYXQgZWFjaCBjaGFyYWN0ZXIgaXMgfjYwJSBvZiB0aGUgZm9udCBzaXplXG4vLyAgICAgICAgICAgICAgICAgY29uc3QgcmVjdFdpZHRoID0gdGV4dFdpZHRoICsgcGFkZGluZ1g7IC8vIEFkZCBwYWRkaW5nIGZvciB3aWR0aFxuLy8gICAgICAgICAgICAgICAgIGNvbnN0IHJlY3RIZWlnaHQgPSBmb250U2l6ZSArIHBhZGRpbmdZOyAvLyBBZGQgcGFkZGluZyBmb3IgaGVpZ2h0XG4gICAgXG4vLyAgICAgICAgICAgICAgICAgaWYgKGlzTFBWYWx1ZSkge1xuLy8gICAgICAgICAgICAgICAgICAgcmV0dXJuIChcbi8vICAgICAgICAgICAgICAgICAgICAgPGcgdHJhbnNmb3JtPXtgdHJhbnNsYXRlKCR7eH0sJHt5fSlgfT5cbi8vICAgICAgICAgICAgICAgICAgICAgICA8cmVjdFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgeD17LXJlY3RXaWR0aCAvIDJ9IFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgeT17LXJlY3RIZWlnaHQgLyAyfVxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg9e3JlY3RXaWR0aH1cbi8vICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodD17cmVjdEhlaWdodH1cbi8vICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGw9XCIjNGQ0ZDRkXCJcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIHJ4PXswfSBcbi8vICAgICAgICAgICAgICAgICAgICAgICAvPlxuLy8gICAgICAgICAgICAgICAgICAgICAgIDx0ZXh0XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBmaWxsPVwid2hpdGVcIlxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgZm9udFNpemU9e2ZvbnRTaXplfVxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgdGV4dEFuY2hvcj1cIm1pZGRsZVwiXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBkeT1cIjAuMzJlbVwiXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICB4PXswfSBcbi8vICAgICAgICAgICAgICAgICAgICAgICA+XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBMUCB7THBZVmFsdWUudG9GaXhlZCgxKX1cbi8vICAgICAgICAgICAgICAgICAgICAgICA8L3RleHQ+XG4vLyAgICAgICAgICAgICAgICAgICAgIDwvZz5cbi8vICAgICAgICAgICAgICAgICAgICk7XG4vLyAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpc0xhdGVzdFZhbHVlKSB7XG4vLyAgICAgICAgICAgICAgICAgICByZXR1cm4gKFxuLy8gICAgICAgICAgICAgICAgICAgICA8ZyB0cmFuc2Zvcm09e2B0cmFuc2xhdGUoJHt4fSwke3l9KWB9PlxuLy8gICAgICAgICAgICAgICAgICAgICAgIDxyZWN0XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICB4PXstcmVjdFdpZHRoIC8gMn0gXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICB5PXstcmVjdEhlaWdodCAvIDJ9XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aD17cmVjdFdpZHRofVxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0PXtyZWN0SGVpZ2h0fVxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgZmlsbD1cIndoaXRlXCJcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIHJ4PXswfSBcbi8vICAgICAgICAgICAgICAgICAgICAgICAvPlxuLy8gICAgICAgICAgICAgICAgICAgICAgIDx0ZXh0XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBmaWxsPVwiYmxhY2tcIlxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgZm9udFdlaWdodD1cIjcwMFwiXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBmb250U2l6ZT17Zm9udFNpemV9XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0QW5jaG9yPVwibWlkZGxlXCJcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIGR5PVwiMC4zMmVtXCJcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIHg9ezB9XG4vLyAgICAgICAgICAgICAgICAgICAgICAgPlxuLy8gICAgICAgICAgICAgICAgICAgICAgICAge0xhdGVzdFZhbHVlLnRvRml4ZWQoMSl9XG4vLyAgICAgICAgICAgICAgICAgICAgICAgPC90ZXh0PlxuLy8gICAgICAgICAgICAgICAgICAgICA8L2c+XG4vLyAgICAgICAgICAgICAgICAgICApO1xuLy8gICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4vLyAgICAgICAgICAgICAgICAgICByZXR1cm4gKFxuLy8gICAgICAgICAgICAgICAgICAgICA8dGV4dFxuLy8gICAgICAgICAgICAgICAgICAgICAgIGZpbGw9XCIjQTZBNkE2XCJcbi8vICAgICAgICAgICAgICAgICAgICAgICBmb250U2l6ZT17Zm9udFNpemV9XG4vLyAgICAgICAgICAgICAgICAgICAgICAgdGV4dEFuY2hvcj1cInN0YXJ0XCJcbi8vICAgICAgICAgICAgICAgICAgICAgICBkeT1cIjAuMzJlbVwiXG4vLyAgICAgICAgICAgICAgICAgICAgICAgeD17LTEwfVxuLy8gICAgICAgICAgICAgICAgICAgICAgIHk9e3l9XG4vLyAgICAgICAgICAgICAgICAgICAgID5cbi8vICAgICAgICAgICAgICAgICAgICAgICB7dGV4dH1cbi8vICAgICAgICAgICAgICAgICAgICAgPC90ZXh0PlxuLy8gICAgICAgICAgICAgICAgICAgKTtcbi8vICAgICAgICAgICAgICAgICB9XG4vLyAgICAgICAgICAgICB9fVxuLy8gICAgICAgICAgIC8+XG4vLyAgICAgICAgICAgPEF4aXNCb3R0b21cbi8vICAgICAgICAgICAgIHJhbmdlUGFkZGluZz17NDF9XG4vLyAgICAgICAgICAgICB0b3A9e2JvdW5kZWRIZWlnaHR9XG4vLyAgICAgICAgICAgICBoaWRlQXhpc0xpbmU9e3RydWV9XG4vLyAgICAgICAgICAgICBoaWRlVGlja3M9e3RydWV9XG4vLyAgICAgICAgICAgICBzY2FsZT17eFNjYWxlfVxuLy8gICAgICAgICAgICAgdGlja0Zvcm1hdD17KGQpID0+IChkIGluc3RhbmNlb2YgRGF0ZSA/IHRpbWVGb3JtYXQoJyVIOiVNJykoZCkgOiAnJyl9XG4vLyAgICAgICAgICAgICB0aWNrTGFiZWxQcm9wcz17KCkgPT4gKHtcbi8vICAgICAgICAgICAgICAgZmlsbDogJ3doaXRlJyxcbi8vICAgICAgICAgICAgICAgZm9udFNpemU6IDgsXG4vLyAgICAgICAgICAgICAgIHRleHRBbmNob3I6ICdtaWRkbGUnLFxuLy8gICAgICAgICAgICAgfSl9XG4vLyAgICAgICAgICAgLz5cbi8vICAgICAgICAgICA8cmVjdFxuLy8gICAgICAgICAgICAgeD17MH1cbi8vICAgICAgICAgICAgIHk9ezB9XG4vLyAgICAgICAgICAgICB3aWR0aD17Ym91bmRlZFdpZHRofVxuLy8gICAgICAgICAgICAgaGVpZ2h0PXtib3VuZGVkSGVpZ2h0fVxuLy8gICAgICAgICAgICAgZmlsbD1cInRyYW5zcGFyZW50XCJcbi8vICAgICAgICAgICAgIG9uTW91c2VNb3ZlPXtoYW5kbGVUb29sdGlwfVxuLy8gICAgICAgICAgICAgb25Nb3VzZUxlYXZlPXsoKSA9PiBoaWRlVG9vbHRpcCgpfVxuLy8gICAgICAgICAgIC8+XG4vLyAgICAgICAgIDwvR3JvdXA+XG4vLyAgICAgICAgIHt0b29sdGlwRGF0YSAmJiAoXG4vLyAgICAgICAgICAgPGNpcmNsZVxuLy8gICAgICAgICAgICAgY3g9e3Rvb2x0aXBMZWZ0ICsgMTR9XG4vLyAgICAgICAgICAgICBjeT17dG9vbHRpcFRvcCArIDEyIH1cbi8vICAgICAgICAgICAgIHI9ezV9XG4vLyAgICAgICAgICAgICBzdHJva2U9XCJibGFja1wiXG4vLyAgICAgICAgICAgICBmaWxsPVwiI2ZmY2I4ZlwiXG4vLyAgICAgICAgICAgICBzdHJva2VXaWR0aD17Mn1cbi8vICAgICAgICAgICAgIHBvaW50ZXJFdmVudHM9XCJub25lXCJcbi8vICAgICAgICAgICAvPlxuLy8gICAgICAgICApfVxuLy8gICAgICAgPC9zdmc+XG4vLyAgICAgICB7dG9vbHRpcERhdGEgJiYgKFxuLy8gICAgICAgICA8VG9vbHRpcFdpdGhCb3VuZHNcbi8vICAgICAgICAgICB0b3A9e3Rvb2x0aXBUb3AtMjUwfVxuLy8gICAgICAgICAgIGxlZnQ9e3Rvb2x0aXBMZWZ0fVxuLy8gICAgICAgICAgIHN0eWxlPXt7XG4vLyAgICAgICAgICAgICB3aWR0aDogJzEyMHB4Jyxcbi8vICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJyM0ZDRkNGQnLFxuLy8gICAgICAgICAgICAgY29sb3I6ICd3aGl0ZScsXG4vLyAgICAgICAgICAgICBwYWRkaW5nOiAnMC41cmVtJyxcbi8vICAgICAgICAgICAgIGJvcmRlclJhZGl1czogJzRweCcsXG4vLyAgICAgICAgICAgICBmb250U2l6ZTogJzEwcHgnLFxuLy8gICAgICAgICAgIH19XG4vLyAgICAgICAgID5cbi8vICAgICAgICAgICA8ZGl2PkRhdGU6IHt0aW1lRm9ybWF0KCclYiAlZCwgJVknKSh4QWNjZXNzb3IodG9vbHRpcERhdGEpKX08L2Rpdj5cbi8vICAgICAgICAgICA8ZGl2PlZhbHVlOiB7eUFjY2Vzc29yKHRvb2x0aXBEYXRhKX08L2Rpdj5cbi8vICAgICAgICAgPC9Ub29sdGlwV2l0aEJvdW5kcz5cbi8vICAgICAgICl9XG4vLyAgICAgPC9kaXY+XG4vLyAgICk7XG4vLyB9XG5cbi8vIGV4cG9ydCB7IExpbmVDaGFydCB9O1xuXG5cblxuXG5cbmltcG9ydCBSZWFjdCwgeyB1c2VNZW1vLCB1c2VDYWxsYmFjayB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGV4dGVudCwgYmlzZWN0b3IgfSBmcm9tICdkMy1hcnJheSc7XG5pbXBvcnQgeyB0aW1lRm9ybWF0IH0gZnJvbSAnZDMtdGltZS1mb3JtYXQnO1xuaW1wb3J0IHsgQXhpc0JvdHRvbSwgQXhpc1JpZ2h0IH0gZnJvbSAnQHZpc3gvYXhpcyc7XG5pbXBvcnQgeyBMaW5lUGF0aCwgQmFyIH0gZnJvbSAnQHZpc3gvc2hhcGUnO1xuaW1wb3J0IHsgR3JvdXAgfSBmcm9tICdAdmlzeC9ncm91cCc7XG5pbXBvcnQgeyBzY2FsZUxpbmVhciwgc2NhbGVUaW1lIH0gZnJvbSAnQHZpc3gvc2NhbGUnO1xuaW1wb3J0IHsgR3JpZFJvd3MgfSBmcm9tIFwiQHZpc3gvZ3JpZFwiO1xuaW1wb3J0IHsgY3VydmVMaW5lYXIgfSBmcm9tICdAdmlzeC9jdXJ2ZSc7XG5pbXBvcnQgeyB3aXRoVG9vbHRpcCwgVG9vbHRpcFdpdGhCb3VuZHMsIGRlZmF1bHRTdHlsZXMgfSBmcm9tICdAdmlzeC90b29sdGlwJztcbmltcG9ydCB7IGxvY2FsUG9pbnQgfSBmcm9tICdAdmlzeC9ldmVudCc7XG5cbmltcG9ydCB7IGRhdGEgfSBmcm9tICcuLi9kYXRhL2xpbmUtY2hhcnQnO1xuaW1wb3J0IHsgZ2V0RGltZW5zaW9ucywgeEFjY2Vzc29yLCB5QWNjZXNzb3IgfSBmcm9tICcjL3V0aWxzL2xpbmUtY2hhcnQnO1xuXG5jb25zdCBmb3JtYXREYXRlID0gdGltZUZvcm1hdCgnJWIgJWQsICVIOiVNJyk7XG5jb25zdCB0b29sdGlwU3R5bGVzID0ge1xuICAuLi5kZWZhdWx0U3R5bGVzLFxuICBiYWNrZ3JvdW5kOiAncmdiYSgwLCAwLCAwLCAwLjkpJyxcbiAgYm9yZGVyUmFkaXVzOiAnNHB4JyxcbiAgY29sb3I6ICd3aGl0ZScsXG59O1xuXG5jb25zdCBiaXNlY3REYXRlID0gYmlzZWN0b3IoZCA9PiB4QWNjZXNzb3IoZCkpLmxlZnQ7XG5cbnR5cGUgUHJvcHMgPSB7XG4gIHdpZHRoOiBudW1iZXI7XG4gIGhlaWdodDogbnVtYmVyO1xufTtcblxuZnVuY3Rpb24gTGluZUNoYXJ0KHsgd2lkdGgsIGhlaWdodCwgc2hvd1Rvb2x0aXAsIGhpZGVUb29sdGlwLCB0b29sdGlwRGF0YSwgdG9vbHRpcExlZnQsIHRvb2x0aXBUb3AgfTogUHJvcHMgJiBhbnkpIHtcbiAgY29uc3QgeyBtYXJnaW4sIGJvdW5kZWRXaWR0aCwgYm91bmRlZEhlaWdodCB9ID0gZ2V0RGltZW5zaW9ucyh7IHdpZHRoLCBoZWlnaHQgfSk7XG4gIGNvbnN0IExwWVZhbHVlID0gNTQzMDAuMjsgXG4gIGNvbnN0IExhdGVzdFZhbHVlID0gNTk5ODAuOTtcblxuICBjb25zdCB4U2NhbGUgPSB1c2VNZW1vKCgpID0+IHNjYWxlVGltZSh7XG4gICAgZG9tYWluOiBleHRlbnQoZGF0YSwgeEFjY2Vzc29yKSBhcyBbRGF0ZSwgRGF0ZV0sXG4gICAgcmFuZ2U6IFswLCBib3VuZGVkV2lkdGhdLFxuICAgIG5pY2U6IHRydWUsXG4gIH0pLCBbYm91bmRlZFdpZHRoXSk7XG5cbiAgY29uc3QgeVNjYWxlID0gdXNlTWVtbygoKSA9PiBzY2FsZUxpbmVhcih7XG4gICAgZG9tYWluOiBleHRlbnQoZGF0YSwgeUFjY2Vzc29yKSBhcyBbbnVtYmVyLCBudW1iZXJdLFxuICAgIHJhbmdlOiBbYm91bmRlZEhlaWdodCwgMF0sXG4gICAgbmljZTogdHJ1ZSxcbiAgfSksIFtib3VuZGVkSGVpZ2h0XSk7XG5cbiAgY29uc3QgaGFuZGxlVG9vbHRpcCA9IHVzZUNhbGxiYWNrKChldmVudCkgPT4ge1xuICAgIGNvbnN0IHsgeCB9ID0gbG9jYWxQb2ludChldmVudCkgfHwgeyB4OiAwIH07XG4gICAgY29uc3QgeDAgPSB4U2NhbGUuaW52ZXJ0KHgpO1xuICAgIGNvbnN0IGluZGV4ID0gYmlzZWN0RGF0ZShkYXRhLCB4MCwgMSk7XG4gICAgY29uc3QgZDAgPSBkYXRhW2luZGV4IC0gMV07XG4gICAgY29uc3QgZDEgPSBkYXRhW2luZGV4XTtcbiAgICBsZXQgZCA9IGQwO1xuICAgIGlmIChkMSAmJiB4QWNjZXNzb3IoZDEpKSB7XG4gICAgICBkID0geDAudmFsdWVPZigpIC0geEFjY2Vzc29yKGQwKS52YWx1ZU9mKCkgPiB4QWNjZXNzb3IoZDEpLnZhbHVlT2YoKSAtIHgwLnZhbHVlT2YoKSA/IGQxIDogZDA7XG4gICAgfVxuICAgIHNob3dUb29sdGlwKHtcbiAgICAgIHRvb2x0aXBEYXRhOiBkLFxuICAgICAgdG9vbHRpcExlZnQ6IHgsXG4gICAgICB0b29sdGlwVG9wOiB5U2NhbGUoeUFjY2Vzc29yKGQpKSxcbiAgICB9KTtcbiAgfSwgW3Nob3dUb29sdGlwLCB5U2NhbGUsIHhTY2FsZV0pO1xuXG4gIGNvbnN0IGN1c3RvbVlQb3NpdGlvbiA9IHlTY2FsZShMcFlWYWx1ZSk7IFxuICBjb25zdCB5VGlja1ZhbHVlcyA9IHlTY2FsZS50aWNrcyg4KTtcblxuICBpZiAoIXlUaWNrVmFsdWVzLmluY2x1ZGVzKExwWVZhbHVlKSkge1xuICAgIHlUaWNrVmFsdWVzLnB1c2goTHBZVmFsdWUpO1xuICB9XG4gIGlmICgheVRpY2tWYWx1ZXMuaW5jbHVkZXMoTGF0ZXN0VmFsdWUpKSB7XG4gICAgeVRpY2tWYWx1ZXMucHVzaChMYXRlc3RWYWx1ZSk7XG4gIH1cblxuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPVwidy1maXRcIj5cbiAgICAgIDxzdmcgd2lkdGg9e3dpZHRofSBoZWlnaHQ9e2hlaWdodH0gcm9sZT1cImZpZ3VyZVwiPlxuICAgICAgICA8cmVjdCB4PXswfSB5PXswfSB3aWR0aD17d2lkdGh9IGhlaWdodD17aGVpZ2h0fSBmaWxsPVwidHJhbnNwYXJlbnRcIiAvPlxuICAgICAgICA8R3JvdXAgdG9wPXttYXJnaW4udG9wfSBsZWZ0PXttYXJnaW4ubGVmdH0+XG4gICAgICAgICAgPEdyaWRSb3dzIHNjYWxlPXt5U2NhbGV9IHdpZHRoPXtib3VuZGVkV2lkdGh9IHN0cm9rZURhc2hhcnJheT1cIjEsM1wiIHN0cm9rZT1cIiMyNjI2MjZcIiBwb2ludGVyRXZlbnRzPVwibm9uZVwiIC8+XG4gICAgICAgICAgPExpbmVQYXRoXG4gICAgICAgICAgICBjdXJ2ZT17Y3VydmVMaW5lYXJ9XG4gICAgICAgICAgICBkYXRhPXtkYXRhfVxuICAgICAgICAgICAgc3Ryb2tlPXtcIiNGRkNBNDNcIn1cbiAgICAgICAgICAgIHN0cm9rZVdpZHRoPXsxLjV9XG4gICAgICAgICAgICB4PXsoZCkgPT4geFNjYWxlKHhBY2Nlc3NvcihkKSkgPz8gMH1cbiAgICAgICAgICAgIHk9eyhkKSA9PiB5U2NhbGUoeUFjY2Vzc29yKGQpKSA/PyAwfVxuICAgICAgICAgIC8+XG4gICAgICAgICAgPEJhclxuICAgICAgICAgICAgeD17MH1cbiAgICAgICAgICAgIHk9ezB9XG4gICAgICAgICAgICB3aWR0aD17Ym91bmRlZFdpZHRofVxuICAgICAgICAgICAgaGVpZ2h0PXtib3VuZGVkSGVpZ2h0fVxuICAgICAgICAgICAgZmlsbD1cInRyYW5zcGFyZW50XCJcbiAgICAgICAgICAgIG9uTW91c2VNb3ZlPXtoYW5kbGVUb29sdGlwfVxuICAgICAgICAgICAgb25Nb3VzZUxlYXZlPXtoaWRlVG9vbHRpcH1cbiAgICAgICAgICAvPlxuICAgICAgICAgIHtjdXN0b21ZUG9zaXRpb24gJiYgKFxuICAgICAgICAgICAgPGxpbmVcbiAgICAgICAgICAgICAgeDE9ezB9XG4gICAgICAgICAgICAgIHgyPXtib3VuZGVkV2lkdGh9XG4gICAgICAgICAgICAgIHkxPXtjdXN0b21ZUG9zaXRpb259XG4gICAgICAgICAgICAgIHkyPXtjdXN0b21ZUG9zaXRpb259XG4gICAgICAgICAgICAgIHN0cm9rZT1cIndoaXRlXCJcbiAgICAgICAgICAgICAgc3Ryb2tlV2lkdGg9ezF9XG4gICAgICAgICAgICAgIHN0cm9rZURhc2hhcnJheT1cIjMsNVwiXG4gICAgICAgICAgICAvPlxuICAgICAgICAgICl9XG4gICAgICAgICAgPEF4aXNSaWdodFxuICAgICAgICAgICAgbGVmdD17Ym91bmRlZFdpZHRoICsgbWFyZ2luLnJpZ2h0IC0gNDB9XG4gICAgICAgICAgICBzY2FsZT17eVNjYWxlfVxuICAgICAgICAgICAgdG9wPXswfVxuICAgICAgICAgICAgaGlkZUF4aXNMaW5lPXt0cnVlfVxuICAgICAgICAgICAgaGlkZVRpY2tzPXt0cnVlfVxuICAgICAgICAgICAgdGlja1ZhbHVlcz17eVRpY2tWYWx1ZXN9XG4gICAgICAgICAgICB0aWNrRm9ybWF0PXsodmFsdWUpID0+IGAke051bWJlcih2YWx1ZSkudG9GaXhlZCgxKX1gfVxuICAgICAgICAgICAgdGlja0xhYmVsUHJvcHM9eygpID0+ICh7XG4gICAgICAgICAgICAgIGZpbGw6ICcjQTZBNkE2JyxcbiAgICAgICAgICAgICAgZm9udFNpemU6IDksXG4gICAgICAgICAgICAgIHRleHRBbmNob3I6ICdzdGFydCcsXG4gICAgICAgICAgICB9KX1cbiAgICAgICAgICAgIHRpY2tDb21wb25lbnQ9eyh7IGZvcm1hdHRlZFZhbHVlLCB4LCB5IH0pID0+IHtcbiAgICAgICAgICAgICAgaWYgKGZvcm1hdHRlZFZhbHVlID09PSB1bmRlZmluZWQpIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICBjb25zdCBudW1Gb3JtYXR0ZWRWYWx1ZSA9IE51bWJlcihmb3JtYXR0ZWRWYWx1ZSk7IFxuICAgICAgICAgICAgICBjb25zdCBpc0xQVmFsdWUgPSBudW1Gb3JtYXR0ZWRWYWx1ZSA9PT0gTHBZVmFsdWU7XG4gICAgICAgICAgICAgIGNvbnN0IGlzTGF0ZXN0VmFsdWUgPSBudW1Gb3JtYXR0ZWRWYWx1ZSA9PT0gTGF0ZXN0VmFsdWU7XG4gICAgICAgICAgICAgIGNvbnN0IHRleHQgPSBpc0xQVmFsdWUgPyBgTFAgJHtMcFlWYWx1ZS50b0ZpeGVkKDEpfWAgOiBpc0xhdGVzdFZhbHVlID8gYCR7TGF0ZXN0VmFsdWUudG9GaXhlZCgxKX1gIDogZm9ybWF0dGVkVmFsdWU7XG5cbiAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICA8dGV4dFxuICAgICAgICAgICAgICAgICAgZmlsbD17aXNMUFZhbHVlID8gJ3doaXRlJyA6IGlzTGF0ZXN0VmFsdWUgPyAncGluaycgOiAnI0E2QTZBNid9XG4gICAgICAgICAgICAgICAgICBmb250U2l6ZT17OX1cbiAgICAgICAgICAgICAgICAgIGZvbnRXZWlnaHQ9e2lzTGF0ZXN0VmFsdWUgPyAnNzAwJyA6ICdub3JtYWwnfVxuICAgICAgICAgICAgICAgICAgeD17eCAtIDEwfVxuICAgICAgICAgICAgICAgICAgeT17eX1cbiAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICB7dGV4dH1cbiAgICAgICAgICAgICAgICA8L3RleHQ+XG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9fVxuICAgICAgICAgIC8+XG4gICAgICAgICAgPEF4aXNCb3R0b21cbiAgICAgICAgICAgIHJhbmdlUGFkZGluZz17NDF9XG4gICAgICAgICAgICB0b3A9e2JvdW5kZWRIZWlnaHR9XG4gICAgICAgICAgICBoaWRlQXhpc0xpbmU9e3RydWV9XG4gICAgICAgICAgICBoaWRlVGlja3M9e3RydWV9XG4gICAgICAgICAgICBzY2FsZT17eFNjYWxlfVxuICAgICAgICAgICAgdGlja0Zvcm1hdD17KGQpID0+IChkIGluc3RhbmNlb2YgRGF0ZSA/IHRpbWVGb3JtYXQoJyVIOiVNJykoZCkgOiAnJyl9XG4gICAgICAgICAgICB0aWNrTGFiZWxQcm9wcz17KCkgPT4gKHtcbiAgICAgICAgICAgICAgZmlsbDogJ3doaXRlJyxcbiAgICAgICAgICAgICAgZm9udFNpemU6IDgsXG4gICAgICAgICAgICAgIHRleHRBbmNob3I6ICdtaWRkbGUnLFxuICAgICAgICAgICAgfSl9XG4gICAgICAgICAgLz5cbiAgICAgICAgPC9Hcm91cD5cbiAgICAgICAge3Rvb2x0aXBEYXRhICYmIChcbiAgICAgICAgICA8Zz5cbiAgICAgICAgICAgIDxjaXJjbGUgY3g9e3Rvb2x0aXBMZWZ0fSBjeT17dG9vbHRpcFRvcH0gcj17NH0gZmlsbD1cIndoaXRlXCIgc3Ryb2tlPVwiYmxhY2tcIiBzdHJva2VXaWR0aD17MX0gLz5cbiAgICAgICAgICA8L2c+XG4gICAgICAgICl9XG4gICAgICA8L3N2Zz5cbiAgICAgIHt0b29sdGlwRGF0YSAmJiAoXG4gICAgICAgIDxkaXY+XG4gICAgICAgICAgPFRvb2x0aXBXaXRoQm91bmRzIHRvcD17dG9vbHRpcFRvcCsxMH0gbGVmdD17dG9vbHRpcExlZnR9IHN0eWxlPXt0b29sdGlwU3R5bGVzfT5cbiAgICAgICAgICAgIHtgVmFsdWU6ICR7eUFjY2Vzc29yKHRvb2x0aXBEYXRhKX1gfVxuICAgICAgICAgIDwvVG9vbHRpcFdpdGhCb3VuZHM+XG4gICAgICAgIDwvZGl2PlxuICAgICAgKX1cbiAgICA8L2Rpdj5cbiAgKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgd2l0aFRvb2x0aXAoTGluZUNoYXJ0KTtcblxuIl0sIm5hbWVzIjpbIlJlYWN0IiwidXNlTWVtbyIsInVzZUNhbGxiYWNrIiwiZXh0ZW50IiwiYmlzZWN0b3IiLCJ0aW1lRm9ybWF0IiwiQXhpc0JvdHRvbSIsIkF4aXNSaWdodCIsIkxpbmVQYXRoIiwiQmFyIiwiR3JvdXAiLCJzY2FsZUxpbmVhciIsInNjYWxlVGltZSIsIkdyaWRSb3dzIiwiY3VydmVMaW5lYXIiLCJ3aXRoVG9vbHRpcCIsIlRvb2x0aXBXaXRoQm91bmRzIiwiZGVmYXVsdFN0eWxlcyIsImxvY2FsUG9pbnQiLCJkYXRhIiwiZ2V0RGltZW5zaW9ucyIsInhBY2Nlc3NvciIsInlBY2Nlc3NvciIsImZvcm1hdERhdGUiLCJ0b29sdGlwU3R5bGVzIiwiYmFja2dyb3VuZCIsImJvcmRlclJhZGl1cyIsImNvbG9yIiwiYmlzZWN0RGF0ZSIsImQiLCJsZWZ0IiwiTGluZUNoYXJ0Iiwid2lkdGgiLCJoZWlnaHQiLCJzaG93VG9vbHRpcCIsImhpZGVUb29sdGlwIiwidG9vbHRpcERhdGEiLCJ0b29sdGlwTGVmdCIsInRvb2x0aXBUb3AiLCJtYXJnaW4iLCJib3VuZGVkV2lkdGgiLCJib3VuZGVkSGVpZ2h0IiwiTHBZVmFsdWUiLCJMYXRlc3RWYWx1ZSIsInhTY2FsZSIsImRvbWFpbiIsInJhbmdlIiwibmljZSIsInlTY2FsZSIsImhhbmRsZVRvb2x0aXAiLCJldmVudCIsIngiLCJ4MCIsImludmVydCIsImluZGV4IiwiZDAiLCJkMSIsInZhbHVlT2YiLCJjdXN0b21ZUG9zaXRpb24iLCJ5VGlja1ZhbHVlcyIsInRpY2tzIiwiaW5jbHVkZXMiLCJwdXNoIiwiZGl2IiwiY2xhc3NOYW1lIiwic3ZnIiwicm9sZSIsInJlY3QiLCJ5IiwiZmlsbCIsInRvcCIsInNjYWxlIiwic3Ryb2tlRGFzaGFycmF5Iiwic3Ryb2tlIiwicG9pbnRlckV2ZW50cyIsImN1cnZlIiwic3Ryb2tlV2lkdGgiLCJvbk1vdXNlTW92ZSIsIm9uTW91c2VMZWF2ZSIsImxpbmUiLCJ4MSIsIngyIiwieTEiLCJ5MiIsInJpZ2h0IiwiaGlkZUF4aXNMaW5lIiwiaGlkZVRpY2tzIiwidGlja1ZhbHVlcyIsInRpY2tGb3JtYXQiLCJ2YWx1ZSIsIk51bWJlciIsInRvRml4ZWQiLCJ0aWNrTGFiZWxQcm9wcyIsImZvbnRTaXplIiwidGV4dEFuY2hvciIsInRpY2tDb21wb25lbnQiLCJmb3JtYXR0ZWRWYWx1ZSIsInVuZGVmaW5lZCIsIm51bUZvcm1hdHRlZFZhbHVlIiwiaXNMUFZhbHVlIiwiaXNMYXRlc3RWYWx1ZSIsInRleHQiLCJmb250V2VpZ2h0IiwicmFuZ2VQYWRkaW5nIiwiRGF0ZSIsImciLCJjaXJjbGUiLCJjeCIsImN5IiwiciIsInN0eWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/line-chart.tsx\n',
        ),
      );

      /***/
    },
});
